// This file is auto-generated by @hey-api/openapi-ts

import type {CancelablePromise} from './core/CancelablePromise';
import {OpenAPI} from './core/OpenAPI';
import {request as __request} from './core/request';
import type {
  AddData,
  AddElementData,
  AddElementResponse,
  AddFormatterData,
  AddFormatterResponse,
  AddGroupData,
  AddGroupResponse,
  AddIdentifierData,
  AddIdentifierResponse,
  AddLanguagesData,
  AddLanguagesResponse,
  AddLogoData,
  AddLogoResponse,
  AddMapserverData,
  AddMapserverResponse,
  AddPageUploadingFileData,
  AddPageUploadingFileResponse,
  AddPageWithoutUploadingFileData,
  AddPageWithoutUploadingFileResponse,
  AddResponse,
  AddSamplesData,
  AddSamplesResponse,
  AddSourceData,
  AddSourceResponse,
  AddTemplatesData,
  AddTemplatesResponse,
  AddToUserSelectionData,
  AddToUserSelectionResponse,
  AddTranslationsData,
  AddTranslationsForData,
  AddTranslationsForResponse,
  AddTranslationsResponse,
  AnalyzeLinksData,
  AnalyzeLinksResponse,
  AnalyzeRecordLinksData,
  AnalyzeRecordLinksResponse,
  ApplyQueryData,
  ApplyQueryResponse,
  ApproveData,
  ApproveResponse,
  AssignHarvestedRecordToSourceData,
  AssignHarvestedRecordToSourceResponse,
  BatchEditData,
  BatchEditResponse,
  BuildFilterData,
  BuildFilterResponse,
  BuildSldData,
  BuildSldResponse,
  CallStepData,
  CallStepResponse,
  CancelEditsData,
  CancelEditsResponse,
  CheckDoiStatusData,
  CheckDoiStatusResponse,
  CheckDoiUrlData,
  CheckDoiUrlResponse,
  CheckHarvesterPropertyExistData,
  CheckHarvesterPropertyExistResponse,
  CheckUserPropertyExistData,
  CheckUserPropertyExistResponse,
  CheckValidationData,
  CheckValidationResponse,
  CleanTranslationsPackagesCacheResponse,
  CleanValidationStatusData,
  CleanValidationStatusResponse,
  ClearData,
  ClearFormatterCacheResponse,
  ClearResponse,
  CloseTaskData,
  CloseTaskResponse,
  CommitIndexChangesResponse,
  CreateData,
  CreateDoiData,
  CreateDoiResponse,
  CreatePersistentSelectionTypeData,
  CreatePersistentSelectionTypeResponse,
  CreateResponse,
  CreateUserCustomSearchData,
  CreateUserCustomSearchResponse,
  CreateUserData,
  CreateUserResponse,
  DeleteAllHistoryAndStatusResponse,
  DeleteAllRecordStatusData,
  DeleteAllRecordStatusResponse,
  DeleteAttributeData,
  DeleteAttributeResponse,
  DeleteElementData,
  DeleteElementResponse,
  DeleteFormatterData,
  DeleteFormatterResponse,
  DeleteFromUserSelectionData,
  DeleteFromUserSelectionResponse,
  DeleteGroupData,
  DeleteGroupResponse,
  DeleteIdentifierData,
  DeleteIdentifierResponse,
  DeleteLanguageData,
  DeleteLanguageResponse,
  DeleteLogoData,
  DeleteLogoResponse,
  DeleteMapserverData,
  DeleteMapserverResourceData,
  DeleteMapserverResponse,
  DeletePageData,
  DeletePageResponse,
  DeleteRecordData,
  DeleteRecordResponse,
  DeleteRecordsData,
  DeleteRecordsResponse,
  DeleteRecordStatusData,
  DeleteRecordStatusResponse,
  DeleteResponse,
  DeleteSourceData,
  DeleteSourceResponse,
  DeleteTagData,
  DeleteTagForRecordsData,
  DeleteTagForRecordsResponse,
  DeleteTagResponse,
  DeleteTagsData,
  DeleteTagsResponse,
  DeleteThesaurusData,
  DeleteThesaurusResponse,
  DeleteTranslationsData,
  DeleteTranslationsResponse,
  DeleteUiConfigurationData,
  DeleteUiConfigurationResponse,
  DeleteUserCustomSerachData,
  DeleteUserCustomSerachResponse,
  DeleteUserData,
  DeleteUserFeedbackData,
  DeleteUserFeedbackResponse,
  DeleteUserResponse,
  DeleteUserSelectionData,
  DeleteUserSelectionResponse,
  DelResourceData,
  DelResourceResponse,
  DelResourcesData,
  DelResourcesResponse,
  DescribeData,
  DescribeResourceData,
  DescribeResourceResponse,
  DescribeResponse,
  DeteleSldResponse,
  DownloadFormatterData,
  DownloadFormatterResponse,
  DownloadResourceData,
  DownloadResourceResponse,
  DownloadSldData,
  DownloadSldResponse,
  EnableVersionControlData,
  EnableVersionControlForRecordsData,
  EnableVersionControlForRecordsResponse,
  EnableVersionControlResponse,
  ExportAsCsvData,
  ExportAsCsvResponse,
  ExportAsMefData,
  ExportAsMefResponse,
  ExportAsPdfData,
  ExportAsPdfResponse,
  ExtractEntriesData,
  ExtractEntriesResponse,
  FeedsData,
  FeedsResponse,
  GetActiveUsersData,
  GetActiveUsersResponse,
  GetAllRecordExtentAsImageData,
  GetAllRecordExtentAsImageResponse,
  GetAllRecordExtentAsJsonData,
  GetAllRecordExtentAsJsonResponse,
  GetAllResourcesData,
  GetAllResourcesResponse,
  GetAllUserCustomSearchesData,
  GetAllUserCustomSearchesPageData,
  GetAllUserCustomSearchesPageResponse,
  GetAllUserCustomSearchesResponse,
  GetApplicationLanguagesResponse,
  GetAsRdfData,
  GetAsRdfResponse,
  GetAssociatedResourcesData,
  GetAssociatedResourcesForRecordsData,
  GetAssociatedResourcesForRecordsResponse,
  GetAssociatedResourcesResponse,
  GetCodelistsTranslationsData,
  GetCodelistsTranslationsResponse,
  GetConfigurationData,
  GetConfigurationResponse,
  GetConfigurationsData,
  GetConfigurationsResponse,
  GetCrsData,
  GetCrsResponse,
  GetCrsTypesResponse,
  GetCssStyleResponse,
  GetCustomTranslationsData,
  GetCustomTranslationsResponse,
  GetData,
  GetDbTranslationsResponse,
  GetEditorAssociatedPanelConfigurationData,
  GetEditorAssociatedPanelConfigurationResponse,
  GetElementDetailsData,
  GetElementDetailsResponse,
  GetEntryData,
  GetEntryResponse,
  GetFeatureCatalogData,
  GetFeatureCatalogResponse,
  GetFeaturedUserCustomSearchesData,
  GetFeaturedUserCustomSearchesResponse,
  GetFormatterFileContentData,
  GetFormatterFileContentResponse,
  GetFormatterFilesData,
  GetFormatterFilesResponse,
  GetGeomAsImageData,
  GetGeomAsImageResponse,
  GetGroupData,
  GetGroupLogoData,
  GetGroupLogoResponse,
  GetGroupResponse,
  GetGroupsData,
  GetGroupsResponse,
  GetGroupUsersData,
  GetGroupUsersResponse,
  GetIdentifiersData,
  GetIdentifiersResponse,
  GetInformationResponse,
  GetIsoLanguagesResponse,
  GetKeywordByIdData,
  GetKeywordByIdResponse,
  GetKeywordByIdsData,
  GetKeywordByIdsResponse,
  GetLanguagesResponse,
  GetLastActivityData,
  GetLastActivityInAzipResponse,
  GetLastActivityResponse,
  GetLogFilesResponse,
  GetLogoData,
  GetLogoResponse,
  GetLogosResponse,
  GetMapserverData,
  GetMapserverResourceData,
  GetMapserversResponse,
  GetMapservicesResponse,
  GetMeResponse,
  GetMetadataRatingData,
  GetMetadataRatingResponse,
  GetNotificationLevelResponse,
  GetOneRecordExtentAsImageData,
  GetOneRecordExtentAsImageResponse,
  GetOperationsResponse,
  GetPageContentData,
  GetPageContentResponse,
  GetPageData,
  GetPageFormatsResponse,
  GetPageResponse,
  GetPageSectionsResponse,
  GetPageStatusResponse,
  GetProcessReportResponse,
  GetProxyConfigurationResponse,
  GetPublicationOptionsResponse,
  GetRatingCriteriaResponse,
  GetRecordAsJsonData,
  GetRecordAsJsonResponse,
  GetRecordAsXmlData,
  GetRecordAsXmlResponse,
  GetRecordAsZipData,
  GetRecordAsZipResponse,
  GetRecordData,
  GetRecordFormattedByData,
  GetRecordFormattedByResponse,
  GetRecordLinksAsCsvData,
  GetRecordLinksAsCsvResponse,
  GetRecordLinksData,
  GetRecordLinksPostData,
  GetRecordLinksPostResponse,
  GetRecordLinksResponse,
  GetRecordOwnersResponse,
  GetRecordPermalinkData,
  GetRecordPermalinkResponse,
  GetRecordPopularityData,
  GetRecordPopularityResponse,
  GetRecordResponse,
  GetRecordSharingSettingsData,
  GetRecordSharingSettingsResponse,
  GetRecordStatusHistoryByTypeData,
  GetRecordStatusHistoryByTypeResponse,
  GetRecordStatusHistoryData,
  GetRecordStatusHistoryResponse,
  GetRecordTagsData,
  GetRecordTagsResponse,
  GetRegionsData,
  GetRegionsResponse,
  GetRegionTypesResponse,
  GetRelatedResourcesData,
  GetRelatedResourcesResponse,
  GetReportDataDownloadsData,
  GetReportDataDownloadsResponse,
  GetReportDataUploadsData,
  GetReportDataUploadsResponse,
  GetReportInternalMetadataData,
  GetReportInternalMetadataResponse,
  GetReportUpdatedMetadataData,
  GetReportUpdatedMetadataResponse,
  GetResourceData,
  GetResourceResponse,
  GetResponse,
  GetRobotsTextResponse,
  GetSavedQueriesData,
  GetSavedQueriesResponse,
  GetSchemaCodelistsWithDetailsData,
  GetSchemaCodelistsWithDetailsResponse,
  GetSchemaTranslationsData,
  GetSchemaTranslationsResponse,
  GetSelectionListResponse,
  GetSelectionRecordsData,
  GetSelectionRecordsResponse,
  GetSelectionsAndSizeResponse,
  GetSettingsDetailsData,
  GetSettingsDetailsResponse,
  GetSettingsSetData,
  GetSettingsSetResponse,
  GetSharingSettingsResponse,
  GetSitemapData,
  GetSitemapResponse,
  GetSiteOrPortalDescriptionResponse,
  GetSldResponse,
  GetSourcesByTypeData,
  GetSourcesByTypeResponse,
  GetSourcesData,
  GetSourcesResponse,
  GetStandardConfigurationsResponse,
  GetStatusByTypeData,
  GetStatusByTypeResponse,
  GetStatusData,
  GetStatusListResponse,
  GetStatusResponse,
  GetSuggestionsData,
  GetSuggestionsResponse,
  GetSystemInfoResponse,
  GetTagData,
  GetTagResponse,
  GetTagsResponse,
  GetTestSuitesData,
  GetTestSuitesResponse,
  GetThesaurusData,
  GetThesaurusResponse,
  GetTranslationProviderNamesResponse,
  GetTranslationsData,
  GetTranslationsPackageData,
  GetTranslationsPackageResponse,
  GetTranslationsPackagesResponse,
  GetTranslationsResponse,
  GetUiConfigurationData,
  GetUiConfigurationResponse,
  GetUiConfigurationsResponse,
  GetUserCommentData,
  GetUserCommentResponse,
  GetUserCommentsData,
  GetUserCommentsOnArecordData,
  GetUserCommentsOnArecordResponse,
  GetUserCommentsResponse,
  GetUserCustomSearchData,
  GetUserCustomSearchesResponse,
  GetUserCustomSearchResponse,
  GetUserData,
  GetUserIdenticonData,
  GetUserIdenticonResponse,
  GetUserResponse,
  GetUsersResponse,
  GetWorkflowStatusByTypeData,
  GetWorkflowStatusByTypeResponse,
  GetXslTransformationsResponse,
  ImportCsvAsThesaurusData,
  ImportCsvAsThesaurusResponse,
  ImportSpatialEntriesData,
  ImportSpatialEntriesResponse,
  IncreaseRecordPopularityData,
  IncreaseRecordPopularityResponse,
  IndexAndDbSynchronizationStatusResponse,
  IndexCommitResponse,
  IndexData,
  IndexResponse2,
  IndexSiteData,
  IndexSiteResponse,
  IndexStatusResponse,
  InsertData,
  InsertFileData,
  InsertFileResponse,
  InsertOgcMapContextFileData,
  InsertOgcMapContextFileResponse,
  InsertResponse,
  IsCasEnabledResponse,
  IsIndexingResponse,
  IsReadOnlyResponse,
  ListFormattersData,
  ListFormattersResponse,
  ListPagesData,
  MsearchData,
  MsearchResponse,
  NewUserFeedbackData,
  NewUserFeedbackResponse,
  PatchResourceData,
  PatchResourceResponse,
  PreviewBatchEditData,
  PreviewBatchEditResponse,
  PreviewExtractedEntriesData,
  PreviewExtractedEntriesResponse,
  PreviewProcessRecordsData,
  PreviewProcessRecordsResponse,
  PreviewProcessSearchAndReplaceData,
  PreviewProcessSearchAndReplaceResponse,
  PreviewUpdatedRecordEntriesData,
  PreviewUpdatedRecordEntriesResponse,
  ProcessRecordData,
  ProcessRecordPreviewData,
  ProcessRecordPreviewResponse,
  ProcessRecordResponse,
  ProcessRecordsData,
  ProcessRecordsResponse,
  ProcessSearchAndReplaceData,
  ProcessSearchAndReplaceResponse,
  PublishData,
  PublishFeedbackData,
  PublishFeedbackResponse,
  PublishMapserverResourceData,
  PublishMultipleRecordsData,
  PublishMultipleRecordsResponse,
  PublishResponse,
  PurgeAllResponse,
  PutResourceData,
  PutResourceFromUrlData,
  PutResourceFromUrlResponse,
  PutResourceResponse,
  PutTagData,
  PutTagResponse,
  PutUiConfigurationData,
  PutUiConfigurationResponse,
  RateRecordData,
  RateRecordResponse,
  RegisterUserData,
  RegisterUserResponse,
  ReloadSchemaResponse,
  RemoveAllTranslationsResponse,
  ReorderElementData,
  ReorderElementResponse,
  ResetUserPasswordData,
  ResetUserPasswordResponse,
  RestoreAtStatusSaveData,
  RestoreAtStatusSaveResponse,
  RetrieveAllUserGroupsResponse,
  RetrieveUserGroupsData,
  RetrieveUserGroupsResponse,
  SaveCssStyleData,
  SaveCssStyleResponse,
  SaveEditsData,
  SaveEditsResponse,
  SaveOwnersData,
  SaveOwnersResponse,
  SaveSettingsData,
  SaveSettingsResponse,
  SaveThumbnailData,
  SaveThumbnailResponse,
  ScanResponse,
  SearchAndReplaceData,
  SearchAndReplaceResponse,
  SearchCrsData,
  SearchCrsResponse,
  SearchData,
  SearchKeywordsData,
  SearchKeywordsResponse,
  SearchResponse,
  SendEmailToContactData,
  SendEmailToContactResponse,
  SendPasswordByEmailData,
  SendPasswordByEmailResponse,
  SetGroupAndOwnerData,
  SetGroupAndOwnerResponse,
  SetLogoData,
  SetLogoResponse,
  SetRecordGroupData,
  SetRecordGroupResponse,
  SetRecordOwnershipData,
  SetRecordOwnershipResponse,
  SetStatusData,
  SetStatusResponse,
  ShareData,
  ShareMultipleRecordsData,
  ShareMultipleRecordsResponse,
  ShareResponse,
  ShowStatusAfterData,
  ShowStatusAfterResponse,
  ShowStatusBeforeData,
  ShowStatusBeforeResponse,
  StartEditingData,
  StartEditingResponse,
  SubmitData,
  SubmitResponse,
  TagRecordData,
  TagRecordResponse,
  TagRecordsData,
  TagRecordsResponse,
  TestMailConfigurationResponse,
  TriggerResponse,
  UnpublishData,
  UnpublishMultipleRecordsData,
  UnpublishMultipleRecordsResponse,
  UnpublishResponse,
  UnregisterDoiData,
  UnregisterDoiResponse,
  UpdateCustomUserSearchData,
  UpdateCustomUserSearchResponse,
  UpdateFormatterFileData,
  UpdateFormatterFileResponse,
  UpdateGroupData,
  UpdateGroupResponse,
  UpdateIdentifierData,
  UpdateIdentifierResponse,
  UpdateMapserverAuthData,
  UpdateMapserverAuthResponse,
  UpdateMapserverData,
  UpdateMapserverResponse,
  UpdatePageData,
  UpdatePageResponse,
  UpdatePasswordData,
  UpdatePasswordResponse,
  UpdateRecordEntriesData,
  UpdateRecordEntriesResponse,
  UpdateSourceData,
  UpdateSourceResponse,
  UpdateStagingProfileData,
  UpdateStagingProfileResponse,
  UpdateTagData,
  UpdateTagResponse,
  UpdateThesaurusData,
  UpdateThesaurusResponse,
  UpdateUiConfigurationData,
  UpdateUiConfigurationResponse,
  UpdateUserData,
  UpdateUserResponse,
  UpdateUserSelectionData,
  UpdateUserSelectionResponse,
  UploadThesaurusData,
  UploadThesaurusFromUrlData,
  UploadThesaurusFromUrlResponse,
  UploadThesaurusResponse,
  ValidateRecordData,
  ValidateRecordForInspireData,
  ValidateRecordForInspireResponse,
  ValidateRecordResponse,
  ValidateRecordsData,
  ValidateRecordsInspireData,
  ValidateRecordsInspireResponse,
  ValidateRecordsResponse,
} from './types.gen';

/**
 * Describe resource
 * @param data The data for the request.
 * @param data.fileIdentifier fileIdentifier
 * @param data.spatialDatasetIdentifierCode spatial_dataset_identifier_code
 * @param data.spatialDatasetIdentifierNamespace spatial_dataset_identifier_namespace
 * @returns unknown Feeds.
 * @returns void Not authenticated.
 * @throws ApiError
 */
export const describeResource = (
  data: DescribeResourceData = {}
): CancelablePromise<DescribeResourceResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/atom/describe/resource',
    query: {
      fileIdentifier: data.fileIdentifier,
      spatial_dataset_identifier_code: data.spatialDatasetIdentifierCode,
      spatial_dataset_identifier_namespace:
        data.spatialDatasetIdentifierNamespace,
    },
  });
};

/**
 * Describe service
 * @param data The data for the request.
 * @param data.metadataUuid metadataUuid
 * @returns unknown Feeds.
 * @returns void Not authenticated.
 * @throws ApiError
 */
export const describe = (
  data: DescribeData
): CancelablePromise<DescribeResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/atom/describe/service/{metadataUuid}',
    path: {
      metadataUuid: data.metadataUuid,
    },
  });
};

/**
 * Get a data file related to dataset
 * This service if a dataset has only 1 download format for a CRS returns the file, otherwise returns a feed with downloads for the dataset.
 * @param data The data for the request.
 * @param data.spatialDatasetIdentifierCode spatial_dataset_identifier_code
 * @param data.spatialDatasetIdentifierNamespace spatial_dataset_identifier_namespace
 * @param data.crs crs
 * @returns unknown Get a data file related to dataset
 * @returns void Not authenticated.
 * @throws ApiError
 */
export const downloadResource = (
  data: DownloadResourceData
): CancelablePromise<DownloadResourceResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/atom/download/resource',
    query: {
      spatial_dataset_identifier_code: data.spatialDatasetIdentifierCode,
      spatial_dataset_identifier_namespace:
        data.spatialDatasetIdentifierNamespace,
      crs: data.crs,
    },
  });
};

/**
 * Get ATOM feeds
 * @param data The data for the request.
 * @param data.fileIdentifier fileIdentifier
 * @returns unknown Get a list of feeds.
 * @throws ApiError
 */
export const feeds = (
  data: FeedsData = {}
): CancelablePromise<FeedsResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/atom/feeds',
    query: {
      fileIdentifier: data.fileIdentifier,
    },
  });
};

/**
 * Scan records for ATOM feeds
 * Check in the settings which protocol identify ATOM feeds in your catalogue.Only applies to ISO19139 records.
 * @returns unknown Scan completed.
 * @throws ApiError
 */
export const scan = (): CancelablePromise<ScanResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/atom/scan',
  });
};

/**
 * Get CssStyleSettings
 * This returns a map with all Less variables.
 * @returns string OK
 * @throws ApiError
 */
export const getCssStyle = (): CancelablePromise<GetCssStyleResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/customstyle',
  });
};

/**
 * Saves custom style variables.
 * Saves custom style variables.
 * @param data The data for the request.
 * @param data.requestBody
 * @returns string Created
 * @throws ApiError
 */
export const saveCssStyle = (
  data: SaveCssStyleData
): CancelablePromise<SaveCssStyleResponse> => {
  return __request(OpenAPI, {
    method: 'POST',
    url: '/customstyle',
    body: data.requestBody,
    mediaType: 'application/json',
  });
};

/**
 * Get formatters
 * @param data The data for the request.
 * @param data.id
 * @param data.uuid
 * @param data.schema
 * @param data.pluginOnly
 * @param data.publishedOnly
 * @returns FormatterDataResponse OK
 * @throws ApiError
 */
export const listFormatters = (
  data: ListFormattersData = {}
): CancelablePromise<ListFormattersResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/formatters',
    query: {
      id: data.id,
      uuid: data.uuid,
      schema: data.schema,
      pluginOnly: data.pluginOnly,
      publishedOnly: data.publishedOnly,
    },
  });
};

/**
 * Import a XSLT formatter (usually a zip named 'schema-formatter.zip')
 * @param data The data for the request.
 * @param data.file
 * @returns unknown Created
 * @throws ApiError
 */
export const addFormatter = (
  data: AddFormatterData
): CancelablePromise<AddFormatterResponse> => {
  return __request(OpenAPI, {
    method: 'POST',
    url: '/formatters',
    query: {
      file: data.file,
    },
  });
};

/**
 * Clear formatter cache
 * Formatters are used to render records in various format (HTML, PDF, ...). When a record is rendered a cache is populated for better performance. By default the cache is an H2 database with files on the filesystems (See <dataDirectory>/resources/htmlcache/formatter-cache folder).
 * @returns void Cache cleared.
 * @throws ApiError
 */
export const clearFormatterCache =
  (): CancelablePromise<ClearFormatterCacheResponse> => {
    return __request(OpenAPI, {
      method: 'DELETE',
      url: '/formatters/cache',
      errors: {
        403: 'Operation not allowed. Only Administrator can access it.',
      },
    });
  };

/**
 * Delete a formatter
 * @param data The data for the request.
 * @param data.formatter
 * @param data.schema
 * @returns void No Content
 * @throws ApiError
 */
export const deleteFormatter = (
  data: DeleteFormatterData
): CancelablePromise<DeleteFormatterResponse> => {
  return __request(OpenAPI, {
    method: 'DELETE',
    url: '/formatters/{schema}/{formatter}',
    path: {
      formatter: data.formatter,
      schema: data.schema,
    },
  });
};

/**
 * Download a formatter as ZIP
 * @param data The data for the request.
 * @param data.formatter
 * @param data.schema
 * @returns unknown OK
 * @throws ApiError
 */
export const downloadFormatter = (
  data: DownloadFormatterData
): CancelablePromise<DownloadFormatterResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/formatters/{schema}/{formatter}',
    path: {
      formatter: data.formatter,
      schema: data.schema,
    },
  });
};

/**
 * Get formatter files
 * @param data The data for the request.
 * @param data.formatter
 * @param data.schema
 * @returns string OK
 * @throws ApiError
 */
export const getFormatterFiles = (
  data: GetFormatterFilesData
): CancelablePromise<GetFormatterFilesResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/formatters/{schema}/{formatter}/files',
    path: {
      formatter: data.formatter,
      schema: data.schema,
    },
  });
};

/**
 * Get formatter file content
 * @param data The data for the request.
 * @param data.formatter
 * @param data.schema
 * @param data.file
 * @returns string OK
 * @throws ApiError
 */
export const getFormatterFileContent = (
  data: GetFormatterFileContentData
): CancelablePromise<GetFormatterFileContentResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/formatters/{schema}/{formatter}/files/{file}',
    path: {
      formatter: data.formatter,
      schema: data.schema,
      file: data.file,
    },
  });
};

/**
 * Update formatter file
 * @param data The data for the request.
 * @param data.formatter
 * @param data.schema
 * @param data.file
 * @param data.data
 * @returns unknown Created
 * @throws ApiError
 */
export const updateFormatterFile = (
  data: UpdateFormatterFileData
): CancelablePromise<UpdateFormatterFileResponse> => {
  return __request(OpenAPI, {
    method: 'POST',
    url: '/formatters/{schema}/{formatter}/files/{file}',
    path: {
      formatter: data.formatter,
      schema: data.schema,
      file: data.file,
    },
    query: {
      data: data.data,
    },
  });
};

/**
 * Get groups
 * The catalog contains one or more groups. By default, there is 3 reserved groups (Internet, Intranet, Guest) and a sample group.<br/>This service returns all catalog groups when not authenticated or when current is user is an administrator. The list can contains or not reserved groups depending on the parameters.<br/>When authenticated, return user groups optionally filtered on a specific user profile.
 * @param data The data for the request.
 * @param data.withReservedGroup Including Internet, Intranet, Guest groups or not
 * @param data.profile For a specific profile
 * @returns Group OK
 * @throws ApiError
 */
export const getGroups = (
  data: GetGroupsData = {}
): CancelablePromise<GetGroupsResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/groups',
    query: {
      withReservedGroup: data.withReservedGroup,
      profile: data.profile,
    },
  });
};

/**
 * Add a group
 * Return the identifier of the group created.
 * @param data The data for the request.
 * @param data.requestBody
 * @returns number Group created.
 * @throws ApiError
 */
export const addGroup = (
  data: AddGroupData
): CancelablePromise<AddGroupResponse> => {
  return __request(OpenAPI, {
    method: 'PUT',
    url: '/groups',
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
      400: 'Group with that id or name already exist.',
      403: 'Operation not allowed. Only UserAdmins can access it.',
    },
  });
};

/**
 * Remove a group
 * Remove a group by first removing sharing settings, link to users and finally reindex all affected records.
 * @param data The data for the request.
 * @param data.groupIdentifier Group identifier.
 * @param data.force Force removal even if records are assigned to that group.
 * @returns void Group removed.
 * @throws ApiError
 */
export const deleteGroup = (
  data: DeleteGroupData
): CancelablePromise<DeleteGroupResponse> => {
  return __request(OpenAPI, {
    method: 'DELETE',
    url: '/groups/{groupIdentifier}',
    path: {
      groupIdentifier: data.groupIdentifier,
    },
    query: {
      force: data.force,
    },
    errors: {
      403: 'Operation not allowed. Only UserAdmins can access it.',
      404: 'Resource not found.',
    },
  });
};

/**
 * Get group
 * Return the requested group details.
 * @param data The data for the request.
 * @param data.groupIdentifier Group identifier
 * @returns Group Group information for the group id supplied.
 * @throws ApiError
 */
export const getGroup = (
  data: GetGroupData
): CancelablePromise<GetGroupResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/groups/{groupIdentifier}',
    path: {
      groupIdentifier: data.groupIdentifier,
    },
    errors: {
      404: 'Resource not found.',
    },
  });
};

/**
 * Update a group
 * @param data The data for the request.
 * @param data.groupIdentifier Group identifier
 * @param data.requestBody
 * @returns void Group updated.
 * @throws ApiError
 */
export const updateGroup = (
  data: UpdateGroupData
): CancelablePromise<UpdateGroupResponse> => {
  return __request(OpenAPI, {
    method: 'PUT',
    url: '/groups/{groupIdentifier}',
    path: {
      groupIdentifier: data.groupIdentifier,
    },
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
      403: 'Operation not allowed. Only UserAdmins can access it.',
      404: 'Resource not found.',
    },
  });
};

/**
 * Get group users
 * @param data The data for the request.
 * @param data.groupIdentifier Group identifier
 * @returns User List of users in that group.
 * @throws ApiError
 */
export const getGroupUsers = (
  data: GetGroupUsersData
): CancelablePromise<GetGroupUsersResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/groups/{groupIdentifier}/users',
    path: {
      groupIdentifier: data.groupIdentifier,
    },
    errors: {
      403: 'Operation not allowed. Only UserAdmins can access it.',
      404: 'Resource not found.',
    },
  });
};

/**
 * Get the group logo image.
 * If last-modified header is present it is used to check if the logo has been modified since the header date. If it hasn't been modified returns an empty 304 Not Modified response. If modified returns the image. If the group has no logo then returns a transparent 1x1 px PNG image.
 * @param data The data for the request.
 * @param data.groupId Group identifier
 * @returns unknown OK
 * @throws ApiError
 */
export const getGroupLogo = (
  data: GetGroupLogoData
): CancelablePromise<GetGroupLogoResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/groups/{groupId}/logo',
    path: {
      groupId: data.groupId,
    },
  });
};

/**
 * Check if a harvester name or host already exist
 * @param data The data for the request.
 * @param data.property The harvester property to check
 * @param data.exist The value to search
 * @returns string Property does not exist.
 * @throws ApiError
 */
export const checkHarvesterPropertyExist = (
  data: CheckHarvesterPropertyExistData
): CancelablePromise<CheckHarvesterPropertyExistResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/harvesters/properties/{property}',
    path: {
      property: data.property,
    },
    query: {
      exist: data.exist,
    },
    errors: {
      403: 'Operation not allowed. Only UserAdmins can access it.',
      404: 'A property with that value already exist.',
    },
  });
};

/**
 * Assign harvester records to a new source
 * @param data The data for the request.
 * @param data.harvesterUuid The harvester UUID
 * @param data.source The target source UUID
 * @returns string Harvester records transfered to new source.
 * @throws ApiError
 */
export const assignHarvestedRecordToSource = (
  data: AssignHarvestedRecordToSourceData
): CancelablePromise<AssignHarvestedRecordToSourceResponse> => {
  return __request(OpenAPI, {
    method: 'POST',
    url: '/harvesters/{harvesterUuid}/assign',
    path: {
      harvesterUuid: data.harvesterUuid,
    },
    query: {
      source: data.source,
    },
    errors: {
      403: 'Operation not allowed. Only UserAdmins can access it.',
      404: 'Resource not found.',
    },
  });
};

/**
 * Clean translation packages cache.
 * @returns unknown OK
 * @throws ApiError
 */
export const cleanTranslationsPackagesCache =
  (): CancelablePromise<CleanTranslationsPackagesCacheResponse> => {
    return __request(OpenAPI, {
      method: 'DELETE',
      url: '/i18n/cache',
    });
  };

/**
 * List translations for database description table
 * @param data The data for the request.
 * @param data.type
 * @returns string OK
 * @throws ApiError
 */
export const getTranslations = (
  data: GetTranslationsData = {}
): CancelablePromise<GetTranslationsResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/i18n/db',
    query: {
      type: data.type,
    },
  });
};

/**
 * List custom user translations
 * @param data The data for the request.
 * @param data.type
 * @returns Translations OK
 * @throws ApiError
 */
export const getCustomTranslations = (
  data: GetCustomTranslationsData = {}
): CancelablePromise<GetCustomTranslationsResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/i18n/db/custom',
    query: {
      type: data.type,
    },
  });
};

/**
 * Remove all database translations.
 * @returns unknown Created
 * @throws ApiError
 */
export const removeAllTranslations =
  (): CancelablePromise<RemoveAllTranslationsResponse> => {
    return __request(OpenAPI, {
      method: 'DELETE',
      url: '/i18n/db/translations',
    });
  };

/**
 * List database translations (used to overrides client application translations).
 * @returns string OK
 * @throws ApiError
 */
export const getDbTranslations =
  (): CancelablePromise<GetDbTranslationsResponse> => {
    return __request(OpenAPI, {
      method: 'GET',
      url: '/i18n/db/translations',
    });
  };

/**
 * Add or update all database translations.
 * @param data The data for the request.
 * @param data.requestBody
 * @param data.replace
 * @returns string Created
 * @throws ApiError
 */
export const addTranslations = (
  data: AddTranslationsData
): CancelablePromise<AddTranslationsResponse> => {
  return __request(OpenAPI, {
    method: 'PUT',
    url: '/i18n/db/translations',
    query: {
      replace: data.replace,
    },
    body: data.requestBody,
    mediaType: 'application/json',
  });
};

/**
 * Delete database translations.
 * Delete custom translations stored in the database.
 * @param data The data for the request.
 * @param data.key Untranslated key for which all translations will be deleted.
 * @returns unknown OK
 * @throws ApiError
 */
export const deleteTranslations = (
  data: DeleteTranslationsData
): CancelablePromise<DeleteTranslationsResponse> => {
  return __request(OpenAPI, {
    method: 'DELETE',
    url: '/i18n/db/translations/{key}',
    path: {
      key: data.key,
    },
  });
};

/**
 * Add or update database translations for a key.
 * Database translations can be used to customize labels in the UI for different languages.
 * @param data The data for the request.
 * @param data.key Untranslated key for which translations are provided.
 * @param data.requestBody An object where keys are valid 3-letter language codes (e.g. `eng` or `fre`) and values are custom translations for the corresponding language.
 * @param data.replace Set to `true` to erase all existing translations for that key
 * @returns string Created
 * @throws ApiError
 */
export const addTranslationsFor = (
  data: AddTranslationsForData
): CancelablePromise<AddTranslationsForResponse> => {
  return __request(OpenAPI, {
    method: 'PUT',
    url: '/i18n/db/translations/{key}',
    path: {
      key: data.key,
    },
    query: {
      replace: data.replace,
    },
    body: data.requestBody,
    mediaType: 'application/json',
  });
};

/**
 * Get list of translation packages.
 * @returns string OK
 * @throws ApiError
 */
export const getTranslationsPackages =
  (): CancelablePromise<GetTranslationsPackagesResponse> => {
    return __request(OpenAPI, {
      method: 'GET',
      url: '/i18n/packages',
    });
  };

/**
 * Get a translation package.
 * @param data The data for the request.
 * @param data.pack
 * @returns string OK
 * @throws ApiError
 */
export const getTranslationsPackage = (
  data: GetTranslationsPackageData
): CancelablePromise<GetTranslationsPackageResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/i18n/packages/{pack}',
    path: {
      pack: data.pack,
    },
  });
};

/**
 * Get identifier templates
 * Identifier templates are used to create record UUIDs havind a particular structure. The template will be used when user creates a new record. The template identifier to use is defined in the administration > settings.
 * @param data The data for the request.
 * @param data.userDefinedOnly Only user defined ones
 * @returns MetadataIdentifierTemplate List of identifier templates.
 * @throws ApiError
 */
export const getIdentifiers = (
  data: GetIdentifiersData = {}
): CancelablePromise<GetIdentifiersResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/identifiers',
    query: {
      userDefinedOnly: data.userDefinedOnly,
    },
    errors: {
      403: 'Operation not allowed. Only Editor can access it.',
    },
  });
};

/**
 * Add an identifier template
 * @param data The data for the request.
 * @param data.requestBody
 * @returns number Identifier template created.
 * @throws ApiError
 */
export const addIdentifier = (
  data: AddIdentifierData
): CancelablePromise<AddIdentifierResponse> => {
  return __request(OpenAPI, {
    method: 'PUT',
    url: '/identifiers',
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
      403: 'Operation not allowed. Only Editor can access it.',
    },
  });
};

/**
 * Remove an identifier template
 * @param data The data for the request.
 * @param data.identifier Identifier template identifier
 * @returns void Template identifier removed.
 * @throws ApiError
 */
export const deleteIdentifier = (
  data: DeleteIdentifierData
): CancelablePromise<DeleteIdentifierResponse> => {
  return __request(OpenAPI, {
    method: 'DELETE',
    url: '/identifiers/{identifier}',
    path: {
      identifier: data.identifier,
    },
    errors: {
      403: 'Operation not allowed. Only Editor can access it.',
      404: 'Resource not found.',
    },
  });
};

/**
 * Update an identifier template
 * @param data The data for the request.
 * @param data.identifier Identifier template identifier
 * @param data.requestBody
 * @returns void Identifier template updated.
 * @throws ApiError
 */
export const updateIdentifier = (
  data: UpdateIdentifierData
): CancelablePromise<UpdateIdentifierResponse> => {
  return __request(OpenAPI, {
    method: 'PUT',
    url: '/identifiers/{identifier}',
    path: {
      identifier: data.identifier,
    },
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
      403: 'Operation not allowed. Only Editor can access it.',
      404: 'Resource not found.',
    },
  });
};

/**
 * Get ISO languages
 * ISO languages provides a list of all languages (eg. used for autocompletion in metadata editor).
 * @returns IsoLanguage OK
 * @throws ApiError
 */
export const getIsoLanguages =
  (): CancelablePromise<GetIsoLanguagesResponse> => {
    return __request(OpenAPI, {
      method: 'GET',
      url: '/isolanguages',
    });
  };

/**
 * Get languages
 * Languages for the application having translations in the database. All tables with 'Desc' suffix contains translation for some domain objects like groups, tags, ...
 * @returns Language OK
 * @throws ApiError
 */
export const getLanguages = (): CancelablePromise<GetLanguagesResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/languages',
  });
};

/**
 * Get languages available in the application
 * Languages available in this version of the application. Those that you can add using PUT operation and which have SQL script to initialize the language.
 * @returns Language OK
 * @throws ApiError
 */
export const getApplicationLanguages =
  (): CancelablePromise<GetApplicationLanguagesResponse> => {
    return __request(OpenAPI, {
      method: 'GET',
      url: '/languages/application',
    });
  };

/**
 * Remove a language
 * Delete all translations from all *Desc tables in the database. Warning: This will also remove all translations you may have done to those objects (eg. custom groups).
 * @param data The data for the request.
 * @param data.langCode ISO 3 letter code
 * @returns void Language translations removed.
 * @throws ApiError
 */
export const deleteLanguage = (
  data: DeleteLanguageData
): CancelablePromise<DeleteLanguageResponse> => {
  return __request(OpenAPI, {
    method: 'DELETE',
    url: '/languages/{langCode}',
    path: {
      langCode: data.langCode,
    },
    errors: {
      403: 'Operation not allowed. Only Administrator can access it.',
      404: 'Resource not found.',
    },
  });
};

/**
 * Add a language
 * Add all default translations from all *Desc tables in the database. This operation will only add translations for a default catalog installation. Defaults can be customized in SQL scripts located in WEB-INF/classes/setup/sql/data*.
 * @param data The data for the request.
 * @param data.langCode ISO 3 letter code
 * @returns unknown Language translations added.
 * @throws ApiError
 */
export const addLanguages = (
  data: AddLanguagesData
): CancelablePromise<AddLanguagesResponse> => {
  return __request(OpenAPI, {
    method: 'PUT',
    url: '/languages/{langCode}',
    path: {
      langCode: data.langCode,
    },
    errors: {
      403: 'Operation not allowed. Only Administrator can access it.',
      404: 'Resource not found. eg. No SQL file available for that langugae.',
    },
  });
};

/**
 * Get all logos
 * Logos are used for the catalog, the groups logos, and harvester icons. Logos are stored in the data directory in <dataDirectory>/resources/images/harvesting.<br/> Records are attached to a source. A source can be the local catalog or a harvester node. When a source is created, its logo is located in the images/logos folder with the source UUID as filename. For some sources the logo can be automatically retrieved (eg. when harvesting GeoNetwork catalogs). For others, the logo is usually manually defined when configuring the harvester.
 * @returns string OK
 * @throws ApiError
 */
export const getLogos = (): CancelablePromise<GetLogosResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/logos',
  });
};

/**
 * Add a logo
 * @param data The data for the request.
 * @param data.file The logo image to upload
 * @param data.overwrite Overwrite if exists
 * @returns string Logo added.
 * @throws ApiError
 */
export const addLogo = (
  data: AddLogoData
): CancelablePromise<AddLogoResponse> => {
  return __request(OpenAPI, {
    method: 'POST',
    url: '/logos',
    query: {
      file: data.file,
      overwrite: data.overwrite,
    },
    errors: {
      403: 'Operation not allowed. Only UserAdmins can access it.',
    },
  });
};

/**
 * Remove a logo
 * @param data The data for the request.
 * @param data.file The logo filename to delete
 * @returns void Logo removed.
 * @throws ApiError
 */
export const deleteLogo = (
  data: DeleteLogoData
): CancelablePromise<DeleteLogoResponse> => {
  return __request(OpenAPI, {
    method: 'DELETE',
    url: '/logos/{file}',
    path: {
      file: data.file,
    },
    errors: {
      403: 'Operation not allowed. Only UserAdmins can access it.',
      404: 'Resource not found.',
    },
  });
};

/**
 * Get a logo
 * @param data The data for the request.
 * @param data.file The logo filename
 * @returns unknown Logo returned.
 * @throws ApiError
 */
export const getLogo = (
  data: GetLogoData
): CancelablePromise<GetLogoResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/logos/{file}',
    path: {
      file: data.file,
    },
    errors: {
      403: 'Operation not allowed. Only UserAdmins can access it.',
      404: 'Resource not found.',
    },
  });
};

/**
 * Get mapservers
 * Mapservers are used by the catalog to publish record attachments (eg. ZIP file with shape) or record associated resources (eg. database table, file on the local network) in a remote mapserver like GeoServer or MapServer. The catalog communicate with the mapserver using GeoServer REST API.
 * @returns AnonymousMapserver List of all mapservers.
 * @throws ApiError
 */
export const getMapservers = (): CancelablePromise<GetMapserversResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/mapservers',
    errors: {
      403: 'Operation not allowed. Only Editors can access it.',
    },
  });
};

/**
 * Add a mapserver
 * Return the id of the newly created mapserver.
 * @param data The data for the request.
 * @param data.requestBody
 * @returns number Mapserver created.
 * @throws ApiError
 */
export const addMapserver = (
  data: AddMapserverData
): CancelablePromise<AddMapserverResponse> => {
  return __request(OpenAPI, {
    method: 'PUT',
    url: '/mapservers',
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
      400: 'Bad parameters.',
      403: 'Operation not allowed. Only Reviewvers can access it.',
    },
  });
};

/**
 * Remove a mapserver
 * @param data The data for the request.
 * @param data.mapserverId Mapserver identifier
 * @returns void Mapserver removed.
 * @throws ApiError
 */
export const deleteMapserver = (
  data: DeleteMapserverData
): CancelablePromise<DeleteMapserverResponse> => {
  return __request(OpenAPI, {
    method: 'DELETE',
    url: '/mapservers/{mapserverId}',
    path: {
      mapserverId: data.mapserverId,
    },
    errors: {
      403: 'Operation not allowed. Only Reviewvers can access it.',
      404: 'Resource not found.',
    },
  });
};

/**
 * Get a mapserver
 * @param data The data for the request.
 * @param data.mapserverId Mapserver identifier
 * @throws ApiError
 */
export const getMapserver = (
  data: GetMapserverData
): CancelablePromise<void> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/mapservers/{mapserverId}',
    path: {
      mapserverId: data.mapserverId,
    },
    errors: {
      403: 'Operation not allowed. Only Editors can access it.',
      404: 'Resource not found.',
    },
  });
};

/**
 * Update a mapserver
 * @param data The data for the request.
 * @param data.mapserverId Mapserver identifier
 * @param data.requestBody
 * @returns void Mapserver updated.
 * @throws ApiError
 */
export const updateMapserver = (
  data: UpdateMapserverData
): CancelablePromise<UpdateMapserverResponse> => {
  return __request(OpenAPI, {
    method: 'PUT',
    url: '/mapservers/{mapserverId}',
    path: {
      mapserverId: data.mapserverId,
    },
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
      403: 'Operation not allowed. Only Reviewvers can access it.',
      404: 'Resource not found.',
    },
  });
};

/**
 * Update a mapserver authentication
 * The remote mapserver REST API may require basic authentication. This operation set the username and password.
 * @param data The data for the request.
 * @param data.mapserverId Mapserver identifier
 * @param data.username User name
 * @param data.password Password
 * @returns void Mapserver updated.
 * @throws ApiError
 */
export const updateMapserverAuth = (
  data: UpdateMapserverAuthData
): CancelablePromise<UpdateMapserverAuthResponse> => {
  return __request(OpenAPI, {
    method: 'POST',
    url: '/mapservers/{mapserverId}/auth',
    path: {
      mapserverId: data.mapserverId,
    },
    query: {
      username: data.username,
      password: data.password,
    },
    errors: {
      403: 'Operation not allowed. Only Reviewvers can access it.',
      404: 'Resource not found.',
    },
  });
};

/**
 * Remove a metadata mapserver resource
 * @param data The data for the request.
 * @param data.mapserverId Mapserver identifier
 * @param data.metadataUuid Record UUID.
 * @param data.resource Resource name (could be a file or a db connection)
 * @param data.metadataTitle Metadata title
 * @param data.metadataAbstract Metadata abstract
 * @throws ApiError
 */
export const deleteMapserverResource = (
  data: DeleteMapserverResourceData
): CancelablePromise<void> => {
  return __request(OpenAPI, {
    method: 'DELETE',
    url: '/mapservers/{mapserverId}/records/{metadataUuid}',
    path: {
      mapserverId: data.mapserverId,
      metadataUuid: data.metadataUuid,
    },
    query: {
      resource: data.resource,
      metadataTitle: data.metadataTitle,
      metadataAbstract: data.metadataAbstract,
    },
    errors: {
      403: 'Operation not allowed. Only Editors can access it.',
    },
  });
};

/**
 * Check metadata mapserver resource is published
 * @param data The data for the request.
 * @param data.mapserverId Mapserver identifier
 * @param data.metadataUuid Record UUID.
 * @param data.resource Resource name (could be a file or a db connection)
 * @param data.metadataTitle Metadata title
 * @param data.metadataAbstract Metadata abstract
 * @throws ApiError
 */
export const getMapserverResource = (
  data: GetMapserverResourceData
): CancelablePromise<void> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/mapservers/{mapserverId}/records/{metadataUuid}',
    path: {
      mapserverId: data.mapserverId,
      metadataUuid: data.metadataUuid,
    },
    query: {
      resource: data.resource,
      metadataTitle: data.metadataTitle,
      metadataAbstract: data.metadataAbstract,
    },
    errors: {
      403: 'Operation not allowed. Only Editors can access it.',
    },
  });
};

/**
 * Publish a metadata resource in a mapserver
 * @param data The data for the request.
 * @param data.mapserverId Mapserver identifier
 * @param data.metadataUuid Record UUID.
 * @param data.resource Resource name (could be a file or a db connection)
 * @param data.metadataTitle Metadata title
 * @param data.metadataAbstract Metadata abstract
 * @throws ApiError
 */
export const publishMapserverResource = (
  data: PublishMapserverResourceData
): CancelablePromise<void> => {
  return __request(OpenAPI, {
    method: 'PUT',
    url: '/mapservers/{mapserverId}/records/{metadataUuid}',
    path: {
      mapserverId: data.mapserverId,
      metadataUuid: data.metadataUuid,
    },
    query: {
      resource: data.resource,
      metadataTitle: data.metadataTitle,
      metadataAbstract: data.metadataAbstract,
    },
    errors: {
      403: 'Operation not allowed. Only Editors can access it.',
    },
  });
};

/**
 * Get mapservices
 * Return the list of mapservices. mapservices are used to identify secured map services.
 * @returns MapService OK
 * @throws ApiError
 */
export const getMapservices = (): CancelablePromise<GetMapservicesResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/mapservices',
  });
};

/**
 * Get information about me
 * If not authenticated, return status 204 (NO_CONTENT), else return basic user information. This operation is usually used to know if current user is authenticated or not.It returns also info about groups and profiles.
 * @returns MeResponse Authenticated. Return user details.
 * @throws ApiError
 */
export const getMe = (): CancelablePromise<GetMeResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/me',
  });
};

/**
 * Get operations
 * Return the list of operations. Operations are used to define authorization per group. Extending the list of default operations (ie. view, dynamic, download, editing, notify, featured) might be feasible but is experimental.<br/> Featured is not really used anymore (was used in past version for home page highlights).
 * @returns Operation OK
 * @throws ApiError
 */
export const getOperations = (): CancelablePromise<GetOperationsResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/operations',
  });
};

/**
 * List all pages according to the filters
 * <a href='https://geonetwork-opensource.org/manuals/4.0.x/en/customizing-application/adding-static-pages.html'>More info</a>
 * @param data The data for the request.
 * @param data.language
 * @param data.section
 * @param data.format
 * @throws ApiError
 */
export const listPages = (
  data: ListPagesData = {}
): CancelablePromise<void> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/pages',
    query: {
      language: data.language,
      section: data.section,
      format: data.format,
    },
    errors: {
      403: 'Operation not allowed. User needs to be able to view the resource.',
    },
  });
};

/**
 * Add a page by uploading a file
 * <p>Is not possible to load a link and a file at the same time.</p> <a href='https://geonetwork-opensource.org/manuals/4.0.x/en/customizing-application/adding-static-pages.html'>More info</a>
 * @param data The data for the request.
 * @param data.language
 * @param data.pageId
 * @param data.sections
 * @param data.status
 * @param data.format
 * @param data.formData
 * @returns string Page saved
 * @throws ApiError
 */
export const addPageUploadingFile = (
  data: AddPageUploadingFileData
): CancelablePromise<AddPageUploadingFileResponse> => {
  return __request(OpenAPI, {
    method: 'POST',
    url: '/pages',
    query: {
      language: data.language,
      pageId: data.pageId,
      sections: data.sections,
      status: data.status,
      format: data.format,
    },
    formData: data.formData,
    mediaType: 'multipart/form-data',
    errors: {
      400: 'Wrong parameters are provided',
      403: 'Operation not allowed. User needs to be able to edit the resource.',
      409: 'Page already in the system: use PUT',
      500: 'File not valid',
    },
  });
};

/**
 * Add a page
 * <p>Is not possible to load a link and a file at the same time.</p> <a href='https://geonetwork-opensource.org/manuals/4.0.x/en/customizing-application/adding-static-pages.html'>More info</a>
 * @param data The data for the request.
 * @param data.requestBody
 * @returns string Page saved
 * @throws ApiError
 */
export const addPageWithoutUploadingFile = (
  data: AddPageWithoutUploadingFileData
): CancelablePromise<AddPageWithoutUploadingFileResponse> => {
  return __request(OpenAPI, {
    method: 'PUT',
    url: '/pages',
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
      400: 'Wrong parameters are provided',
      403: 'Operation not allowed. User needs to be able to edit the resource.',
      409: 'Page already in the system: use PUT',
      500: 'File not valid',
    },
  });
};

/**
 * @returns string Page found
 * @throws ApiError
 */
export const getPageFormats = (): CancelablePromise<GetPageFormatsResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/pages/config/formats',
  });
};

/**
 * @returns string Page found
 * @throws ApiError
 */
export const getPageSections =
  (): CancelablePromise<GetPageSectionsResponse> => {
    return __request(OpenAPI, {
      method: 'GET',
      url: '/pages/config/sections',
    });
  };

/**
 * @returns string Page found
 * @throws ApiError
 */
export const getPageStatus = (): CancelablePromise<GetPageStatusResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/pages/config/status',
  });
};

/**
 * Delete a page
 * <a href='https://geonetwork-opensource.org/manuals/4.0.x/en/customizing-application/adding-static-pages.html'>More info</a>
 * @param data The data for the request.
 * @param data.language
 * @param data.pageId
 * @returns unknown Page removed
 * @throws ApiError
 */
export const deletePage = (
  data: DeletePageData
): CancelablePromise<DeletePageResponse> => {
  return __request(OpenAPI, {
    method: 'DELETE',
    url: '/pages/{language}/{pageId}',
    path: {
      language: data.language,
      pageId: data.pageId,
    },
    errors: {
      403: 'Operation not allowed. User needs to be able to edit the resource.',
      404: 'Page not found',
    },
  });
};

/**
 * Return the page object details except the content
 * <a href='https://geonetwork-opensource.org/manuals/4.0.x/en/customizing-application/adding-static-pages.html'>More info</a>
 * @param data The data for the request.
 * @param data.language
 * @param data.pageId
 * @returns PageProperties Page found
 * @throws ApiError
 */
export const getPage = (
  data: GetPageData
): CancelablePromise<GetPageResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/pages/{language}/{pageId}',
    path: {
      language: data.language,
      pageId: data.pageId,
    },
    errors: {
      403: 'Operation not allowed. User needs to be able to view the resource.',
      404: 'Page not found',
    },
  });
};

/**
 * Update a page
 * <a href='https://geonetwork-opensource.org/manuals/4.0.x/en/customizing-application/adding-static-pages.html'>More info</a>
 * @param data The data for the request.
 * @param data.language
 * @param data.pageId
 * @param data.requestBody
 * @returns unknown Page changes saved
 * @throws ApiError
 */
export const updatePage = (
  data: UpdatePageData
): CancelablePromise<UpdatePageResponse> => {
  return __request(OpenAPI, {
    method: 'PUT',
    url: '/pages/{language}/{pageId}',
    path: {
      language: data.language,
      pageId: data.pageId,
    },
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
      403: 'Operation not allowed. User needs to be able to edit the resource.',
    },
  });
};

/**
 * Return the static html content identified by pageId
 * <a href='https://geonetwork-opensource.org/manuals/4.0.x/en/customizing-application/adding-static-pages.html'>More info</a>
 * @param data The data for the request.
 * @param data.language
 * @param data.pageId
 * @returns string Page found
 * @throws ApiError
 */
export const getPageContent = (
  data: GetPageContentData
): CancelablePromise<GetPageContentResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/pages/{language}/{pageId}/content',
    path: {
      language: data.language,
      pageId: data.pageId,
    },
    errors: {
      403: 'Operation not allowed. User needs to be able to view the resource.',
      404: 'Page not found',
    },
  });
};

/**
 * Preview of search and replace text.
 *  When errors occur during processing, the processing report is returned in JSON format.
 * @param data The data for the request.
 * @param data.search Value to search for
 * @param data.useRegexp Use regular expression (may not be supported by all databases - tested with H2 and PostgreSQL)
 * @param data.replace Replacement
 * @param data.regexpFlags regexpFlags
 * @param data.diffType Return differences with diff, diffhtml or patch
 * @param data.uuids Record UUIDs. If null current selection is used.
 * @param data.bucket Selection bucket name
 * @returns unknown Processed records.
 * @throws ApiError
 */
export const previewProcessSearchAndReplace = (
  data: PreviewProcessSearchAndReplaceData
): CancelablePromise<PreviewProcessSearchAndReplaceResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/processes/db/search-and-replace',
    query: {
      useRegexp: data.useRegexp,
      search: data.search,
      replace: data.replace,
      regexpFlags: data.regexpFlags,
      diffType: data.diffType,
      uuids: data.uuids,
      bucket: data.bucket,
    },
    errors: {
      403: 'Operation not allowed. Only Editors can access it.',
      500: 'If one record processed is invalid.',
    },
  });
};

/**
 * Apply a database search and replace to one or more records
 * Process a metadata with an XSL transformation declared in the metadata schema (See the process folder). Parameters sent to the service are forwarded to XSL process.
 * @param data The data for the request.
 * @param data.search Value to search for
 * @param data.useRegexp Use regular expression (may not be supported by all databases - tested with H2 and PostgreSQL)
 * @param data.replace Replacement
 * @param data.regexpFlags regexpFlags
 * @param data.uuids Record UUIDs. If null current selection is used.
 * @param data.bucket Selection bucket name
 * @param data.updateDateStamp If true updates the DateStamp (or equivalent in standards different to ISO 19139) field in the metadata with the current timestamp
 * @param data.index Index after processing
 * @returns XsltMetadataProcessingReport Report about processed records.
 * @throws ApiError
 */
export const processSearchAndReplace = (
  data: ProcessSearchAndReplaceData
): CancelablePromise<ProcessSearchAndReplaceResponse> => {
  return __request(OpenAPI, {
    method: 'POST',
    url: '/processes/db/search-and-replace',
    query: {
      useRegexp: data.useRegexp,
      search: data.search,
      replace: data.replace,
      regexpFlags: data.regexpFlags,
      uuids: data.uuids,
      bucket: data.bucket,
      updateDateStamp: data.updateDateStamp,
      index: data.index,
    },
    errors: {
      403: 'Operation not allowed. Only Editors can access it.',
    },
  });
};

/**
 * Clear process reports list
 * @returns void Report registry cleared.
 * @throws ApiError
 */
export const deleteReports = (): CancelablePromise<DeleteResponse> => {
  return __request(OpenAPI, {
    method: 'DELETE',
    url: '/processes/reports',
    errors: {
      403: 'Operation not allowed. Only authenticated user can access it.',
    },
  });
};

/**
 * Get current process reports
 * When processing, the report is stored in memory and allows to retrieve progress repport during processing. Usually, process reports are returned by the synchronous processing operation.
 * @returns ProcessingReport List of reports returned.
 * @throws ApiError
 */
export const getProcessReport =
  (): CancelablePromise<GetProcessReportResponse> => {
    return __request(OpenAPI, {
      method: 'GET',
      url: '/processes/reports',
      errors: {
        403: 'Operation not allowed. Only authenticated user can access it.',
      },
    });
  };

/**
 * @deprecated
 * Search and replace values in one or more ISO19139 records
 * Service to apply replacements to one or more records.
 * To define a replacement, send the following parameters:
 * * mdsection-139815551372=metadata
 * * mdfield-1398155513728=id.contact.individualName
 * * replaceValue-1398155513728=Juan
 * * searchValue-1398155513728=Jose
 *
 * <br/>Batch editing can also be used for similar works.
 * @param data The data for the request.
 * @param data.process
 * @param data.uuids Record UUIDs. If null current selection is used.
 * @param data.bucket Selection bucket name
 * @param data.isTesting Test only (ie. metadata are not saved). Return the report only.
 * @param data.isCaseInsensitive Case insensitive search.
 * @param data.vacuumMode 'record' to apply vacuum.xsl, 'element' to remove empty elements. Empty to not affect empty elements.
 * @returns MetadataReplacementProcessingReport Replacements applied.
 * @throws ApiError
 */
export const searchAndReplace = (
  data: SearchAndReplaceData = {}
): CancelablePromise<SearchAndReplaceResponse> => {
  return __request(OpenAPI, {
    method: 'POST',
    url: '/processes/search-and-replace',
    query: {
      process: data.process,
      uuids: data.uuids,
      bucket: data.bucket,
      isTesting: data.isTesting,
      isCaseInsensitive: data.isCaseInsensitive,
      vacuumMode: data.vacuumMode,
    },
    errors: {
      403: 'Operation not allowed. Only Editors can access it.',
    },
  });
};

/**
 * Preview process result applied to one or more records
 * Preview result of a process applied to metadata records with an XSL transformation declared in the metadata schema (See the process folder). Parameters sent to the service are forwarded to XSL process. Append mode has 2 limitations. First, it only support a set of records in the same schema. Secondly, it does not propagate URL parameters. This mode is mainly used to create custom reports based on metadata records content.If process name ends with '.csv', the XSL process output a text document which is returned. When errors occur during processing, the processing report is returned in JSON format.
 * @param data The data for the request.
 * @param data.process Process identifier
 * @param data.diffType Return differences with diff, diffhtml or patch
 * @param data.uuids Record UUIDs. If null current selection is used.
 * @param data.bucket Selection bucket name
 * @param data.appendFirst Append documents before processing
 * @param data.applyUpdateFixedInfo Apply update fixed info
 * @returns unknown Processed records.
 * @throws ApiError
 */
export const previewProcessRecords = (
  data: PreviewProcessRecordsData
): CancelablePromise<PreviewProcessRecordsResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/processes/{process}',
    path: {
      process: data.process,
    },
    query: {
      diffType: data.diffType,
      uuids: data.uuids,
      bucket: data.bucket,
      appendFirst: data.appendFirst,
      applyUpdateFixedInfo: data.applyUpdateFixedInfo,
    },
    errors: {
      403: 'Operation not allowed. Only Editors can access it.',
    },
  });
};

/**
 * Apply a process to one or more records
 * Process a metadata with an XSL transformation declared in the metadata schema (See the process folder). Parameters sent to the service are forwarded to XSL process.
 * @param data The data for the request.
 * @param data.process Process identifier
 * @param data.uuids Record UUIDs. If null current selection is used.
 * @param data.bucket Selection bucket name
 * @param data.updateDateStamp If true updates the DateStamp (or equivalent in standards different to ISO 19139) field in the metadata with the current timestamp
 * @param data.index Index after processing
 * @returns XsltMetadataProcessingReport Report about processed records.
 * @throws ApiError
 */
export const processRecords = (
  data: ProcessRecordsData
): CancelablePromise<ProcessRecordsResponse> => {
  return __request(OpenAPI, {
    method: 'POST',
    url: '/processes/{process}',
    path: {
      process: data.process,
    },
    query: {
      uuids: data.uuids,
      bucket: data.bucket,
      updateDateStamp: data.updateDateStamp,
      index: data.index,
    },
    errors: {
      403: 'Operation not allowed. Only Editors can access it.',
    },
  });
};

/**
 * Delete one or more records
 * User MUST be able to edit the record to delete it.
 * @param data The data for the request.
 * @param data.uuids Record UUIDs. If null current selection is used.
 * @param data.bucket Selection bucket name
 * @param data.withBackup Backup first the record as MEF in the metadata removed folder.
 * @returns SimpleMetadataProcessingReport Report about deleted records.
 * @throws ApiError
 */
export const deleteRecords = (
  data: DeleteRecordsData = {}
): CancelablePromise<DeleteRecordsResponse> => {
  return __request(OpenAPI, {
    method: 'DELETE',
    url: '/records',
    query: {
      uuids: data.uuids,
      bucket: data.bucket,
      withBackup: data.withBackup,
    },
    errors: {
      403: 'Operation not allowed. Only Editors can access it.',
    },
  });
};

/**
 * Get catalog content as RDF. This endpoint supports the same Lucene query parameters as for the GUI search.
 * .
 * @param data The data for the request.
 * @param data.from Indicates the start position in a sorted list of matches that the client wants to use as the beginning of a page result.
 * @param data.hitsPerPage Indicates the number of hits per page.
 * @param data.any Search key
 * @param data.title A search key for the title.
 * @param data.facetQ A search facet in the Lucene index. Use the GeoNetwork GUI search to generate the suitable filter values. Example: standard/dcat-ap&createDateYear/2018&sourceCatalog/6d93613e-2b76-4e26-94af-4b4c420a1758 (filter by creation year and source catalog).
 * @param data.sortBy Lucene sortBy criteria. Relevant values: relevance, title, changeDate.
 * @param data.sortOrder Sort order. Possible values: reverse.
 * @param data.similarity Use the Lucene FuzzyQuery. Values range from 0.0 to 1.0 and defaults to 0.8.
 * @returns unknown Return the catalog content as RDF.
 * @throws ApiError
 */
export const getAsRdf = (
  data: GetAsRdfData = {}
): CancelablePromise<GetAsRdfResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/records',
    query: {
      from: data.from,
      hitsPerPage: data.hitsPerPage,
      any: data.any,
      title: data.title,
      'facet.q': data.facetQ,
      sortBy: data.sortBy,
      sortOrder: data.sortOrder,
      similarity: data.similarity,
    },
    errors: {
      303: 'Redirect the client to the first in-sequence page resource. This happens when the paging parameters (from, hitsPerPage) are not included in the request.',
    },
  });
};

/**
 * Add a record from XML or MEF/ZIP file
 * Add record in the catalog by uploading files.
 * @param data The data for the request.
 * @param data.metadataType The type of record.
 * @param data.file XML or MEF file to upload
 * @param data.uuidProcessing Record identifier processing.
 * @param data.group The group the record is attached to.
 * @param data.category Tags to assign to the record.
 * @param data.rejectIfInvalid Validate the record first and reject it if not valid.
 * @param data.publishToAll (XML file only) Publish record.
 * @param data.assignToCatalog (MEF file only) Assign to current catalog.
 * @param data.transformWith XSL transformation to apply to the record.
 * @param data.schema Force the schema of the record. If not set, schema autodetection is used (and is the preferred method).
 * @param data.extra (experimental) Add extra information to the record.
 * @param data.allowEditGroupMembers Is editable by group members with editor profile? If not, only the author and administrator can edit the record.
 * @returns SimpleMetadataProcessingReport Report about imported records.
 * @throws ApiError
 */
export const insertFile = (
  data: InsertFileData = {}
): CancelablePromise<InsertFileResponse> => {
  return __request(OpenAPI, {
    method: 'POST',
    url: '/records',
    query: {
      metadataType: data.metadataType,
      file: data.file,
      uuidProcessing: data.uuidProcessing,
      group: data.group,
      category: data.category,
      rejectIfInvalid: data.rejectIfInvalid,
      publishToAll: data.publishToAll,
      assignToCatalog: data.assignToCatalog,
      transformWith: data.transformWith,
      schema: data.schema,
      extra: data.extra,
      allowEditGroupMembers: data.allowEditGroupMembers,
    },
    errors: {
      403: 'Operation not allowed. Only Editors can access it.',
    },
  });
};

/**
 * Add a record
 * Add one or more record from an XML fragment, URL or file in a folder on the catalog server. When loadingfrom the catalog server folder, it might be faster to use a local filesystem harvester.
 * @param data The data for the request.
 * @param data.metadataType The type of record.
 * @param data.url URL of a file to download and insert.
 * @param data.serverFolder Server folder where to look for files.
 * @param data.recursiveSearch (Server folder import only) Recursive search in folder.
 * @param data.publishToAll (XML file only and if workflow is not enabled) Publish record.
 * @param data.assignToCatalog (MEF file only) Assign to current catalog.
 * @param data.uuidProcessing Record identifier processing.
 * @param data.group The group the record is attached to.
 * @param data.category Tags to assign to the record.
 * @param data.rejectIfInvalid Validate the record first and reject it if not valid.
 * @param data.transformWith XSL transformation to apply to the record.
 * @param data.schema Force the schema of the record. If not set, schema autodetection is used (and is the preferred method).
 * @param data.allowEditGroupMembers Is editable by group members with editor profile? If not, only the author and administrator can edit the record.
 * @param data.extra (experimental) Add extra information to the record.
 * @param data.requestBody
 * @returns SimpleMetadataProcessingReport Report about imported records.
 * @throws ApiError
 */
export const insert = (
  data: InsertData = {}
): CancelablePromise<InsertResponse> => {
  return __request(OpenAPI, {
    method: 'PUT',
    url: '/records',
    query: {
      metadataType: data.metadataType,
      url: data.url,
      serverFolder: data.serverFolder,
      recursiveSearch: data.recursiveSearch,
      publishToAll: data.publishToAll,
      assignToCatalog: data.assignToCatalog,
      uuidProcessing: data.uuidProcessing,
      group: data.group,
      category: data.category,
      rejectIfInvalid: data.rejectIfInvalid,
      transformWith: data.transformWith,
      schema: data.schema,
      allowEditGroupMembers: data.allowEditGroupMembers,
      extra: data.extra,
    },
    body: data.requestBody,
    mediaType: 'application/xml',
    errors: {
      403: 'Operation not allowed. Only Editors can access it.',
    },
  });
};

/**
 * Set the records status to approved
 * @param data The data for the request.
 * @param data.requestBody
 * @returns MetadataProcessingReport Metadata approved .
 * @throws ApiError
 */
export const approve = (
  data: ApproveData
): CancelablePromise<ApproveResponse> => {
  return __request(OpenAPI, {
    method: 'PUT',
    url: '/records/approve',
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
      400: 'Metadata workflow not enabled.',
    },
  });
};

/**
 * Trigger MEF backup archive
 * The backup contains all metadata not harvested including templates.
 * @returns string Return succeed message.
 * @throws ApiError
 */
export const trigger = (): CancelablePromise<TriggerResponse> => {
  return __request(OpenAPI, {
    method: 'PUT',
    url: '/records/backups',
  });
};

/**
 * Download MEF backup archive
 * The backup contains all metadata not harvested including templates.
 * @throws ApiError
 */
export const downloadBackup = (): CancelablePromise<void> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/records/backups/latest',
    errors: {
      404: 'Resource not found.',
    },
  });
};

/**
 * Edit a set of records by XPath expressions. This operations applies the update-fixed-info.xsl transformation for the metadata schema and updates the change date if the parameter updateDateStamp is set to true.
 * @param data The data for the request.
 * @param data.requestBody
 * @param data.uuids Record UUIDs. If null current selection is used.
 * @param data.bucket Selection bucket name
 * @param data.updateDateStamp If true updates the DateStamp (or equivalent in standards different to ISO 19139) field in the metadata with the current timestamp
 * @returns IProcessingReport Return a report of what has been done.
 * @throws ApiError
 */
export const batchEdit = (
  data: BatchEditData
): CancelablePromise<BatchEditResponse> => {
  return __request(OpenAPI, {
    method: 'PUT',
    url: '/records/batchediting',
    query: {
      uuids: data.uuids,
      bucket: data.bucket,
      updateDateStamp: data.updateDateStamp,
    },
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
      403: 'Operation not allowed. User needs to be able to edit the resource.',
    },
  });
};

/**
 * Preview edits made by XPath expressions.
 * @param data The data for the request.
 * @param data.requestBody
 * @param data.uuids Record UUIDs. If null current selection is used.
 * @param data.bucket Selection bucket name
 * @param data.diffType Return differences with diff, diffhtml or patch
 * @returns unknown Processed records.
 * @throws ApiError
 */
export const previewBatchEdit = (
  data: PreviewBatchEditData
): CancelablePromise<PreviewBatchEditResponse> => {
  return __request(OpenAPI, {
    method: 'POST',
    url: '/records/batchediting/preview',
    query: {
      uuids: data.uuids,
      bucket: data.bucket,
      diffType: data.diffType,
    },
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
      403: 'Operation not allowed. User needs to be able to edit the resource.',
    },
  });
};

/**
 * Get a set of metadata records as CSV
 * The CSV is a short summary of each records.
 * @param data The data for the request.
 * @param data.uuids Record UUIDs. If null current selection is used.
 * @param data.bucket Selection bucket name
 * @param data.loopElementXpath XPath pointing to the XML element to loop on.
 * @param data.propertiesXpath Properties to collect
 * @param data.sep Column separator
 * @param data.internalSep Multiple values separator
 * @returns unknown Return requested records as CSV.
 * @throws ApiError
 */
export const exportAsCsv = (
  data: ExportAsCsvData = {}
): CancelablePromise<ExportAsCsvResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/records/csv',
    query: {
      uuids: data.uuids,
      bucket: data.bucket,
      loopElementXpath: data.loopElementXpath,
      propertiesXpath: data.propertiesXpath,
      sep: data.sep,
      internalSep: data.internalSep,
    },
    errors: {
      403: 'Operation not allowed. User needs to be able to view the resource.',
    },
  });
};

/**
 * Create a new record
 * Create a record from a template or by copying an existing record.Return the UUID of the newly created record. Existing links in the source record are preserved, this means that the new record may contains link to the source attachments. They need to be manually updated after creation.
 * @param data The data for the request.
 * @param data.sourceUuid UUID of the source record to copy.
 * @param data.group The group the record is attached to.
 * @param data.metadataType The type of record.
 * @param data.targetUuid Assign a custom UUID. If this UUID already exist an error is returned. This is enabled only if metadata create / generate UUID settings is activated.
 * @param data.allowEditGroupMembers Is editable by group members with editor profile? If not, only the author and administrator can edit the record.
 * @param data.category Tags to assign to the record.
 * @param data.hasCategoryOfSource Copy categories from source?
 * @param data.isChildOfSource Is child of the record to copy?
 * @param data.hasAttachmentsOfSource Copy attachments from source?
 * @returns string Return the internal id of the newly created record.
 * @throws ApiError
 */
export const create = (data: CreateData): CancelablePromise<CreateResponse> => {
  return __request(OpenAPI, {
    method: 'PUT',
    url: '/records/duplicate',
    query: {
      metadataType: data.metadataType,
      sourceUuid: data.sourceUuid,
      targetUuid: data.targetUuid,
      group: data.group,
      allowEditGroupMembers: data.allowEditGroupMembers,
      category: data.category,
      hasCategoryOfSource: data.hasCategoryOfSource,
      isChildOfSource: data.isChildOfSource,
      hasAttachmentsOfSource: data.hasAttachmentsOfSource,
    },
    errors: {
      403: 'Operation not allowed. Only Editors can access it.',
    },
  });
};

/**
 * Add a map metadata record from OGC OWS context
 * Add record in the catalog by uploading a map context.
 * @param data The data for the request.
 * @param data.title A map title
 * @param data.recordAbstract A map abstract
 * @param data.xml OGC OWS context as string
 * @param data.filename OGC OWS context file name
 * @param data.url OGC OWS context URL
 * @param data.viewerUrl A map viewer URL to visualize the map
 * @param data.overview Map overview as PNG (base64 encoded)
 * @param data.overviewFilename Map overview filename
 * @param data.topic Topic category
 * @param data.publishToAll Publish record.
 * @param data.uuidProcessing Record identifier processing.
 * @param data.group The group the record is attached to.
 * @returns SimpleMetadataProcessingReport Report about imported records.
 * @throws ApiError
 */
export const insertOgcMapContextFile = (
  data: InsertOgcMapContextFileData
): CancelablePromise<InsertOgcMapContextFileResponse> => {
  return __request(OpenAPI, {
    method: 'POST',
    url: '/records/importfrommap',
    query: {
      title: data.title,
      recordAbstract: data.recordAbstract,
      xml: data.xml,
      filename: data.filename,
      url: data.url,
      viewerUrl: data.viewerUrl,
      overview: data.overview,
      overviewFilename: data.overviewFilename,
      topic: data.topic,
      publishToAll: data.publishToAll,
      uuidProcessing: data.uuidProcessing,
      group: data.group,
    },
    errors: {
      403: 'Operation not allowed. Only Editors can access it.',
    },
  });
};

/**
 * Index a set of records
 * Index a set of records provided either by a bucket or a list of uuids
 * @param data The data for the request.
 * @param data.uuids Record UUIDs. If null current selection is used.
 * @param data.bucket Selection bucket name
 * @returns IndexResponse Record indexed.
 * @throws ApiError
 */
export const index = (
  data: IndexData = {}
): CancelablePromise<IndexResponse2> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/records/index',
    query: {
      uuids: data.uuids,
      bucket: data.bucket,
    },
    errors: {
      403: 'Operation not allowed. Only Administrators can access it.',
    },
  });
};

/**
 * Remove all links and status history
 * @returns unknown OK
 * @throws ApiError
 */
export const purgeAll = (): CancelablePromise<PurgeAllResponse> => {
  return __request(OpenAPI, {
    method: 'DELETE',
    url: '/records/links',
  });
};

/**
 * Get record links
 * @param data The data for the request.
 * @param data.filter Filter, e.g. "{url: 'png', lastState: 'ko', records: 'e421'}", lastState being 'ok'/'ko'/'unknown'
 * @param data.groupIdFilter Optional, filter links to records published in that group.
 * @param data.groupOwnerIdFilter Optional, filter links to records created in that group.
 * @param data.httpErrorStatusValueFilter Optional, filter links to http status.
 * @param data.excludeHarvestedMetadataFilter Optional, filter links excluding harvested metadata.
 * @param data.page Results page you want to retrieve (0..N)
 * @param data.size Number of records per page.
 * @param data.sort Sorting criteria in the format: property(,asc|desc). Default sort order is ascending.
 * @returns PageLink OK
 * @throws ApiError
 */
export const getRecordLinks = (
  data: GetRecordLinksData = {}
): CancelablePromise<GetRecordLinksResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/records/links',
    query: {
      filter: data.filter,
      groupIdFilter: data.groupIdFilter,
      groupOwnerIdFilter: data.groupOwnerIdFilter,
      httpErrorStatusValueFilter: data.httpErrorStatusValueFilter,
      excludeHarvestedMetadataFilter: data.excludeHarvestedMetadataFilter,
      page: data.page,
      size: data.size,
      sort: data.sort,
    },
  });
};

/**
 * Get record links
 * @param data The data for the request.
 * @param data.filter Filter, e.g. "{url: 'png', lastState: 'ko', records: 'e421'}", lastState being 'ok'/'ko'/'unknown'
 * @param data.groupIdFilter Optional, filter links to records published in that group.
 * @param data.groupOwnerIdFilter Optional, filter links to records created in that group.
 * @param data.httpStatusValueFilter Optional, filter links to http status.
 * @param data.excludeHarvestedMetadataFilter Optional, filter links excluding harvested metadata.
 * @param data.page Results page you want to retrieve (0..N)
 * @param data.size Number of records per page.
 * @param data.sort Sorting criteria in the format: property(,asc|desc). Default sort order is ascending.
 * @returns PageLink OK
 * @throws ApiError
 */
export const getRecordLinksPost = (
  data: GetRecordLinksPostData = {}
): CancelablePromise<GetRecordLinksPostResponse> => {
  return __request(OpenAPI, {
    method: 'POST',
    url: '/records/links',
    query: {
      filter: data.filter,
      groupIdFilter: data.groupIdFilter,
      groupOwnerIdFilter: data.groupOwnerIdFilter,
      httpStatusValueFilter: data.httpStatusValueFilter,
      excludeHarvestedMetadataFilter: data.excludeHarvestedMetadataFilter,
      page: data.page,
      size: data.size,
      sort: data.sort,
    },
  });
};

/**
 * Analyze records links
 * One of uuids or bucket parameter is required if not an Administrator. Only records that you can edit will be validated.
 * @param data The data for the request.
 * @param data.uuids Record UUIDs. If null current selection is used.
 * @param data.bucket Selection bucket name
 * @param data.removeFirst Only allowed if Administrator.
 * @param data.analyze
 * @returns SimpleMetadataProcessingReport Created
 * @throws ApiError
 */
export const analyzeRecordLinks = (
  data: AnalyzeRecordLinksData = {}
): CancelablePromise<AnalyzeRecordLinksResponse> => {
  return __request(OpenAPI, {
    method: 'POST',
    url: '/records/links/analyze',
    query: {
      uuids: data.uuids,
      bucket: data.bucket,
      removeFirst: data.removeFirst,
      analyze: data.analyze,
    },
  });
};

/**
 * Analyze one or more links
 * @param data The data for the request.
 * @param data.url URL
 * @returns unknown Created
 * @throws ApiError
 */
export const analyzeLinks = (
  data: AnalyzeLinksData = {}
): CancelablePromise<AnalyzeLinksResponse> => {
  return __request(OpenAPI, {
    method: 'POST',
    url: '/records/links/analyzeurl',
    query: {
      url: data.url,
    },
  });
};

/**
 * Get record links as CSV
 * @param data The data for the request.
 * @param data.filter Filter, e.g. "{url: 'png', lastState: 'ko', records: 'e421'}", lastState being 'ok'/'ko'/'unknown'
 * @param data.groupIdFilter Optional, filter links to records published in that group.
 * @param data.groupOwnerIdFilter Optional, filter links to records created in that group.
 * @param data.httpStatusValueFilter Optional, filter links to http status.
 * @param data.excludeHarvestedMetadataFilter Optional, filter links excluding harvested metadata.
 * @param data.page Results page you want to retrieve (0..N)
 * @param data.size Number of records per page.
 * @param data.sort Sorting criteria in the format: property(,asc|desc). Default sort order is ascending.
 * @returns unknown OK
 * @throws ApiError
 */
export const getRecordLinksAsCsv = (
  data: GetRecordLinksAsCsvData = {}
): CancelablePromise<GetRecordLinksAsCsvResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/records/links/csv',
    query: {
      filter: data.filter,
      groupIdFilter: data.groupIdFilter,
      groupOwnerIdFilter: data.groupOwnerIdFilter,
      httpStatusValueFilter: data.httpStatusValueFilter,
      excludeHarvestedMetadataFilter: data.excludeHarvestedMetadataFilter,
      page: data.page,
      size: data.size,
      sort: data.sort,
    },
  });
};

/**
 * Set group and owner for one or more records
 * @param data The data for the request.
 * @param data.groupIdentifier Group identifier
 * @param data.userIdentifier User identifier
 * @param data.uuids Record UUIDs. If null current selection is used.
 * @param data.bucket Selection bucket name
 * @param data.approved Use approved version or not
 * @returns MetadataProcessingReport Records group and owner updated
 * @throws ApiError
 */
export const setGroupAndOwner = (
  data: SetGroupAndOwnerData
): CancelablePromise<SetGroupAndOwnerResponse> => {
  return __request(OpenAPI, {
    method: 'PUT',
    url: '/records/ownership',
    query: {
      uuids: data.uuids,
      groupIdentifier: data.groupIdentifier,
      bucket: data.bucket,
      userIdentifier: data.userIdentifier,
      approved: data.approved,
    },
    errors: {
      403: 'Operation not allowed. User needs to be able to edit the resource.',
    },
  });
};

/**
 * Get a set of metadata records as PDF
 * The PDF is a short summary of each records with links to the complete metadata record in different format (ie. landing page on the portal, XML)
 * @param data The data for the request.
 * @param data.uuids Record UUIDs. If null current selection is used.
 * @param data.bucket Selection bucket name
 * @returns unknown Return requested records as PDF.
 * @throws ApiError
 */
export const exportAsPdf = (
  data: ExportAsPdfData = {}
): CancelablePromise<ExportAsPdfResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/records/pdf',
    query: {
      uuids: data.uuids,
      bucket: data.bucket,
    },
    errors: {
      403: 'Operation not allowed. User needs to be able to view the resource.',
    },
  });
};

/**
 * Publish one or more records
 * See record sharing for more details.
 * @param data The data for the request.
 * @param data.publicationType Publication type
 * @param data.uuids Record UUIDs. If null current selection is used.
 * @param data.bucket Selection bucket name
 * @returns MetadataProcessingReport Report about updated privileges.
 * @throws ApiError
 */
export const publishMultipleRecords = (
  data: PublishMultipleRecordsData
): CancelablePromise<PublishMultipleRecordsResponse> => {
  return __request(OpenAPI, {
    method: 'PUT',
    url: '/records/publish',
    query: {
      uuids: data.uuids,
      bucket: data.bucket,
      publicationType: data.publicationType,
    },
    errors: {
      403: 'Operation not allowed. Only Editors can access it.',
    },
  });
};

/**
 * Add samples
 * Add sample records for one or more schemas. Samples are defined for each standard in the samples folder as MEF files.
 * @param data The data for the request.
 * @param data.schema Schema identifiers
 * @returns SimpleMetadataProcessingReport Return a report of what has been done.
 * @throws ApiError
 */
export const addSamples = (
  data: AddSamplesData
): CancelablePromise<AddSamplesResponse> => {
  return __request(OpenAPI, {
    method: 'PUT',
    url: '/records/samples',
    query: {
      schema: data.schema,
    },
    errors: {
      403: 'Operation not allowed. Only Administrators can access it.',
    },
  });
};

/**
 * Get record sharing settings
 * @returns SharingResponse Return a default array of group and operations that can be used to set record sharing properties.
 * @throws ApiError
 */
export const getSharingSettings =
  (): CancelablePromise<GetSharingSettingsResponse> => {
    return __request(OpenAPI, {
      method: 'GET',
      url: '/records/sharing',
      errors: {
        403: 'Operation not allowed. User needs to be able to edit the resource.',
      },
    });
  };

/**
 * Set sharing settings for one or more records
 * See record sharing for more details.
 * @param data The data for the request.
 * @param data.requestBody
 * @param data.uuids Record UUIDs. If null current selection is used.
 * @param data.bucket Selection bucket name
 * @returns MetadataProcessingReport Report about updated privileges.
 * @throws ApiError
 */
export const shareMultipleRecords = (
  data: ShareMultipleRecordsData
): CancelablePromise<ShareMultipleRecordsResponse> => {
  return __request(OpenAPI, {
    method: 'PUT',
    url: '/records/sharing',
    query: {
      uuids: data.uuids,
      bucket: data.bucket,
    },
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
      403: 'Operation not allowed. Only Editors can access it.',
    },
  });
};

/**
 * Get publication options.
 * @returns PublicationOption OK
 * @throws ApiError
 */
export const getPublicationOptions =
  (): CancelablePromise<GetPublicationOptionsResponse> => {
    return __request(OpenAPI, {
      method: 'GET',
      url: '/records/sharing/options',
    });
  };

/**
 * Search status
 * @param data The data for the request.
 * @param data.type One or more types to retrieve (ie. worflow, event, task). Default is all.
 * @param data.details All event details including XML changes. Responses are bigger. Default is false
 * @param data.sortOrder Sort Order (ie. DESC or ASC). Default is none.
 * @param data.author One or more event author. Default is all.
 * @param data.owner One or more event owners. Default is all.
 * @param data.id One or more record identifier. Default is all.
 * @param data.recordIdentifier One or more metadata record identifier. Default is all.
 * @param data.uuid One or more metadata uuid. Default is all.
 * @param data.statusIds One or more status id. Default is all.
 * @param data.dateFrom Start date
 * @param data.dateTo End date
 * @param data.from From page
 * @param data.size Number of records to return
 * @returns MetadataStatusResponse OK
 * @throws ApiError
 */
export const getWorkflowStatusByType = (
  data: GetWorkflowStatusByTypeData = {}
): CancelablePromise<GetWorkflowStatusByTypeResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/records/status/search',
    query: {
      type: data.type,
      details: data.details,
      sortOrder: data.sortOrder,
      author: data.author,
      owner: data.owner,
      id: data.id,
      recordIdentifier: data.recordIdentifier,
      uuid: data.uuid,
      statusIds: data.statusIds,
      dateFrom: data.dateFrom,
      dateTo: data.dateTo,
      from: data.from,
      size: data.size,
    },
  });
};

/**
 * Set the records status to submitted
 * @param data The data for the request.
 * @param data.requestBody
 * @returns MetadataProcessingReport Metadata submitted .
 * @throws ApiError
 */
export const submit = (data: SubmitData): CancelablePromise<SubmitResponse> => {
  return __request(OpenAPI, {
    method: 'PUT',
    url: '/records/submit',
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
      400: 'Metadata workflow not enabled.',
    },
  });
};

/**
 * Delete tags to one or more records
 * @param data The data for the request.
 * @param data.id Tag identifier
 * @param data.uuids Record UUIDs. If null current selection is used.
 * @param data.bucket Selection bucket name
 * @returns MetadataProcessingReport Report about removed records.
 * @throws ApiError
 */
export const deleteTagForRecords = (
  data: DeleteTagForRecordsData
): CancelablePromise<DeleteTagForRecordsResponse> => {
  return __request(OpenAPI, {
    method: 'DELETE',
    url: '/records/tags',
    query: {
      uuids: data.uuids,
      bucket: data.bucket,
      id: data.id,
    },
    errors: {
      403: 'Operation not allowed. Only Editors can access it.',
    },
  });
};

/**
 * Add or remove tags to one or more records
 * @param data The data for the request.
 * @param data.uuids Record UUIDs. If null current selection is used.
 * @param data.bucket Selection bucket name
 * @param data.id Tag identifier
 * @param data.removeId Tag identifier to remove.
 * @param data.clear Clear all before adding new ones
 * @returns MetadataProcessingReport Report about updated records.
 * @throws ApiError
 */
export const tagRecords = (
  data: TagRecordsData = {}
): CancelablePromise<TagRecordsResponse> => {
  return __request(OpenAPI, {
    method: 'PUT',
    url: '/records/tags',
    query: {
      uuids: data.uuids,
      bucket: data.bucket,
      id: data.id,
      removeId: data.removeId,
      clear: data.clear,
    },
    errors: {
      403: 'Operation not allowed. Only Editors can access it.',
    },
  });
};

/**
 * Add templates
 * Add template records for one or more schemas. Templates are defined for each standard in the template folder as XML files. Template may also contains subtemplates.
 * @param data The data for the request.
 * @param data.schema Schema identifiers
 * @returns SimpleMetadataProcessingReport Return a report of what has been done.
 * @throws ApiError
 */
export const addTemplates = (
  data: AddTemplatesData
): CancelablePromise<AddTemplatesResponse> => {
  return __request(OpenAPI, {
    method: 'PUT',
    url: '/records/templates',
    query: {
      schema: data.schema,
    },
    errors: {
      403: 'Operation not allowed. Only Administrators can access it.',
    },
  });
};

/**
 * Un-publish one or more records
 * See record sharing for more details.
 * @param data The data for the request.
 * @param data.publicationType Publication type
 * @param data.uuids Record UUIDs. If null current selection is used.
 * @param data.bucket Selection bucket name
 * @returns MetadataProcessingReport Report about updated privileges.
 * @throws ApiError
 */
export const unpublishMultipleRecords = (
  data: UnpublishMultipleRecordsData
): CancelablePromise<UnpublishMultipleRecordsResponse> => {
  return __request(OpenAPI, {
    method: 'PUT',
    url: '/records/unpublish',
    query: {
      uuids: data.uuids,
      bucket: data.bucket,
      publicationType: data.publicationType,
    },
    errors: {
      403: 'Operation not allowed. Only Editors can access it.',
    },
  });
};

/**
 * Clear validation status of one or more records
 * @param data The data for the request.
 * @param data.uuids Record UUIDs. If null current selection is used.
 * @param data.bucket Selection bucket name
 * @returns SimpleMetadataProcessingReport Records validation status cleared.
 * @throws ApiError
 */
export const cleanValidationStatus = (
  data: CleanValidationStatusData = {}
): CancelablePromise<CleanValidationStatusResponse> => {
  return __request(OpenAPI, {
    method: 'DELETE',
    url: '/records/validate',
    query: {
      uuids: data.uuids,
      bucket: data.bucket,
    },
    errors: {
      403: 'Operation not allowed. Only Editors can access it.',
    },
  });
};

/**
 * Validate one or more records
 * Update validation status for all records.
 * @param data The data for the request.
 * @param data.uuids Record UUIDs. If null current selection is used.
 * @param data.approved Use approved version or not
 * @param data.bucket Selection bucket name
 * @returns SimpleMetadataProcessingReport Records validated.
 * @throws ApiError
 */
export const validateRecords = (
  data: ValidateRecordsData = {}
): CancelablePromise<ValidateRecordsResponse> => {
  return __request(OpenAPI, {
    method: 'PUT',
    url: '/records/validate',
    query: {
      uuids: data.uuids,
      approved: data.approved,
      bucket: data.bucket,
    },
    errors: {
      403: 'Operation not allowed. Only Editors can access it.',
    },
  });
};

/**
 * Validate one or more records in INSPIRE validator
 * Update validation status for all records.
 * @param data The data for the request.
 * @param data.uuids Record UUIDs. If null current selection is used.
 * @param data.bucket Selection bucket name
 * @param data.mode Define the encoding of the record to use. By default, ISO19139 are used as is and ISO19115-3 are converted to ISO19139.If mode = csw, a GetRecordById request is used.If mode = any portal id, then a GetRecordById request is used on this portal CSW entry point which may define custom CSW post processing. See https://github.com/geonetwork/core-geonetwork/pull/4493.
 * @returns string Records validated.
 * @throws ApiError
 */
export const validateRecordsInspire = (
  data: ValidateRecordsInspireData = {}
): CancelablePromise<ValidateRecordsInspireResponse> => {
  return __request(OpenAPI, {
    method: 'PUT',
    url: '/records/validate/inspire',
    query: {
      uuids: data.uuids,
      bucket: data.bucket,
      mode: data.mode,
    },
    errors: {
      403: 'Operation not allowed. Only Editors can access it.',
    },
  });
};

/**
 * (Experimental) Enable version control for one or more records
 * @param data The data for the request.
 * @param data.uuids Record UUIDs. If null current selection is used.
 * @param data.bucket Selection bucket name
 * @returns MetadataProcessingReport OK
 * @throws ApiError
 */
export const enableVersionControlForRecords = (
  data: EnableVersionControlForRecordsData = {}
): CancelablePromise<EnableVersionControlForRecordsResponse> => {
  return __request(OpenAPI, {
    method: 'PUT',
    url: '/records/versions',
    query: {
      uuids: data.uuids,
      bucket: data.bucket,
    },
  });
};

/**
 * Get a set of metadata records as ZIP
 * Metadata Exchange Format (MEF) is returned. MEF is a ZIP file containing the metadata as XML and some others files depending on the version requested. See https://docs.geonetwork-opensource.org/latest/annexes/mef-format/.
 * @param data The data for the request.
 * @param data.uuids Record UUIDs. If null current selection is used.
 * @param data.bucket Selection bucket name
 * @param data.format MEF file format.
 * @param data.withRelated With related records (parent and service).
 * @param data.withXlinksResolved Resolve XLinks in the records.
 * @param data.withXlinkAttribute Preserve XLink URLs in the records.
 * @param data.addSchemaLocation
 * @param data.approved Download the approved version
 * @returns unknown Return requested records as ZIP.
 * @throws ApiError
 */
export const exportAsMef = (
  data: ExportAsMefData = {}
): CancelablePromise<ExportAsMefResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/records/zip',
    query: {
      uuids: data.uuids,
      bucket: data.bucket,
      format: data.format,
      withRelated: data.withRelated,
      withXLinksResolved: data.withXlinksResolved,
      withXLinkAttribute: data.withXlinkAttribute,
      addSchemaLocation: data.addSchemaLocation,
      approved: data.approved,
    },
    errors: {
      403: 'Operation not allowed. User needs to be able to view the resource.',
    },
  });
};

/**
 * Delete a record
 * User MUST be able to edit the record to delete it. By default, a backup is made in ZIP format. After that, the record attachments are removed, the document removed from the index and then from the database.
 * @param data The data for the request.
 * @param data.metadataUuid Record UUID.
 * @param data.withBackup Backup first the record as MEF in the metadata removed folder.
 * @returns void Record deleted.
 * @throws ApiError
 */
export const deleteRecord = (
  data: DeleteRecordData
): CancelablePromise<DeleteRecordResponse> => {
  return __request(OpenAPI, {
    method: 'DELETE',
    url: '/records/{metadataUuid}',
    path: {
      metadataUuid: data.metadataUuid,
    },
    query: {
      withBackup: data.withBackup,
    },
    errors: {
      401: 'This template is referenced',
      403: 'Operation not allowed. User needs to be able to edit the resource.',
    },
  });
};

/**
 * Get a metadata record
 * Accept header should indicate which is the appropriate format to return. It could be text/html, application/xml, application/zip, ...If no appropriate Accept header found, the XML format is returned.Depending on the accept header the appropriate formatter is used. When requesting a ZIP, a MEF version 2 file is returned. When requesting HTML, the default formatter is used.
 * @param data The data for the request.
 * @param data.metadataUuid Record UUID.
 * @returns binary Return the record.
 * @throws ApiError
 */
export const getRecord = (
  data: GetRecordData
): CancelablePromise<GetRecordResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/records/{metadataUuid}',
    path: {
      metadataUuid: data.metadataUuid,
    },
    errors: {
      403: 'Operation not allowed. User needs to be able to view the resource.',
      404: 'Resource not found.',
    },
  });
};

/**
 * Send an email to catalogue administrator or record's contact
 * @param data The data for the request.
 * @param data.metadataUuid Metadata record UUID.
 * @param data.name User name.
 * @param data.org User organisation.
 * @param data.email User email address.
 * @param data.comments A comment or question.
 * @param data.recaptcha Recaptcha validation key.
 * @param data.phone User phone number.
 * @param data.subject Email subject.
 * @param data._function User function.
 * @param data.type Comment type.
 * @param data.category Comment category.
 * @param data.metadataEmail List of record's contact to send this email (separated by comma).
 * @returns string Created
 * @throws ApiError
 */
export const sendEmailToContact = (
  data: SendEmailToContactData
): CancelablePromise<SendEmailToContactResponse> => {
  return __request(OpenAPI, {
    method: 'POST',
    url: '/records/{metadataUuid}/alert',
    path: {
      metadataUuid: data.metadataUuid,
    },
    query: {
      recaptcha: data.recaptcha,
      name: data.name,
      org: data.org,
      email: data.email,
      comments: data.comments,
      phone: data.phone,
      subject: data.subject,
      function: data._function,
      type: data.type,
      category: data.category,
      metadataEmail: data.metadataEmail,
    },
  });
};

/**
 * Get record associated resources
 * Retrieve related services, datasets, sources, ... to this records.<br/><a href='https://docs.geonetwork-opensource.org/latest/user-guide/associating-resources/'>More info</a>
 * @param data The data for the request.
 * @param data.metadataUuid Record UUID.
 * @param data.type Type of related resource. If none, all resources are returned.
 * @param data.approved Use approved version or not
 * @param data.start Start offset for paging. Default 1. Only applies to related metadata records (ie. not for thumbnails).
 * @param data.rows Number of rows returned. Default 100.
 * @returns AssociatedRecord Return the associated resources.
 * @throws ApiError
 */
export const getAssociatedResources = (
  data: GetAssociatedResourcesData
): CancelablePromise<GetAssociatedResourcesResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/records/{metadataUuid}/associated',
    path: {
      metadataUuid: data.metadataUuid,
    },
    query: {
      type: data.type,
      approved: data.approved,
      start: data.start,
      rows: data.rows,
    },
    errors: {
      403: 'Operation not allowed. User needs to be able to view the resource.',
    },
  });
};

/**
 * Delete all uploaded metadata resources
 * @param data The data for the request.
 * @param data.metadataUuid The metadata UUID
 * @param data.approved Use approved version or not
 * @returns void Attachment added.
 * @throws ApiError
 */
export const delResources = (
  data: DelResourcesData
): CancelablePromise<DelResourcesResponse> => {
  return __request(OpenAPI, {
    method: 'DELETE',
    url: '/records/{metadataUuid}/attachments',
    path: {
      metadataUuid: data.metadataUuid,
    },
    query: {
      approved: data.approved,
    },
    errors: {
      403: 'Operation not allowed. User needs to be able to edit the resource.',
    },
  });
};

/**
 * List all metadata attachments
 * <a href='https://docs.geonetwork-opensource.org/latest/user-guide/associating-resources/using-filestore/'>More info</a>
 * @param data The data for the request.
 * @param data.metadataUuid The metadata UUID
 * @param data.sort Sort by
 * @param data.approved Use approved version or not
 * @param data.filter
 * @returns MetadataResource Return the record attachments.
 * @throws ApiError
 */
export const getAllResources = (
  data: GetAllResourcesData
): CancelablePromise<GetAllResourcesResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/records/{metadataUuid}/attachments',
    path: {
      metadataUuid: data.metadataUuid,
    },
    query: {
      sort: data.sort,
      approved: data.approved,
      filter: data.filter,
    },
    errors: {
      403: 'Operation not allowed. User needs to be able to view the resource.',
    },
  });
};

/**
 * Create a new resource for a given metadata
 * @param data The data for the request.
 * @param data.metadataUuid The metadata UUID
 * @param data.visibility The sharing policy
 * @param data.approved Use approved version or not
 * @param data.requestBody
 * @returns MetadataResource Attachment uploaded.
 * @throws ApiError
 */
export const putResource = (
  data: PutResourceData
): CancelablePromise<PutResourceResponse> => {
  return __request(OpenAPI, {
    method: 'POST',
    url: '/records/{metadataUuid}/attachments',
    path: {
      metadataUuid: data.metadataUuid,
    },
    query: {
      visibility: data.visibility,
      approved: data.approved,
    },
    body: data.requestBody,
    mediaType: '*/*',
    errors: {
      403: 'Operation not allowed. User needs to be able to edit the resource.',
    },
  });
};

/**
 * Create a new resource from a URL for a given metadata
 * @param data The data for the request.
 * @param data.metadataUuid The metadata UUID
 * @param data.url The URL to load in the store
 * @param data.visibility The sharing policy
 * @param data.approved Use approved version or not
 * @returns MetadataResource Attachment added.
 * @throws ApiError
 */
export const putResourceFromUrl = (
  data: PutResourceFromUrlData
): CancelablePromise<PutResourceFromUrlResponse> => {
  return __request(OpenAPI, {
    method: 'PUT',
    url: '/records/{metadataUuid}/attachments',
    path: {
      metadataUuid: data.metadataUuid,
    },
    query: {
      visibility: data.visibility,
      url: data.url,
      approved: data.approved,
    },
    errors: {
      403: 'Operation not allowed. User needs to be able to edit the resource.',
    },
  });
};

/**
 * Create an overview using the map print module
 * <a href='https://docs.geonetwork-opensource.org/latest/user-guide/associating-resources/linking-thumbnail/#linking-thumbnail-from-wms'>More info</a>
 * @param data The data for the request.
 * @param data.metadataUuid Record UUID.
 * @param data.jsonConfig The mapprint module JSON configuration
 * @param data.rotationAngle The rotation angle of the map
 * @returns MetadataResource Thumbnail created.
 * @throws ApiError
 */
export const saveThumbnail = (
  data: SaveThumbnailData
): CancelablePromise<SaveThumbnailResponse> => {
  return __request(OpenAPI, {
    method: 'PUT',
    url: '/records/{metadataUuid}/attachments/print-thumbnail',
    path: {
      metadataUuid: data.metadataUuid,
    },
    query: {
      jsonConfig: data.jsonConfig,
      rotationAngle: data.rotationAngle,
    },
    errors: {
      403: 'Operation not allowed. User needs to be able to edit the resource.',
    },
  });
};

/**
 * Delete a metadata resource
 * @param data The data for the request.
 * @param data.metadataUuid The metadata UUID
 * @param data.resourceId The resource identifier (ie. filename)
 * @param data.approved Use approved version or not
 * @returns void Attachment visibility removed.
 * @throws ApiError
 */
export const delResource = (
  data: DelResourceData
): CancelablePromise<DelResourceResponse> => {
  return __request(OpenAPI, {
    method: 'DELETE',
    url: '/records/{metadataUuid}/attachments/{resourceId}',
    path: {
      metadataUuid: data.metadataUuid,
      resourceId: data.resourceId,
    },
    query: {
      approved: data.approved,
    },
    errors: {
      403: 'Operation not allowed. User needs to be able to edit the resource.',
    },
  });
};

/**
 * Get a metadata resource
 * @param data The data for the request.
 * @param data.metadataUuid The metadata UUID
 * @param data.resourceId The resource identifier (ie. filename)
 * @param data.approved Use approved version or not
 * @param data.size Size (only applies to images). From 1px to 2048px.
 * @returns binary Record attachment.
 * @throws ApiError
 */
export const getResource = (
  data: GetResourceData
): CancelablePromise<GetResourceResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/records/{metadataUuid}/attachments/{resourceId}',
    path: {
      metadataUuid: data.metadataUuid,
      resourceId: data.resourceId,
    },
    query: {
      approved: data.approved,
      size: data.size,
    },
    errors: {
      403: 'Operation not allowed. User needs to be able to download the resource.',
    },
  });
};

/**
 * Update the metadata resource visibility
 * @param data The data for the request.
 * @param data.metadataUuid The metadata UUID
 * @param data.resourceId The resource identifier (ie. filename)
 * @param data.visibility The visibility
 * @param data.approved Use approved version or not
 * @returns MetadataResource Attachment visibility updated.
 * @throws ApiError
 */
export const patchResource = (
  data: PatchResourceData
): CancelablePromise<PatchResourceResponse> => {
  return __request(OpenAPI, {
    method: 'PATCH',
    url: '/records/{metadataUuid}/attachments/{resourceId}',
    path: {
      metadataUuid: data.metadataUuid,
      resourceId: data.resourceId,
    },
    query: {
      visibility: data.visibility,
      approved: data.approved,
    },
    errors: {
      403: 'Operation not allowed. User needs to be able to edit the resource.',
    },
  });
};

/**
 * Remove a DOI (this is not recommended, DOI are supposed to be persistent once created. This is mainly here for testing).
 * @param data The data for the request.
 * @param data.metadataUuid Record UUID.
 * @returns string DOI unregistered.
 * @throws ApiError
 */
export const unregisterDoi = (
  data: UnregisterDoiData
): CancelablePromise<UnregisterDoiResponse> => {
  return __request(OpenAPI, {
    method: 'DELETE',
    url: '/records/{metadataUuid}/doi',
    path: {
      metadataUuid: data.metadataUuid,
    },
    errors: {
      403: 'Operation not allowed. Only Administrators can access it.',
      404: 'Metadata or DOI not found.',
      500: 'Service unavailable.',
    },
  });
};

/**
 * Submit a record to the Datacite metadata store in order to create a DOI.
 * @param data The data for the request.
 * @param data.metadataUuid Record UUID.
 * @returns string Check status of the report.
 * @throws ApiError
 */
export const createDoi = (
  data: CreateDoiData
): CancelablePromise<CreateDoiResponse> => {
  return __request(OpenAPI, {
    method: 'PUT',
    url: '/records/{metadataUuid}/doi',
    path: {
      metadataUuid: data.metadataUuid,
    },
    errors: {
      403: 'Operation not allowed. User needs to be able to edit the resource.',
      404: 'Metadata not found.',
      500: 'Service unavailable.',
    },
  });
};

/**
 * Check the DOI URL created based on current configuration and pattern.
 * @param data The data for the request.
 * @param data.metadataUuid Record UUID.
 * @returns string DOI URL created.
 * @throws ApiError
 */
export const checkDoiUrl = (
  data: CheckDoiUrlData
): CancelablePromise<CheckDoiUrlResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/records/{metadataUuid}/doi/checkDoiUrl',
    path: {
      metadataUuid: data.metadataUuid,
    },
    errors: {
      403: 'Operation not allowed. User needs to be able to edit the resource.',
      404: 'Metadata not found.',
      500: 'Service unavailable.',
    },
  });
};

/**
 * Check that a record can be submitted to DataCite for DOI creation. DataCite requires some fields to be populated.
 * @param data The data for the request.
 * @param data.metadataUuid Record UUID.
 * @returns boolean Record can be proposed to DataCite.
 * @throws ApiError
 */
export const checkDoiStatus = (
  data: CheckDoiStatusData
): CancelablePromise<CheckDoiStatusResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/records/{metadataUuid}/doi/checkPreConditions',
    path: {
      metadataUuid: data.metadataUuid,
    },
    errors: {
      400: 'Record does not meet preconditions. Check error message.',
      403: 'Operation not allowed. User needs to be able to edit the resource.',
      404: 'Metadata not found.',
      500: 'Service unavailable.',
    },
  });
};

/**
 * Cancel edits
 * Cancel current editing session.
 * @param data The data for the request.
 * @param data.metadataUuid Record UUID.
 * @returns void Editing session cancelled.
 * @throws ApiError
 */
export const cancelEdits = (
  data: CancelEditsData
): CancelablePromise<CancelEditsResponse> => {
  return __request(OpenAPI, {
    method: 'DELETE',
    url: '/records/{metadataUuid}/editor',
    path: {
      metadataUuid: data.metadataUuid,
    },
    errors: {
      403: 'Operation not allowed. User needs to be able to edit the resource.',
    },
  });
};

/**
 * Edit a record
 * Return HTML form for editing.
 * @param data The data for the request.
 * @param data.metadataUuid Record UUID.
 * @param data.currTab Tab
 * @param data.withAttributes
 * @returns unknown The editor form.
 * @throws ApiError
 */
export const startEditing = (
  data: StartEditingData
): CancelablePromise<StartEditingResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/records/{metadataUuid}/editor',
    path: {
      metadataUuid: data.metadataUuid,
    },
    query: {
      currTab: data.currTab,
      withAttributes: data.withAttributes,
    },
    errors: {
      403: 'Operation not allowed. User needs to be able to edit the resource.',
    },
  });
};

/**
 * Save edits
 * Save the HTML form content.
 * @param data The data for the request.
 * @param data.metadataUuid Record UUID.
 * @param data.tab Tab
 * @param data.withAttributes
 * @param data.withValidationErrors
 * @param data.minor
 * @param data.status Submit for review directly after save.
 * @param data.commit Save current edits.
 * @param data.terminate Save and terminate session.
 * @param data.data Record as XML. TODO: rename xml
 * @returns unknown The editor form.
 * @throws ApiError
 */
export const saveEdits = (
  data: SaveEditsData
): CancelablePromise<SaveEditsResponse> => {
  return __request(OpenAPI, {
    method: 'POST',
    url: '/records/{metadataUuid}/editor',
    path: {
      metadataUuid: data.metadataUuid,
    },
    query: {
      tab: data.tab,
      withAttributes: data.withAttributes,
      withValidationErrors: data.withValidationErrors,
      minor: data.minor,
      status: data.status,
      commit: data.commit,
      terminate: data.terminate,
      data: data.data,
    },
    errors: {
      403: 'Operation not allowed. User needs to be able to edit the resource.',
    },
  });
};

/**
 * Delete attribute
 * @param data The data for the request.
 * @param data.metadataUuid Record UUID.
 * @param data.ref Reference of the attribute to remove.
 * @param data.displayAttributes Should attributes be shown on the editor snippet?
 * @returns void Attribute removed.
 * @throws ApiError
 */
export const deleteAttribute = (
  data: DeleteAttributeData
): CancelablePromise<DeleteAttributeResponse> => {
  return __request(OpenAPI, {
    method: 'DELETE',
    url: '/records/{metadataUuid}/editor/attributes',
    path: {
      metadataUuid: data.metadataUuid,
    },
    query: {
      ref: data.ref,
      displayAttributes: data.displayAttributes,
    },
    errors: {
      403: 'Operation not allowed. User needs to be able to edit the resource.',
    },
  });
};

/**
 * Delete element
 * @param data The data for the request.
 * @param data.metadataUuid Record UUID.
 * @param data.ref Reference of the element to remove.
 * @param data.parent Name of the parent.
 * @param data.displayAttributes Should attributes be shown on the editor snippet?
 * @returns void Element removed.
 * @throws ApiError
 */
export const deleteElement = (
  data: DeleteElementData
): CancelablePromise<DeleteElementResponse> => {
  return __request(OpenAPI, {
    method: 'DELETE',
    url: '/records/{metadataUuid}/editor/elements',
    path: {
      metadataUuid: data.metadataUuid,
    },
    query: {
      ref: data.ref,
      parent: data.parent,
      displayAttributes: data.displayAttributes,
    },
    errors: {
      403: 'Operation not allowed. User needs to be able to edit the resource.',
    },
  });
};

/**
 * Add element
 * @param data The data for the request.
 * @param data.metadataUuid Record UUID.
 * @param data.ref Reference of the insertion point.
 * @param data.name Name of the element to add (with prefix)
 * @param data.child Use geonet:attribute for attributes or child name.
 * @param data.displayAttributes Should attributes be shown on the editor snippet?
 * @returns unknown Element added.
 * @throws ApiError
 */
export const addElement = (
  data: AddElementData
): CancelablePromise<AddElementResponse> => {
  return __request(OpenAPI, {
    method: 'PUT',
    url: '/records/{metadataUuid}/editor/elements',
    path: {
      metadataUuid: data.metadataUuid,
    },
    query: {
      ref: data.ref,
      name: data.name,
      child: data.child,
      displayAttributes: data.displayAttributes,
    },
    errors: {
      403: 'Operation not allowed. User needs to be able to edit the resource.',
    },
  });
};

/**
 * Reorder element
 * @param data The data for the request.
 * @param data.metadataUuid Record UUID.
 * @param data.ref Reference of the element to move.
 * @param data.direction Direction
 * @param data.displayAttributes Should attributes be shown on the editor snippet?
 * @returns unknown Element reordered.
 * @throws ApiError
 */
export const reorderElement = (
  data: ReorderElementData
): CancelablePromise<ReorderElementResponse> => {
  return __request(OpenAPI, {
    method: 'PUT',
    url: '/records/{metadataUuid}/editor/elements/{direction}',
    path: {
      metadataUuid: data.metadataUuid,
      direction: data.direction,
    },
    query: {
      ref: data.ref,
      displayAttributes: data.displayAttributes,
    },
    errors: {
      403: 'Operation not allowed. User needs to be able to edit the resource.',
    },
  });
};

/**
 * Get list of record extents
 * A rendering of the geometry as a png. If no background is specified the image will be transparent. In getMap the envelope of the geometry is calculated then it is expanded by a factor.  That factor is the size of the map.  This allows the map to be slightly bigger than the geometry allowing some context to be shown. This parameter allows different factors to be chosen per scale level.
 * Proportion is the proportion of the world that the geometry covers (bounds of WGS84)/(bounds of geometry in WGS84)
 *
 * Named backgrounds allow the background parameter to be a simple key and the complete URL will be looked up from this list of named backgrounds
 *
 * @param data The data for the request.
 * @param data.metadataUuid Record UUID.
 * @returns ExtentDto OK
 * @throws ApiError
 */
export const getAllRecordExtentAsJson = (
  data: GetAllRecordExtentAsJsonData
): CancelablePromise<GetAllRecordExtentAsJsonResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/records/{metadataUuid}/extents.json',
    path: {
      metadataUuid: data.metadataUuid,
    },
  });
};

/**
 * Get record extents as image
 * A rendering of the geometry as a png. If no background is specified the image will be transparent. In getMap the envelope of the geometry is calculated then it is expanded by a factor.  That factor is the size of the map.  This allows the map to be slightly bigger than the geometry allowing some context to be shown. This parameter allows different factors to be chosen per scale level.
 * Proportion is the proportion of the world that the geometry covers (bounds of WGS84)/(bounds of geometry in WGS84)
 *
 * Named backgrounds allow the background parameter to be a simple key and the complete URL will be looked up from this list of named backgrounds
 *
 * @param data The data for the request.
 * @param data.metadataUuid Record UUID.
 * @param data.mapsrs (optional) the background map projection. If not passed uses the region/getmap/mapproj setting. If the setting is not set defaults to EPSG:4326
 * @param data.width (optional) width of the image that is created. Only one of width and height are permitted
 * @param data.height (optional) height of the image that is created. Only one of width and height are permitted
 * @param data.background (optional) URL for loading a background image for regions or a key that references the namedBackgrounds (configured in config-spring-geonetwork.xml). A WMS GetMap request is the typical example. The URL must be parameterized with the following parameters: minx, maxx, miny, maxy, width, height
 * @param data.fillColor (optional) Fill color with format RED,GREEN,BLUE,ALPHA
 * @param data.strokeColor (optional) Stroke color with format RED,GREEN,BLUE,ALPHA
 * @returns string OK
 * @throws ApiError
 */
export const getAllRecordExtentAsImage = (
  data: GetAllRecordExtentAsImageData
): CancelablePromise<GetAllRecordExtentAsImageResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/records/{metadataUuid}/extents.png',
    path: {
      metadataUuid: data.metadataUuid,
    },
    query: {
      mapsrs: data.mapsrs,
      width: data.width,
      height: data.height,
      background: data.background,
      fillColor: data.fillColor,
      strokeColor: data.strokeColor,
    },
  });
};

/**
 * Get one record extent as image
 * A rendering of the geometry as a png. If no background is specified the image will be transparent. In getMap the envelope of the geometry is calculated then it is expanded by a factor.  That factor is the size of the map.  This allows the map to be slightly bigger than the geometry allowing some context to be shown. This parameter allows different factors to be chosen per scale level.
 * Proportion is the proportion of the world that the geometry covers (bounds of WGS84)/(bounds of geometry in WGS84)
 *
 * Named backgrounds allow the background parameter to be a simple key and the complete URL will be looked up from this list of named backgrounds
 *
 * @param data The data for the request.
 * @param data.metadataUuid Record UUID.
 * @param data.geometryIndex Index of the geometry or bounding box to display. Starts at 1.
 * @param data.mapsrs (optional) the background map projection. If not passed uses the region/getmap/mapproj setting. If the setting is not set defaults to EPSG:4326
 * @param data.width (optional) width of the image that is created. Only one of width and height are permitted
 * @param data.height (optional) height of the image that is created. Only one of width and height are permitted
 * @param data.background (optional) URL for loading a background image for regions or a key that references the namedBackgrounds (configured in config-spring-geonetwork.xml). A WMS GetMap request is the typical example. The URL must be parameterized with the following parameters: minx, maxx, miny, maxy, width, height
 * @param data.fillColor (optional) Fill color with format RED,GREEN,BLUE,ALPHA
 * @param data.strokeColor (optional) Stroke color with format RED,GREEN,BLUE,ALPHA
 * @returns string OK
 * @throws ApiError
 */
export const getOneRecordExtentAsImage = (
  data: GetOneRecordExtentAsImageData
): CancelablePromise<GetOneRecordExtentAsImageResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/records/{metadataUuid}/extents/{geometryIndex}.png',
    path: {
      metadataUuid: data.metadataUuid,
      geometryIndex: data.geometryIndex,
    },
    query: {
      mapsrs: data.mapsrs,
      width: data.width,
      height: data.height,
      background: data.background,
      fillColor: data.fillColor,
      strokeColor: data.strokeColor,
    },
  });
};

/**
 * Returns a map to decode attributes in a dataset (from the associated feature catalog)
 * @param data The data for the request.
 * @param data.metadataUuid Record UUID.
 * @param data.approved Use approved version or not
 * @returns FeatureResponse Return the associated resources.
 * @throws ApiError
 */
export const getFeatureCatalog = (
  data: GetFeatureCatalogData
): CancelablePromise<GetFeatureCatalogResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/records/{metadataUuid}/featureCatalog',
    path: {
      metadataUuid: data.metadataUuid,
    },
    query: {
      approved: data.approved,
    },
    errors: {
      403: 'Operation not allowed. User needs to be able to view the resource.',
    },
  });
};

/**
 * Get a metadata record as JSON
 * @param data The data for the request.
 * @param data.metadataUuid Record UUID.
 * @param data.addSchemaLocation Add XSD schema location based on standard configuration (see schema-ident.xml).
 * @param data.increasePopularity Increase record popularity
 * @param data.withInfo Add geonet:info details
 * @param data.attachment Download as a file
 * @param data.approved Download the approved version
 * @returns binary Return the record.
 * @throws ApiError
 */
export const getRecordAsJson = (
  data: GetRecordAsJsonData
): CancelablePromise<GetRecordAsJsonResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/records/{metadataUuid}/formatters/json',
    path: {
      metadataUuid: data.metadataUuid,
    },
    query: {
      addSchemaLocation: data.addSchemaLocation,
      increasePopularity: data.increasePopularity,
      withInfo: data.withInfo,
      attachment: data.attachment,
      approved: data.approved,
    },
    errors: {
      403: 'Operation not allowed. User needs to be able to view the resource.',
    },
  });
};

/**
 * Get a metadata record as XML
 * @param data The data for the request.
 * @param data.metadataUuid Record UUID.
 * @param data.addSchemaLocation Add XSD schema location based on standard configuration (see schema-ident.xml).
 * @param data.increasePopularity Increase record popularity
 * @param data.withInfo Add geonet:info details
 * @param data.attachment Download as a file
 * @param data.approved Download the approved version
 * @returns binary Return the record.
 * @throws ApiError
 */
export const getRecordAsXml = (
  data: GetRecordAsXmlData
): CancelablePromise<GetRecordAsXmlResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/records/{metadataUuid}/formatters/xml',
    path: {
      metadataUuid: data.metadataUuid,
    },
    query: {
      addSchemaLocation: data.addSchemaLocation,
      increasePopularity: data.increasePopularity,
      withInfo: data.withInfo,
      attachment: data.attachment,
      approved: data.approved,
    },
    errors: {
      403: 'Operation not allowed. User needs to be able to view the resource.',
    },
  });
};

/**
 * Get a metadata record as ZIP
 * Metadata Exchange Format (MEF) is returned. MEF is a ZIP file containing the metadata as XML and some others files depending on the version requested. See https://docs.geonetwork-opensource.org/latest/annexes/mef-format/.
 * @param data The data for the request.
 * @param data.metadataUuid Record UUID.
 * @param data.format MEF file format.
 * @param data.withRelated With related records (parent and service).
 * @param data.withXlinksResolved Resolve XLinks in the records.
 * @param data.withXlinkAttribute Preserve XLink URLs in the records.
 * @param data.addSchemaLocation
 * @param data.approved Download the approved version
 * @returns unknown Return the record.
 * @throws ApiError
 */
export const getRecordAsZip = (
  data: GetRecordAsZipData
): CancelablePromise<GetRecordAsZipResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/records/{metadataUuid}/formatters/zip',
    path: {
      metadataUuid: data.metadataUuid,
    },
    query: {
      format: data.format,
      withRelated: data.withRelated,
      withXLinksResolved: data.withXlinksResolved,
      withXLinkAttribute: data.withXlinkAttribute,
      addSchemaLocation: data.addSchemaLocation,
      approved: data.approved,
    },
    errors: {
      403: 'Operation not allowed. User needs to be able to view the resource.',
    },
  });
};

/**
 * Get a formatted metadata record
 * @param data The data for the request.
 * @param data.formatterId Formatter type to use.
 * @param data.metadataUuid Record UUID.
 * @param data.width
 * @param data.mdpath
 * @param data.language Optional language ISO 3 letters code to override HTTP Accept-language header.
 * @param data.output
 * @param data.approved Download the approved version
 * @returns unknown OK
 * @throws ApiError
 */
export const getRecordFormattedBy = (
  data: GetRecordFormattedByData
): CancelablePromise<GetRecordFormattedByResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/records/{metadataUuid}/formatters/{formatterId}',
    path: {
      formatterId: data.formatterId,
      metadataUuid: data.metadataUuid,
    },
    query: {
      width: data.width,
      mdpath: data.mdpath,
      language: data.language,
      output: data.output,
      approved: data.approved,
    },
  });
};

/**
 * Set record group
 * A record is related to one group.
 * @param data The data for the request.
 * @param data.metadataUuid Record UUID.
 * @param data.requestBody
 * @returns void Record group updated.
 * @throws ApiError
 */
export const setRecordGroup = (
  data: SetRecordGroupData
): CancelablePromise<SetRecordGroupResponse> => {
  return __request(OpenAPI, {
    method: 'PUT',
    url: '/records/{metadataUuid}/group',
    path: {
      metadataUuid: data.metadataUuid,
    },
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
      403: 'Operation not allowed. User needs to be able to edit the resource.',
    },
  });
};

/**
 * Set record group and owner
 * @param data The data for the request.
 * @param data.metadataUuid Record UUID.
 * @param data.groupIdentifier Group identifier
 * @param data.userIdentifier User identifier
 * @param data.approved Use approved version or not
 * @returns MetadataProcessingReport Record group and owner updated
 * @throws ApiError
 */
export const setRecordOwnership = (
  data: SetRecordOwnershipData
): CancelablePromise<SetRecordOwnershipResponse> => {
  return __request(OpenAPI, {
    method: 'PUT',
    url: '/records/{metadataUuid}/ownership',
    path: {
      metadataUuid: data.metadataUuid,
    },
    query: {
      groupIdentifier: data.groupIdentifier,
      userIdentifier: data.userIdentifier,
      approved: data.approved,
    },
    errors: {
      403: 'Operation not allowed. User needs to be able to edit the resource.',
    },
  });
};

/**
 * Get metadata record permalink
 * Permalink is by default the landing page formatter but can be configured in the admin console > settings. If the record as a DOI and if enabled in the settings, then it takes priority.
 * @param data The data for the request.
 * @param data.metadataUuid Record UUID.
 * @returns string Return the permalink URL.
 * @throws ApiError
 */
export const getRecordPermalink = (
  data: GetRecordPermalinkData
): CancelablePromise<GetRecordPermalinkResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/records/{metadataUuid}/permalink',
    path: {
      metadataUuid: data.metadataUuid,
    },
    errors: {
      403: 'Operation not allowed. User needs to be able to view the resource.',
      404: 'Resource not found.',
    },
  });
};

/**
 * Get record popularity
 * @param data The data for the request.
 * @param data.metadataUuid Record UUID.
 * @returns string Popularity.
 * @throws ApiError
 */
export const getRecordPopularity = (
  data: GetRecordPopularityData
): CancelablePromise<GetRecordPopularityResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/records/{metadataUuid}/popularity',
    path: {
      metadataUuid: data.metadataUuid,
    },
    errors: {
      403: 'Operation not allowed. User needs to be able to view the resource.',
      404: 'Resource not found.',
    },
  });
};

/**
 * Increase record popularity
 * Used when a view is based on the search results content and does not really access the record. Record is then added to the indexing queue and popularity will be updated soon.
 * @param data The data for the request.
 * @param data.metadataUuid Record UUID.
 * @returns string Popularity updated.
 * @throws ApiError
 */
export const increaseRecordPopularity = (
  data: IncreaseRecordPopularityData
): CancelablePromise<IncreaseRecordPopularityResponse> => {
  return __request(OpenAPI, {
    method: 'POST',
    url: '/records/{metadataUuid}/popularity',
    path: {
      metadataUuid: data.metadataUuid,
    },
    errors: {
      403: 'Operation not allowed. User needs to be able to view the resource.',
      404: 'Resource not found.',
    },
  });
};

/**
 * Get suggestions
 * Analyze the record an suggest processes to improve the quality of the record.<br/><a href='https://docs.geonetwork-opensource.org/latest/user-guide/workflow/batchupdate-xsl/'>More info</a>
 * @param data The data for the request.
 * @param data.metadataUuid Record UUID.
 * @returns SuggestionType Record suggestions.
 * @throws ApiError
 */
export const getSuggestions = (
  data: GetSuggestionsData
): CancelablePromise<GetSuggestionsResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/records/{metadataUuid}/processes',
    path: {
      metadataUuid: data.metadataUuid,
    },
    errors: {
      403: 'Operation not allowed. User needs to be able to edit the resource.',
    },
  });
};

/**
 * Preview process result
 * Process a metadata with an XSL transformation declared in the metadata schema (See the process folder). Parameters sent to the service are forwarded to XSL process.
 * @param data The data for the request.
 * @param data.metadataUuid Record UUID.
 * @param data.process Process identifier
 * @returns unknown A preview of the processed record.
 * @throws ApiError
 */
export const processRecordPreview = (
  data: ProcessRecordPreviewData
): CancelablePromise<ProcessRecordPreviewResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/records/{metadataUuid}/processes/{process}',
    path: {
      metadataUuid: data.metadataUuid,
      process: data.process,
    },
    errors: {
      403: 'Operation not allowed. User needs to be able to edit the resource.',
    },
  });
};

/**
 * Apply a process
 * Process a metadata with an XSL transformation declared in the metadata schema (See the process folder). Parameters sent to the service are forwarded to XSL process.
 * @param data The data for the request.
 * @param data.metadataUuid Record UUID.
 * @param data.process Process identifier
 * @returns string Record processed and saved.
 * @throws ApiError
 */
export const processRecord = (
  data: ProcessRecordData
): CancelablePromise<ProcessRecordResponse> => {
  return __request(OpenAPI, {
    method: 'POST',
    url: '/records/{metadataUuid}/processes/{process}',
    path: {
      metadataUuid: data.metadataUuid,
      process: data.process,
    },
    errors: {
      403: 'Operation not allowed. User needs to be able to edit the resource.',
    },
  });
};

/**
 * Set privileges for ALL group to publish the metadata for all users.
 * @param data The data for the request.
 * @param data.metadataUuid Record UUID.
 * @param data.publicationType Publication type
 * @returns void Settings updated.
 * @throws ApiError
 */
export const publish = (
  data: PublishData
): CancelablePromise<PublishResponse> => {
  return __request(OpenAPI, {
    method: 'PUT',
    url: '/records/{metadataUuid}/publish',
    path: {
      metadataUuid: data.metadataUuid,
    },
    query: {
      publicationType: data.publicationType,
    },
    errors: {
      403: 'Operation not allowed. User needs to be able to edit the resource.',
    },
  });
};

/**
 * List saved queries for this metadata
 * @param data The data for the request.
 * @param data.metadataUuid Record UUID.
 * @returns SavedQuery Saved query available.
 * @throws ApiError
 */
export const getSavedQueries = (
  data: GetSavedQueriesData
): CancelablePromise<GetSavedQueriesResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/records/{metadataUuid}/query',
    path: {
      metadataUuid: data.metadataUuid,
    },
    errors: {
      403: 'Operation not allowed. User needs to be able to view the resource.',
    },
  });
};

/**
 * Apply a saved query for this metadata
 * All parameters will be substituted to the XPath query. eg. {{protocol}} in the XPath expression will be replaced by the protocol parameter provided in the request body.
 * @param data The data for the request.
 * @param data.metadataUuid The metadata UUID
 * @param data.savedQuery The saved query to apply
 * @param data.requestBody
 * @returns string List of matching elements. If element are nodes, then they are returned as string.
 * @throws ApiError
 */
export const applyQuery = (
  data: ApplyQueryData
): CancelablePromise<ApplyQueryResponse> => {
  return __request(OpenAPI, {
    method: 'POST',
    url: '/records/{metadataUuid}/query/{savedQuery}',
    path: {
      metadataUuid: data.metadataUuid,
      savedQuery: data.savedQuery,
    },
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
      403: 'Operation not allowed. User needs to be able to view the resource.',
    },
  });
};

/**
 * Rate a record
 * User rating of metadata. If the metadata was harvested using the 'GeoNetwork' protocol and the system setting localrating/enable is false (the default), the user's rating is shared between GN nodes in this harvesting network. If the metadata was not harvested or if localrating/enable is true then 'local rating' is applied, counting only rating from users of this node.<br/>When a remote rating is applied, the local rating is not updated. It will be updated on the next harvest run (FIXME ?).
 * @param data The data for the request.
 * @param data.metadataUuid Record UUID.
 * @param data.requestBody
 * @returns number New rating value.
 * @throws ApiError
 */
export const rateRecord = (
  data: RateRecordData
): CancelablePromise<RateRecordResponse> => {
  return __request(OpenAPI, {
    method: 'PUT',
    url: '/records/{metadataUuid}/rate',
    path: {
      metadataUuid: data.metadataUuid,
    },
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
      403: 'Operation not allowed. User needs to be able to view the resource.',
    },
  });
};

/**
 * Get record related resources
 * Retrieve related services, datasets, onlines, thumbnails, sources, ... to this records.<br/><a href='https://geonetwork-opensource.org/manuals/trunk/eng/users/user-guide/associating-resources/index.html'>More info</a>
 * @param data The data for the request.
 * @param data.metadataUuid Record UUID.
 * @param data.type Type of related resource. If none, all resources are returned.
 * @param data.approved Use approved version or not
 * @param data.start Start offset for paging. Default 1. Only applies to related metadata records (ie. not for thumbnails).
 * @param data.rows Number of rows returned. Default 100.
 * @returns RelatedResponse Return the associated resources.
 * @throws ApiError
 */
export const getRelatedResources = (
  data: GetRelatedResourcesData
): CancelablePromise<GetRelatedResourcesResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/records/{metadataUuid}/related',
    path: {
      metadataUuid: data.metadataUuid,
    },
    query: {
      type: data.type,
      approved: data.approved,
      start: data.start,
      rows: data.rows,
    },
    errors: {
      403: 'Operation not allowed. User needs to be able to view the resource.',
    },
  });
};

/**
 * Get record sharing settings
 * Return current sharing options for a record.
 * @param data The data for the request.
 * @param data.metadataUuid Record UUID.
 * @returns SharingResponse The record sharing settings.
 * @throws ApiError
 */
export const getRecordSharingSettings = (
  data: GetRecordSharingSettingsData
): CancelablePromise<GetRecordSharingSettingsResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/records/{metadataUuid}/sharing',
    path: {
      metadataUuid: data.metadataUuid,
    },
    errors: {
      403: 'Operation not allowed. User needs to be able to view the resource.',
    },
  });
};

/**
 * Set record sharing
 * Privileges are assigned by group. User needs to be able to edit a record to set sharing settings. For reserved group (ie. Internet, Intranet & Guest), user MUST be reviewer of one group. For other group, if Only set privileges to user's groups is set in catalog configuration user MUST be a member of the group.<br/>Clear first allows to unset all operations first before setting the new ones.Clear option does not remove reserved groups operation if user is not an administrator, a reviewer or the owner of the record.<br/><a href='https://geonetwork-opensource.org/manuals/trunk/eng/users/user-guide/publishing/managing-privileges.html'>More info</a>
 * @param data The data for the request.
 * @param data.metadataUuid Record UUID.
 * @param data.requestBody
 * @returns void Settings updated.
 * @throws ApiError
 */
export const share = (data: ShareData): CancelablePromise<ShareResponse> => {
  return __request(OpenAPI, {
    method: 'PUT',
    url: '/records/{metadataUuid}/sharing',
    path: {
      metadataUuid: data.metadataUuid,
    },
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
      403: 'Operation not allowed. User needs to be able to edit the resource.',
    },
  });
};

/**
 * Delete all record status
 * @param data The data for the request.
 * @param data.metadataUuid Record UUID.
 * @returns void Status removed.
 * @throws ApiError
 */
export const deleteAllRecordStatus = (
  data: DeleteAllRecordStatusData
): CancelablePromise<DeleteAllRecordStatusResponse> => {
  return __request(OpenAPI, {
    method: 'DELETE',
    url: '/records/{metadataUuid}/status',
    path: {
      metadataUuid: data.metadataUuid,
    },
    errors: {
      403: 'Operation not allowed. Only Administrators can access it.',
      404: 'Status not found.',
    },
  });
};

/**
 * Get record status history
 * @param data The data for the request.
 * @param data.metadataUuid Record UUID.
 * @param data.details
 * @param data.sortOrder Sort direction
 * @returns MetadataStatusResponse OK
 * @throws ApiError
 */
export const getRecordStatusHistory = (
  data: GetRecordStatusHistoryData
): CancelablePromise<GetRecordStatusHistoryResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/records/{metadataUuid}/status',
    path: {
      metadataUuid: data.metadataUuid,
    },
    query: {
      details: data.details,
      sortOrder: data.sortOrder,
    },
  });
};

/**
 * Set the record status
 * @param data The data for the request.
 * @param data.metadataUuid Record UUID.
 * @param data.requestBody
 * @returns string Status updated.
 * @throws ApiError
 */
export const setStatus = (
  data: SetStatusData
): CancelablePromise<SetStatusResponse> => {
  return __request(OpenAPI, {
    method: 'PUT',
    url: '/records/{metadataUuid}/status',
    path: {
      metadataUuid: data.metadataUuid,
    },
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
      400: 'Metadata workflow not enabled.',
      403: 'Operation not allowed. User needs to be able to edit the resource.',
    },
  });
};

/**
 * Get last workflow status for a record
 * @param data The data for the request.
 * @param data.metadataUuid Record UUID.
 * @returns MetadataWorkflowStatusResponse Record status.
 * @throws ApiError
 */
export const getStatus = (
  data: GetStatusData
): CancelablePromise<GetStatusResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/records/{metadataUuid}/status/workflow/last',
    path: {
      metadataUuid: data.metadataUuid,
    },
    errors: {
      403: 'Operation not allowed. User needs to be able to edit the resource.',
    },
  });
};

/**
 * Delete a record status
 * @param data The data for the request.
 * @param data.metadataUuid Record UUID.
 * @param data.statusId Status identifier
 * @param data.userId User identifier
 * @param data.changeDate Change date
 * @returns void Status removed.
 * @throws ApiError
 */
export const deleteRecordStatus = (
  data: DeleteRecordStatusData
): CancelablePromise<DeleteRecordStatusResponse> => {
  return __request(OpenAPI, {
    method: 'DELETE',
    url: '/records/{metadataUuid}/status/{statusId}.{userId}.{changeDate}',
    path: {
      metadataUuid: data.metadataUuid,
      statusId: data.statusId,
      userId: data.userId,
      changeDate: data.changeDate,
    },
    errors: {
      403: 'Operation not allowed. Only Administrators can access it.',
      404: 'Status not found.',
    },
  });
};

/**
 * Get saved content from the status record after changes
 * @param data The data for the request.
 * @param data.metadataUuid Record UUID.
 * @param data.statusId Status identifier
 * @param data.userId User identifier
 * @param data.changeDate Change date
 * @returns string Version of the record after changes.
 * @throws ApiError
 */
export const showStatusAfter = (
  data: ShowStatusAfterData
): CancelablePromise<ShowStatusAfterResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/records/{metadataUuid}/status/{statusId}.{userId}.{changeDate}/after',
    path: {
      metadataUuid: data.metadataUuid,
      statusId: data.statusId,
      userId: data.userId,
      changeDate: data.changeDate,
    },
    errors: {
      403: 'Operation not allowed. User needs to be able to edit the resource.',
    },
  });
};

/**
 * Get saved content from the status record before changes
 * @param data The data for the request.
 * @param data.metadataUuid Record UUID.
 * @param data.statusId Status identifier
 * @param data.userId User identifier
 * @param data.changeDate Change date
 * @returns string Previous version of the record.
 * @throws ApiError
 */
export const showStatusBefore = (
  data: ShowStatusBeforeData
): CancelablePromise<ShowStatusBeforeResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/records/{metadataUuid}/status/{statusId}.{userId}.{changeDate}/before',
    path: {
      metadataUuid: data.metadataUuid,
      statusId: data.statusId,
      userId: data.userId,
      changeDate: data.changeDate,
    },
    errors: {
      403: 'Operation not allowed. User needs to be able to edit the resource.',
    },
  });
};

/**
 * Close a record task
 * @param data The data for the request.
 * @param data.metadataUuid Record UUID.
 * @param data.statusId Status identifier
 * @param data.userId User identifier
 * @param data.changeDate Change date
 * @param data.closeDate Close date
 * @returns void Task closed.
 * @throws ApiError
 */
export const closeTask = (
  data: CloseTaskData
): CancelablePromise<CloseTaskResponse> => {
  return __request(OpenAPI, {
    method: 'PUT',
    url: '/records/{metadataUuid}/status/{statusId}.{userId}.{changeDate}/close',
    path: {
      metadataUuid: data.metadataUuid,
      statusId: data.statusId,
      userId: data.userId,
      changeDate: data.changeDate,
    },
    query: {
      closeDate: data.closeDate,
    },
    errors: {
      403: 'Operation not allowed. User needs to be able to edit the resource.',
      404: 'Status not found.',
    },
  });
};

/**
 * Restore saved content from a status record
 * @param data The data for the request.
 * @param data.metadataUuid Record UUID.
 * @param data.statusId Status identifier
 * @param data.userId User identifier
 * @param data.changeDate Change date
 * @returns unknown Record restored.
 * @throws ApiError
 */
export const restoreAtStatusSave = (
  data: RestoreAtStatusSaveData
): CancelablePromise<RestoreAtStatusSaveResponse> => {
  return __request(OpenAPI, {
    method: 'POST',
    url: '/records/{metadataUuid}/status/{statusId}.{userId}.{changeDate}/restore',
    path: {
      metadataUuid: data.metadataUuid,
      statusId: data.statusId,
      userId: data.userId,
      changeDate: data.changeDate,
    },
    errors: {
      403: 'Operation not allowed. User needs to be able to edit the resource.',
    },
  });
};

/**
 * Get record status history by type
 * @param data The data for the request.
 * @param data.metadataUuid Record UUID.
 * @param data.type Type
 * @param data.details
 * @param data.sortOrder Sort direction
 * @returns MetadataStatusResponse OK
 * @throws ApiError
 */
export const getRecordStatusHistoryByType = (
  data: GetRecordStatusHistoryByTypeData
): CancelablePromise<GetRecordStatusHistoryByTypeResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/records/{metadataUuid}/status/{type}',
    path: {
      metadataUuid: data.metadataUuid,
      type: data.type,
    },
    query: {
      details: data.details,
      sortOrder: data.sortOrder,
    },
  });
};

/**
 * Delete tags of a record
 * @param data The data for the request.
 * @param data.metadataUuid Record UUID.
 * @param data.id Tag identifier. If none, all tags are removed.
 * @returns void Record tags removed.
 * @throws ApiError
 */
export const deleteTags = (
  data: DeleteTagsData
): CancelablePromise<DeleteTagsResponse> => {
  return __request(OpenAPI, {
    method: 'DELETE',
    url: '/records/{metadataUuid}/tags',
    path: {
      metadataUuid: data.metadataUuid,
    },
    query: {
      id: data.id,
    },
    errors: {
      403: 'Operation not allowed. User needs to be able to edit the resource.',
    },
  });
};

/**
 * Get record tags
 * Tags are used to classify information.<br/><a href='https://docs.geonetwork-opensource.org/latest/user-guide/tag-information/tagging-with-categories/'>More info</a>
 * @param data The data for the request.
 * @param data.metadataUuid Record UUID.
 * @returns MetadataCategory Record tags.
 * @throws ApiError
 */
export const getRecordTags = (
  data: GetRecordTagsData
): CancelablePromise<GetRecordTagsResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/records/{metadataUuid}/tags',
    path: {
      metadataUuid: data.metadataUuid,
    },
    errors: {
      403: 'Operation not allowed. User needs to be able to view the resource.',
    },
  });
};

/**
 * Add tags to a record
 * @param data The data for the request.
 * @param data.metadataUuid Record UUID.
 * @param data.id Tag identifier
 * @param data.clear Clear all before adding new ones
 * @returns unknown Record tags added.
 * @throws ApiError
 */
export const tagRecord = (
  data: TagRecordData
): CancelablePromise<TagRecordResponse> => {
  return __request(OpenAPI, {
    method: 'PUT',
    url: '/records/{metadataUuid}/tags',
    path: {
      metadataUuid: data.metadataUuid,
    },
    query: {
      id: data.id,
      clear: data.clear,
    },
    errors: {
      403: 'Operation not allowed. User needs to be able to edit the resource.',
    },
  });
};

/**
 * Unsets privileges for ALL group to publish the metadata for all users.
 * @param data The data for the request.
 * @param data.metadataUuid Record UUID.
 * @param data.publicationType Publication type
 * @returns void Settings updated.
 * @throws ApiError
 */
export const unpublish = (
  data: UnpublishData
): CancelablePromise<UnpublishResponse> => {
  return __request(OpenAPI, {
    method: 'PUT',
    url: '/records/{metadataUuid}/unpublish',
    path: {
      metadataUuid: data.metadataUuid,
    },
    query: {
      publicationType: data.publicationType,
    },
    errors: {
      403: 'Operation not allowed. User needs to be able to edit the resource.',
    },
  });
};

/**
 * Finds a list of user feedback for a specific records.
 *  This list will include also the draft user feedback if the client is logged as reviewer.
 * @param data The data for the request.
 * @param data.metadataUuid Metadata record UUID.
 * @param data.size Maximum number of feedback to return.
 * @returns UserFeedbackDTO OK
 * @throws ApiError
 */
export const getUserCommentsOnArecord = (
  data: GetUserCommentsOnArecordData
): CancelablePromise<GetUserCommentsOnArecordResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/records/{metadataUuid}/userfeedback',
    path: {
      metadataUuid: data.metadataUuid,
    },
    query: {
      size: data.size,
    },
  });
};

/**
 * Provides an average rating for a metadata record
 * @param data The data for the request.
 * @param data.metadataUuid Metadata record UUID.
 * @returns RatingAverage OK
 * @throws ApiError
 */
export const getMetadataRating = (
  data: GetMetadataRatingData
): CancelablePromise<GetMetadataRatingResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/records/{metadataUuid}/userfeedbackrating',
    path: {
      metadataUuid: data.metadataUuid,
    },
  });
};

/**
 * Submit a record to the INSPIRE service for validation.
 * User MUST be able to edit the record to validate it. An INSPIRE endpoint must be configured in Settings. This activates an asyncronous process, this method does not return any report. This method returns an id to be used to get the report.
 * @param data The data for the request.
 * @param data.metadataUuid Record UUID.
 * @param data.testsuite Test suite to run
 * @param data.mode Define the encoding of the record to use. By default, ISO19139 are used as is and ISO19115-3 are converted to ISO19139.If mode = csw, a GetRecordById request is used.If mode = any portal id, then a GetRecordById request is used on this portal CSW entry point which may define custom CSW post processing. See https://github.com/geonetwork/core-geonetwork/pull/4493.
 * @returns string Check status of the report.
 * @throws ApiError
 */
export const validateRecordForInspire = (
  data: ValidateRecordForInspireData
): CancelablePromise<ValidateRecordForInspireResponse> => {
  return __request(OpenAPI, {
    method: 'PUT',
    url: '/records/{metadataUuid}/validate/inspire',
    path: {
      metadataUuid: data.metadataUuid,
    },
    query: {
      testsuite: data.testsuite,
      mode: data.mode,
    },
    errors: {
      403: 'Operation not allowed. User needs to be able to edit the resource.',
      404: 'Metadata not found.',
      500: 'Service unavailable.',
    },
  });
};

/**
 * Get test suites available.
 * TG13, TG2, ...
 * @param data The data for the request.
 * @param data.metadataUuid Record UUID.
 * @returns string List of testsuites available.
 * @throws ApiError
 */
export const getTestSuites = (
  data: GetTestSuitesData
): CancelablePromise<GetTestSuitesResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/records/{metadataUuid}/validate/inspire/testsuites',
    path: {
      metadataUuid: data.metadataUuid,
    },
    errors: {
      403: 'Operation not allowed. User needs to be able to edit the resource.',
    },
  });
};

/**
 * Validate a record
 * User MUST be able to edit the record to validate it. FIXME : id MUST be the id of the current metadata record in session ?
 * @param data The data for the request.
 * @param data.metadataUuid Record UUID.
 * @param data.isvalid Validation status. Should be provided only in case of SUBTEMPLATE validation. If provided for another type, throw a BadParameter Exception
 * @returns Reports Validation report.
 * @throws ApiError
 */
export const validateRecord = (
  data: ValidateRecordData
): CancelablePromise<ValidateRecordResponse> => {
  return __request(OpenAPI, {
    method: 'PUT',
    url: '/records/{metadataUuid}/validate/internal',
    path: {
      metadataUuid: data.metadataUuid,
    },
    query: {
      isvalid: data.isvalid,
    },
    errors: {
      403: 'Operation not allowed. User needs to be able to edit the resource.',
    },
  });
};

/**
 * (Experimental) Enable version control
 * @param data The data for the request.
 * @param data.metadataUuid Record UUID.
 * @returns string OK
 * @throws ApiError
 */
export const enableVersionControl = (
  data: EnableVersionControlData
): CancelablePromise<EnableVersionControlResponse> => {
  return __request(OpenAPI, {
    method: 'PUT',
    url: '/records/{metadataUuid}/versions',
    path: {
      metadataUuid: data.metadataUuid,
    },
  });
};

/**
 * Check the status of validation with the INSPIRE service.
 * User MUST be able to edit the record to validate it. An INSPIRE endpoint must be configured in Settings. If the process is complete an object with status is returned.
 * @param data The data for the request.
 * @param data.testId Test identifier
 * @returns string Report ready.
 * @throws ApiError
 */
export const checkValidation = (
  data: CheckValidationData
): CancelablePromise<CheckValidationResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/records/{testId}/validate/inspire',
    path: {
      testId: data.testId,
    },
    errors: {
      403: 'Operation not allowed. User needs to be able to edit the resource.',
      404: 'Report id not found.',
    },
  });
};

/**
 * Get list of regions
 * @param data The data for the request.
 * @param data.label
 * @param data.categoryId
 * @param data.maxRecords
 * @returns ListRegionsResponse List of regions.
 * @throws ApiError
 */
export const getRegions = (
  data: GetRegionsData = {}
): CancelablePromise<GetRegionsResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/regions',
    query: {
      label: data.label,
      categoryId: data.categoryId,
      maxRecords: data.maxRecords,
    },
  });
};

/**
 * Get geometry as image
 * A rendering of the geometry as a png.
 * @param data The data for the request.
 * @param data.mapsrs (optional) the background map projection. If not passed uses the region/getmap/mapproj setting. If the setting is not set defaults to EPSG:4326
 * @param data.width (optional) width of the image that is created. Only one of width and height are permitted
 * @param data.height (optional) height of the image that is created. Only one of width and height are permitted
 * @param data.background (optional) URL for loading a background image for regions or a key that references the namedBackgrounds (configured in config-spring-geonetwork.xml). A WMS Getmap request is the typical example. The URL must be parameterized with the following parameters: minx, maxx, miny, maxy, width, height
 * @param data.geom (optional) a wkt or gml encoded geometry.
 * @param data.geomtype (optional) defines if geom is wkt or gml. Allowed values are wkt and gml. if not specified the it is assumed the geometry is wkt
 * @param data.geomsrs
 * @param data.fillColor (optional) Fill color with format RED,GREEN,BLUE,ALPHA
 * @param data.strokeColor (optional) Stroke color with format RED,GREEN,BLUE,ALPHA
 * @returns string OK
 * @throws ApiError
 */
export const getGeomAsImage = (
  data: GetGeomAsImageData = {}
): CancelablePromise<GetGeomAsImageResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/regions/geom.png',
    query: {
      mapsrs: data.mapsrs,
      width: data.width,
      height: data.height,
      background: data.background,
      geom: data.geom,
      geomtype: data.geomtype,
      geomsrs: data.geomsrs,
      fillColor: data.fillColor,
      strokeColor: data.strokeColor,
    },
  });
};

/**
 * Get list of region types
 * @returns Category List of region types.
 * @throws ApiError
 */
export const getRegionTypes = (): CancelablePromise<GetRegionTypesResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/regions/types',
  });
};

/**
 * Preview directory entries extracted from records
 * Scan one or more records for element matching the XPath provided and save them as directory entries (ie. subtemplate).<br/><br/>Only records that the current user can edit are analyzed.<br/><br/>Examples:<br/>For ISO19115-3 records, use .//cit:CI_Responsibility and compute identifier based on email with .//cit:electronicMailAddress*text() to create a contact directory.
 * @param data The data for the request.
 * @param data.xpath XPath of the elements to extract as entry.
 * @param data.uuids Record UUIDs. If null current selection is used.
 * @param data.bucket Selection bucket name
 * @param data.identifierXpath XPath of the element identifier. If not defined a random UUID is generated and analysis will not check for duplicates.
 * @returns unknown OK
 * @throws ApiError
 */
export const previewExtractedEntries = (
  data: PreviewExtractedEntriesData
): CancelablePromise<PreviewExtractedEntriesResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/registries/actions/entries/collect',
    query: {
      uuids: data.uuids,
      bucket: data.bucket,
      xpath: data.xpath,
      identifierXpath: data.identifierXpath,
    },
  });
};

/**
 * Extracts directory entries from records
 * Scan one or more records for element matching the XPath provided and save them as directory entries (ie. subtemplate).<br/><br/>Only records that the current user can edit are analyzed.<br/><br/>Examples:<br/>For ISO19115-3 records, use .//cit:CI_Responsibility and compute identifier based on email with .//cit:electronicMailAddress*text() to create a contact directory.
 * @param data The data for the request.
 * @param data.xpath XPath of the elements to extract as entry.
 * @param data.uuids Record UUIDs. If null current selection is used.
 * @param data.bucket Selection bucket name
 * @param data.identifierXpath XPath of the element identifier. If not defined a random UUID is generated and analysis will not check for duplicates.
 * @returns unknown OK
 * @throws ApiError
 */
export const extractEntries = (
  data: ExtractEntriesData
): CancelablePromise<ExtractEntriesResponse> => {
  return __request(OpenAPI, {
    method: 'PUT',
    url: '/registries/actions/entries/collect',
    query: {
      uuids: data.uuids,
      bucket: data.bucket,
      xpath: data.xpath,
      identifierXpath: data.identifierXpath,
    },
  });
};

/**
 * Import spatial directory entries
 * Directory entry (AKA subtemplates) are XML fragments that can be inserted in metadata records. Use this service to import geographic extent entries from an ESRI Shapefile format.
 * @param data The data for the request.
 * @param data.uuidAttribute Attribute to use for UUID. If none, random UUID are generated.
 * @param data.uuidPattern Pattern to build UUID from. Default is '{{uuid}}'.
 * @param data.descriptionAttribute Attribute to use for extent description. If none, no extent description defined. TODO: Add per language desc ?
 * @param data.geomProjectionTo geomProjectionTo
 * @param data.lenient lenient
 * @param data.charset Attribute table charset
 * @param data.onlyBoundingBox Create only bounding box for each spatial objects.
 * @param data.process Process
 * @param data.schema Schema identifier
 * @param data.uuidProcessing Record identifier processing.
 * @param data.group The group the record is attached to.
 * @param data.formData
 * @returns SimpleMetadataProcessingReport Directory entries imported.
 * @throws ApiError
 */
export const importSpatialEntries = (
  data: ImportSpatialEntriesData = {}
): CancelablePromise<ImportSpatialEntriesResponse> => {
  return __request(OpenAPI, {
    method: 'POST',
    url: '/registries/actions/entries/import/spatial',
    query: {
      uuidAttribute: data.uuidAttribute,
      uuidPattern: data.uuidPattern,
      descriptionAttribute: data.descriptionAttribute,
      geomProjectionTo: data.geomProjectionTo,
      lenient: data.lenient,
      charset: data.charset,
      onlyBoundingBox: data.onlyBoundingBox,
      process: data.process,
      schema: data.schema,
      uuidProcessing: data.uuidProcessing,
      group: data.group,
    },
    formData: data.formData,
    mediaType: 'multipart/form-data',
    errors: {
      403: 'Operation not allowed. Only Reviewvers can access it.',
    },
  });
};

/**
 * Preview updated matching entries in records
 * Scan one or more records for element matching the XPath provided and then check if this element is available in the directory. If Found, the element from the directory update the element in the record and optionally text or attribute value properties are preserved using propertiesToCopy. Elements can be lost if not existing in the directory entry (eg. from an gex:Extent directory containing only description and bounding polygon, the update can remove temporal element).<br/><br/>The identifier XPath is used to find a match. An optional filtercan be added to restrict search to a subset of the directory. If no identifier XPaths is provided, the UUID is based on the content of the snippet (hash). It is recommended to use an identifier for better matching (eg. ISO19139 contact with different roles will not match on the automatic UUID mode).
 * @param data The data for the request.
 * @param data.xpath XPath of the elements to extract as entry.
 * @param data.uuids Record UUIDs. If null current selection is used.
 * @param data.bucket Selection bucket name
 * @param data.identifierXpath XPath of the element identifier. If not defined a random UUID is generated and analysis will not check for duplicates.
 * @param data.propertiesToCopy List of XPath of properties to copy from record to matching entry. Only support text or attribute eg. ./gmd:role*@codeListValue
 * @param data.substituteAsXlink Replace entry by XLink.
 * @param data.fq Filter query for directory search.
 * @returns unknown OK
 * @throws ApiError
 */
export const previewUpdatedRecordEntries = (
  data: PreviewUpdatedRecordEntriesData
): CancelablePromise<PreviewUpdatedRecordEntriesResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/registries/actions/entries/synchronize',
    query: {
      uuids: data.uuids,
      bucket: data.bucket,
      xpath: data.xpath,
      identifierXpath: data.identifierXpath,
      propertiesToCopy: data.propertiesToCopy,
      substituteAsXLink: data.substituteAsXlink,
      fq: data.fq,
    },
  });
};

/**
 * Update matching entries in records
 * Scan one or more records for element matching the XPath provided and then check if this element is available in the directory. If Found, the element from the directory update the element in the record and optionally text or attribute value properties are preserved using propertiesToCopy. Elements can be lost if not existing in the directory entry (eg. from an gex:Extent directory containing only description and bounding polygon, the update can remove temporal element).<br/><br/>The identifier XPath is used to find a match. An optional filtercan be added to restrict search to a subset of the directory. If no identifier XPaths is provided, the UUID is based on the content of the snippet (hash). It is recommended to use an identifier for better matching (eg. ISO19139 contact with different roles will not match on the automatic UUID mode).
 * @param data The data for the request.
 * @param data.xpath XPath of the elements to extract as entry.
 * @param data.uuids Record UUIDs. If null current selection is used.
 * @param data.bucket Selection bucket name
 * @param data.identifierXpath XPath of the element identifier. If not defined a random UUID is generated and analysis will not check for duplicates.
 * @param data.propertiesToCopy List of XPath of properties to copy from record to matching entry. Only support text or attribute eg. ./gmd:role*@codeListValue
 * @param data.substituteAsXlink Replace entry by XLink.
 * @param data.fq Filter query for directory search.
 * @returns unknown Created
 * @throws ApiError
 */
export const updateRecordEntries = (
  data: UpdateRecordEntriesData
): CancelablePromise<UpdateRecordEntriesResponse> => {
  return __request(OpenAPI, {
    method: 'PUT',
    url: '/registries/actions/entries/synchronize',
    query: {
      uuids: data.uuids,
      bucket: data.bucket,
      xpath: data.xpath,
      identifierXpath: data.identifierXpath,
      propertiesToCopy: data.propertiesToCopy,
      substituteAsXLink: data.substituteAsXlink,
      fq: data.fq,
    },
  });
};

/**
 * Search coordinate reference system (CRS)
 * Based on GeoTools EPSG database. If phrase query, each words are searched separately.
 * @param data The data for the request.
 * @param data.q Search value
 * @param data.type Type of CRS
 * @param data.rows Number of results. Default is: 100
 * @returns Crs List of CRS.
 * @throws ApiError
 */
export const searchCrs = (
  data: SearchCrsData = {}
): CancelablePromise<SearchCrsResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/registries/crs',
    query: {
      q: data.q,
      type: data.type,
      rows: data.rows,
    },
  });
};

/**
 * Get list of CRS type
 * @returns string List of CRS types.
 * @throws ApiError
 */
export const getCrsTypes = (): CancelablePromise<GetCrsTypesResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/registries/crs/types',
  });
};

/**
 * Get CRS
 * @param data The data for the request.
 * @param data.id CRS identifier
 * @returns Crs CRS details.
 * @throws ApiError
 */
export const getCrs = (data: GetCrsData): CancelablePromise<GetCrsResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/registries/crs/{id}',
    path: {
      id: data.id,
    },
    errors: {
      404: 'CRS not found.',
    },
  });
};

/**
 * Get a directory entry
 * Directory entry (AKA subtemplates) are XML fragments that can be inserted in metadata records using XLinks. XLinks can be remote or local.
 * @param data The data for the request.
 * @param data.uuid Directory entry UUID.
 * @param data.process Process
 * @param data.transformation Transformation
 * @param data.lang lang
 * @param data.schema schema
 * @returns unknown Directory entry.
 * @throws ApiError
 */
export const getEntry = (
  data: GetEntryData
): CancelablePromise<GetEntryResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/registries/entries/{uuid}',
    path: {
      uuid: data.uuid,
    },
    query: {
      process: data.process,
      transformation: data.transformation,
      lang: data.lang,
      schema: data.schema,
    },
    errors: {
      403: 'Operation not allowed. User needs to be able to view the resource.',
    },
  });
};

/**
 * Uploads a new thesaurus from a file
 * Supported thesaurus are RDF/XML files using SKOS specification, OWL file describing NamedIndividual elements or SDMX file describing Codelist element. For RDF, extension must be .rdf or .xml, for OWL, .owl and for SDMX, .sdmx.
 * @param data The data for the request.
 * @param data.type Local or external (default).
 * @param data.dir Type of thesaurus, usually one of the ISO thesaurus type codelist value. Default is theme.
 * @param data.stylesheet XSL to be use to convert the thesaurus before load. Default _none_.
 * @param data.requestBody
 * @returns string Thesaurus uploaded in SKOS format.
 * @throws ApiError
 */
export const uploadThesaurus = (
  data: UploadThesaurusData = {}
): CancelablePromise<UploadThesaurusResponse> => {
  return __request(OpenAPI, {
    method: 'POST',
    url: '/registries/vocabularies',
    query: {
      type: data.type,
      dir: data.dir,
      stylesheet: data.stylesheet,
    },
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
      403: 'Operation not allowed. Only Reviewvers can access it.',
    },
  });
};

/**
 * Uploads a new thesaurus from URL or Registry
 * Uploads a new thesaurus.
 * @param data The data for the request.
 * @param data.url If set, try to download from the Internet.
 * @param data.registryUrl If set, try to download from a registry.
 * @param data.registryType If using registryUrl, then define the type of registry. If not set, default mode is re3gistry.
 * @param data.registryLanguage Languages to download from a registry.
 * @param data.type Local or external (default).
 * @param data.dir Type of thesaurus, usually one of the ISO thesaurus type codelist value. Default is theme.
 * @param data.stylesheet XSL to be use to convert the thesaurus before load. Default _none_.
 * @param data.requestBody
 * @returns string Thesaurus uploaded in SKOS format.
 * @throws ApiError
 */
export const uploadThesaurusFromUrl = (
  data: UploadThesaurusFromUrlData = {}
): CancelablePromise<UploadThesaurusFromUrlResponse> => {
  return __request(OpenAPI, {
    method: 'PUT',
    url: '/registries/vocabularies',
    query: {
      url: data.url,
      registryUrl: data.registryUrl,
      registryType: data.registryType,
      registryLanguage: data.registryLanguage,
      type: data.type,
      dir: data.dir,
      stylesheet: data.stylesheet,
    },
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
      403: 'Operation not allowed. Only Reviewvers can access it.',
    },
  });
};

/**
 * Uploads a CSV file and convert it to SKOS format
 * CSV file MUST contains columns at least for concept id and label. For multilingual thesaurus, consider using columns like label, label_fre, label_ita with languages parameter set to [en, fr, it]. Default language value is used if translations are empty. The thesaurus filename will be the filename of the CSV file (with .rdf extension). It is recommended to set the thesaurus title and namespace URL even if default values will be used based on the filename. Thesaurus dates are set to the date of import.
 * @param data The data for the request.
 * @param data.type Local or external (default).
 * @param data.dir Type of thesaurus, usually one of the ISO thesaurus type codelist value. Default is theme.
 * @param data.encoding Encoding. Default is UTF-8.
 * @param data.thesaurusNs Thesaurus namespace. Default is filename.
 * @param data.languages Thesaurus languages
 * @param data.thesaurusTitle Thesaurus title. Default is filename.
 * @param data.conceptIdColumn Column name for concept id. Default is id.
 * @param data.conceptLabelColumn Column name for concept label. Default is label.
 * @param data.conceptDescriptionColumn Column name for concept description. Default is description.
 * @param data.conceptBroaderIdColumn Column name for broader concept id. Default is broader.
 * @param data.conceptNarrowerIdColumn Column name for narrower concept id. Default is narrower.
 * @param data.conceptRelatedIdColumn Column name for related concept id. Default is related.
 * @param data.conceptLinkSeparator Separator used when multiple broader/narrower/related ids are in the same column. Default is '|'.
 * @param data.importAsThesaurus Import CSV file as thesaurus if true (detault) or return it in  SKOS format.
 * @param data.requestBody
 * @returns unknown Thesaurus converted and returned in response in SKOS format.
 * @throws ApiError
 */
export const importCsvAsThesaurus = (
  data: ImportCsvAsThesaurusData = {}
): CancelablePromise<ImportCsvAsThesaurusResponse> => {
  return __request(OpenAPI, {
    method: 'POST',
    url: '/registries/vocabularies/import/csv',
    query: {
      type: data.type,
      dir: data.dir,
      encoding: data.encoding,
      thesaurusNs: data.thesaurusNs,
      languages: data.languages,
      thesaurusTitle: data.thesaurusTitle,
      conceptIdColumn: data.conceptIdColumn,
      conceptLabelColumn: data.conceptLabelColumn,
      conceptDescriptionColumn: data.conceptDescriptionColumn,
      conceptBroaderIdColumn: data.conceptBroaderIdColumn,
      conceptNarrowerIdColumn: data.conceptNarrowerIdColumn,
      conceptRelatedIdColumn: data.conceptRelatedIdColumn,
      conceptLinkSeparator: data.conceptLinkSeparator,
      importAsThesaurus: data.importAsThesaurus,
    },
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
      403: 'Operation not allowed. Only Reviewvers can access it.',
    },
  });
};

/**
 * Get keyword by id
 * Retrieve XML representation of keyword(s) from same thesaurususing different transformations. 'to-iso19139-keyword' is the default and return an ISO19139 snippet.'to-iso19139-keyword-as-xlink' return an XLinked element. Custom transformation can be create on a per schema basis.
 * @param data The data for the request.
 * @param data.id Keyword identifier or list of keyword identifiers comma separated.
 * @param data.thesaurus Thesaurus to look info for the keyword(s).
 * @param data.lang Languages.
 * @param data.keywordOnly Only print the keyword, no thesaurus information.
 * @param data.transformation XSL template to use (ISO19139 keyword by default, see convert.xsl).
 * @param data.langMap langMap, that converts the values in the 'lang' parameter to how they will be actually represented in the record. {'fre':'fra'} or {'fre':'fr'}.  Missing/empty means to convert to iso 2 letter.
 * @returns unknown XML snippet with requested keywords.
 * @throws ApiError
 */
export const getKeywordById = (
  data: GetKeywordByIdData
): CancelablePromise<GetKeywordByIdResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/registries/vocabularies/keyword',
    query: {
      id: data.id,
      thesaurus: data.thesaurus,
      lang: data.lang,
      keywordOnly: data.keywordOnly,
      transformation: data.transformation,
      langMap: data.langMap,
    },
  });
};

/**
 * Get keyword by ids
 * Retrieve XML representation of keyword(s) from same thesaurususing different transformations. 'to-iso19139-keyword' is the default and return an ISO19139 snippet.'to-iso19139-keyword-as-xlink' return an XLinked element. Custom transformation can be create on a per schema basis.This can be used instead of the GET method for cases where you need to submit large parameters list
 * @param data The data for the request.
 * @param data.id Keyword identifier or list of keyword identifiers comma separated.
 * @param data.thesaurus Thesaurus to look info for the keyword(s).
 * @param data.lang Languages.
 * @param data.keywordOnly Only print the keyword, no thesaurus information.
 * @param data.transformation XSL template to use (ISO19139 keyword by default, see convert.xsl).
 * @param data.langMap langMap, that converts the values in the 'lang' parameter to how they will be actually represented in the record. {'fre':'fra'} or {'fre':'fr'}.  Missing/empty means to convert to iso 2 letter.
 * @returns unknown XML snippet with requested keywords.
 * @throws ApiError
 */
export const getKeywordByIds = (
  data: GetKeywordByIdsData
): CancelablePromise<GetKeywordByIdsResponse> => {
  return __request(OpenAPI, {
    method: 'POST',
    url: '/registries/vocabularies/keyword',
    query: {
      id: data.id,
      thesaurus: data.thesaurus,
      lang: data.lang,
      keywordOnly: data.keywordOnly,
      transformation: data.transformation,
      langMap: data.langMap,
    },
  });
};

/**
 * Search keywords
 * @param data The data for the request.
 * @param data.q Query
 * @param data.lang Query in that language
 * @param data.rows Number of rows
 * @param data.start Start from
 * @param data.pLang Return keyword information in one or more languages
 * @param data.thesaurus Thesaurus identifier
 * @param data.type Type of search
 * @param data.uri URI query
 * @param data.sort Sort by
 * @returns unknown OK
 * @throws ApiError
 */
export const searchKeywords = (
  data: SearchKeywordsData = {}
): CancelablePromise<SearchKeywordsResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/registries/vocabularies/search',
    query: {
      q: data.q,
      lang: data.lang,
      rows: data.rows,
      start: data.start,
      pLang: data.pLang,
      thesaurus: data.thesaurus,
      type: data.type,
      uri: data.uri,
      sort: data.sort,
    },
  });
};

/**
 * Delete a thesaurus by name
 * Delete a thesaurus.
 * @param data The data for the request.
 * @param data.thesaurus Thesaurus to delete.
 * @returns unknown Thesaurus deleted.
 * @throws ApiError
 */
export const deleteThesaurus = (
  data: DeleteThesaurusData
): CancelablePromise<DeleteThesaurusResponse> => {
  return __request(OpenAPI, {
    method: 'DELETE',
    url: '/registries/vocabularies/{thesaurus}',
    path: {
      thesaurus: data.thesaurus,
    },
    errors: {
      403: 'Operation not allowed. Only UserAdmins can access it.',
      404: 'Resource not found.',
    },
  });
};

/**
 * Download a thesaurus by name
 * Download the thesaurus in SKOS format.
 * @param data The data for the request.
 * @param data.thesaurus Thesaurus to download.
 * @returns binary Thesaurus in SKOS format.
 * @throws ApiError
 */
export const getThesaurus = (
  data: GetThesaurusData
): CancelablePromise<GetThesaurusResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/registries/vocabularies/{thesaurus}',
    path: {
      thesaurus: data.thesaurus,
    },
    errors: {
      404: 'Resource not found.',
    },
  });
};

/**
 * Updates the information of a local thesaurus
 * Updates the information of a local thesaurus.
 * @param data The data for the request.
 * @param data.thesaurus Thesaurus to update.
 * @param data.requestBody
 * @returns unknown OK
 * @throws ApiError
 */
export const updateThesaurus = (
  data: UpdateThesaurusData
): CancelablePromise<UpdateThesaurusResponse> => {
  return __request(OpenAPI, {
    method: 'PUT',
    url: '/registries/vocabularies/{thesaurus}',
    path: {
      thesaurus: data.thesaurus,
    },
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
      403: 'Operation not allowed. Only Administrators can access it.',
    },
  });
};

/**
 * Get record related resources for all requested metadatas
 * Retrieve related services, datasets, onlines, thumbnails, sources, ... to all requested records.<br/><a href='https://geonetwork-opensource.org/manuals/trunk/eng/users/user-guide/associating-resources/index.html'>More info</a>
 * @param data The data for the request.
 * @param data.type Type of related resource. If none, all resources are returned.
 * @param data.uuid Uuids of the metadatas you request the relations from.
 * @param data.approved Use approved version or not
 * @returns RelatedResponse Return the associated resources.
 * @throws ApiError
 */
export const getAssociatedResourcesForRecords = (
  data: GetAssociatedResourcesForRecordsData = {}
): CancelablePromise<GetAssociatedResourcesForRecordsResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/related',
    query: {
      type: data.type,
      uuid: data.uuid,
      approved: data.approved,
    },
    errors: {
      403: 'Operation not allowed. User needs to be able to view the resource.',
    },
  });
};

/**
 * Get list of metadata file downloads
 * @param data The data for the request.
 * @param data.dateFrom From date of the metadata downloads
 * @param data.dateTo To date of the metadata downloads
 * @param data.groups Metadata group(s)
 * @returns unknown List of metadata file downloads.
 * @throws ApiError
 */
export const getReportDataDownloads = (
  data: GetReportDataDownloadsData
): CancelablePromise<GetReportDataDownloadsResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/reports/datadownloads',
    query: {
      dateFrom: data.dateFrom,
      dateTo: data.dateTo,
      groups: data.groups,
    },
  });
};

/**
 * Get uploaded files to metadata records during a period.
 * @param data The data for the request.
 * @param data.dateFrom From date of the metadata uploads
 * @param data.dateTo To date of the metadata uploads
 * @param data.groups Metadata group(s)
 * @returns unknown OK
 * @throws ApiError
 */
export const getReportDataUploads = (
  data: GetReportDataUploadsData
): CancelablePromise<GetReportDataUploadsResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/reports/datauploads',
    query: {
      dateFrom: data.dateFrom,
      dateTo: data.dateTo,
      groups: data.groups,
    },
  });
};

/**
 * Get the metadata not published during a period.
 * @param data The data for the request.
 * @param data.dateFrom From date of metadata change date
 * @param data.dateTo To date of metadata change date
 * @param data.groups Metadata group(s)
 * @returns unknown Metadata not published during a period.
 * @throws ApiError
 */
export const getReportInternalMetadata = (
  data: GetReportInternalMetadataData
): CancelablePromise<GetReportInternalMetadataResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/reports/metadatainternal',
    query: {
      dateFrom: data.dateFrom,
      dateTo: data.dateTo,
      groups: data.groups,
    },
  });
};

/**
 * Get the updated metadata during a period.
 * @param data The data for the request.
 * @param data.dateFrom From date of metadata change date
 * @param data.dateTo To date of metadata change date
 * @param data.groups Metadata group(s)
 * @returns unknown Updated metadata during a period.
 * @throws ApiError
 */
export const getReportUpdatedMetadata = (
  data: GetReportUpdatedMetadataData
): CancelablePromise<GetReportUpdatedMetadataResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/reports/metadataupdated',
    query: {
      dateFrom: data.dateFrom,
      dateTo: data.dateTo,
      groups: data.groups,
    },
  });
};

/**
 * Get the list of users "active" during a time period.
 * @param data The data for the request.
 * @param data.dateFrom From date of users login date
 * @param data.dateTo To date of users login date
 * @param data.groups Group(s) for the users
 * @returns unknown List of users "active" during a time period.
 * @throws ApiError
 */
export const getActiveUsers = (
  data: GetActiveUsersData
): CancelablePromise<GetActiveUsersResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/reports/users',
    query: {
      dateFrom: data.dateFrom,
      dateTo: data.dateTo,
      groups: data.groups,
    },
  });
};

/**
 * robots.txt
 * @returns unknown robots.txt file for SEO.
 * @throws ApiError
 */
export const getRobotsText = (): CancelablePromise<GetRobotsTextResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/robots.txt',
  });
};

/**
 * Executes several searches with a Elasticsearch API request.
 * The multi search API executes several searches from a single API request. See https://www.elastic.co/guide/en/elasticsearch/reference/current/search-multi-search.html for search parameters, and https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html Query DSL.
 * @param data The data for the request.
 * @param data.requestBody JSON request based on Elasticsearch API.
 * @param data.bucket
 * @param data.relatedType Type of related resource. If none, no associated resource returned.
 * @returns string Search results.
 * @throws ApiError
 */
export const msearch = (
  data: MsearchData
): CancelablePromise<MsearchResponse> => {
  return __request(OpenAPI, {
    method: 'POST',
    url: '/search/records/_msearch',
    query: {
      bucket: data.bucket,
      relatedType: data.relatedType,
    },
    body: data.requestBody,
    mediaType: 'application/json',
  });
};

/**
 * Execute a search query and get back search hits that match the query.
 * The search API execute a search query with a JSON request body. For more information see https://www.elastic.co/guide/en/elasticsearch/reference/current/search-search.html for search parameters, and https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html JSON Query DSL.
 * @param data The data for the request.
 * @param data.requestBody JSON request based on Elasticsearch API.
 * @param data.bucket
 * @param data.relatedType Type of related resource. If none, no associated resource returned.
 * @returns string Search results.
 * @throws ApiError
 */
export const search = (data: SearchData): CancelablePromise<SearchResponse> => {
  return __request(OpenAPI, {
    method: 'POST',
    url: '/search/records/_search',
    query: {
      bucket: data.bucket,
      relatedType: data.relatedType,
    },
    body: data.requestBody,
    mediaType: 'application/json',
  });
};

/**
 * Get current selections
 * @returns number OK
 * @throws ApiError
 */
export const getSelectionsAndSize =
  (): CancelablePromise<GetSelectionsAndSizeResponse> => {
    return __request(OpenAPI, {
      method: 'GET',
      url: '/selections',
    });
  };

/**
 * Clear selection or remove items
 * @param data The data for the request.
 * @param data.bucket Selection bucket name
 * @param data.uuid One or more record UUIDs
 * @returns number OK
 * @throws ApiError
 */
export const clear = (data: ClearData): CancelablePromise<ClearResponse> => {
  return __request(OpenAPI, {
    method: 'DELETE',
    url: '/selections/{bucket}',
    path: {
      bucket: data.bucket,
    },
    query: {
      uuid: data.uuid,
    },
  });
};

/**
 * Get current selection
 * @param data The data for the request.
 * @param data.bucket Bucket name
 * @returns string OK
 * @throws ApiError
 */
export const get = (data: GetData): CancelablePromise<GetResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/selections/{bucket}',
    path: {
      bucket: data.bucket,
    },
  });
};

/**
 * Select one or more items
 * @param data The data for the request.
 * @param data.bucket Bucket name
 * @param data.uuid One or more record UUIDs. If null, select all in current search if bucket name is 'metadata' (TODO: remove this limitation?).
 * @returns number OK
 * @throws ApiError
 */
export const add = (data: AddData): CancelablePromise<AddResponse> => {
  return __request(OpenAPI, {
    method: 'PUT',
    url: '/selections/{bucket}',
    path: {
      bucket: data.bucket,
    },
    query: {
      uuid: data.uuid,
    },
  });
};

/**
 * Get site (or portal) description
 * @returns SettingsListResponse Site description.
 * @throws ApiError
 */
export const getSiteOrPortalDescription =
  (): CancelablePromise<GetSiteOrPortalDescriptionResponse> => {
    return __request(OpenAPI, {
      method: 'GET',
      url: '/site',
    });
  };

/**
 * Index
 * @param data The data for the request.
 * @param data.reset Drop and recreate index
 * @param data.asynchronous Asynchronous mode (only on all records. ie. no selection bucket)
 * @param data.indices Index. By default only remove record index.
 * @param data.bucket Selection bucket name
 * @returns string OK
 * @throws ApiError
 */
export const indexSite = (
  data: IndexSiteData = {}
): CancelablePromise<IndexSiteResponse> => {
  return __request(OpenAPI, {
    method: 'PUT',
    url: '/site/index',
    query: {
      reset: data.reset,
      asynchronous: data.asynchronous,
      indices: data.indices,
      bucket: data.bucket,
    },
  });
};

/**
 * Index commit
 * @returns unknown OK
 * @throws ApiError
 */
export const indexCommit = (): CancelablePromise<IndexCommitResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/site/index/commit',
  });
};

/**
 * Force to commit pending documents in index.
 * May be used when indexing task is hanging.
 * @returns unknown Changes committed.
 * @throws ApiError
 */
export const commitIndexChanges =
  (): CancelablePromise<CommitIndexChangesResponse> => {
    return __request(OpenAPI, {
      method: 'PUT',
      url: '/site/index/commit',
    });
  };

/**
 * Index status
 * @returns Status OK
 * @throws ApiError
 */
export const indexStatus = (): CancelablePromise<IndexStatusResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/site/index/status',
  });
};

/**
 * Index synchronized with database
 * @returns unknown OK
 * @throws ApiError
 */
export const indexAndDbSynchronizationStatus =
  (): CancelablePromise<IndexAndDbSynchronizationStatusResponse> => {
    return __request(OpenAPI, {
      method: 'GET',
      url: '/site/index/synchronized',
    });
  };

/**
 * Is indexing?
 * @returns boolean OK
 * @throws ApiError
 */
export const isIndexing = (): CancelablePromise<IsIndexingResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/site/indexing',
  });
};

/**
 * Get site informations
 * @returns SiteInformation Site information.
 * @throws ApiError
 */
export const getInformation = (): CancelablePromise<GetInformationResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/site/info',
  });
};

/**
 * Get build details
 * To know when and how this version of the application was built.
 * @returns SystemInfo Build info.
 * @throws ApiError
 */
export const getSystemInfo = (): CancelablePromise<GetSystemInfoResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/site/info/build',
  });
};

/**
 * Is CAS enabled?
 * @returns boolean OK
 * @throws ApiError
 */
export const isCasEnabled = (): CancelablePromise<IsCasEnabledResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/site/info/isCasEnabled',
  });
};

/**
 * Get notification levels
 * @returns string List of notification levels.
 * @throws ApiError
 */
export const getNotificationLevel =
  (): CancelablePromise<GetNotificationLevelResponse> => {
    return __request(OpenAPI, {
      method: 'GET',
      url: '/site/info/notificationLevels',
    });
  };

/**
 * Get proxy configuration details
 * Get the proxy configuration.
 * @returns ProxyConfiguration Proxy configuration.
 * @throws ApiError
 */
export const getProxyConfiguration =
  (): CancelablePromise<GetProxyConfigurationResponse> => {
    return __request(OpenAPI, {
      method: 'GET',
      url: '/site/info/proxy',
    });
  };

/**
 * Is in read-only mode?
 * @returns boolean OK
 * @throws ApiError
 */
export const isReadOnly = (): CancelablePromise<IsReadOnlyResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/site/info/readonly',
  });
};

/**
 * Update staging profile
 * TODO: Needs doc
 * @param data The data for the request.
 * @param data.profile
 * @returns void Staging profile saved.
 * @throws ApiError
 */
export const updateStagingProfile = (
  data: UpdateStagingProfileData
): CancelablePromise<UpdateStagingProfileResponse> => {
  return __request(OpenAPI, {
    method: 'PUT',
    url: '/site/info/staging/{profile}',
    path: {
      profile: data.profile,
    },
    errors: {
      403: 'Operation not allowed. Only Administrators can access it.',
    },
  });
};

/**
 * Get XSL tranformations available
 * XSL transformations may be applied while importing or harvesting records.
 * @returns string XSLT available.
 * @throws ApiError
 */
export const getXslTransformations =
  (): CancelablePromise<GetXslTransformationsResponse> => {
    return __request(OpenAPI, {
      method: 'GET',
      url: '/site/info/transforms',
    });
  };

/**
 * Get log files
 * @returns LogFileResponse OK
 * @throws ApiError
 */
export const getLogFiles = (): CancelablePromise<GetLogFilesResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/site/logging',
  });
};

/**
 * Get last activity
 * @param data The data for the request.
 * @param data.lines Number of lines to return
 * @returns string OK
 * @throws ApiError
 */
export const getLastActivity = (
  data: GetLastActivityData = {}
): CancelablePromise<GetLastActivityResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/site/logging/activity',
    query: {
      lines: data.lines,
    },
  });
};

/**
 * Get last activity in a ZIP
 * @returns unknown OK
 * @throws ApiError
 */
export const getLastActivityInAzip =
  (): CancelablePromise<GetLastActivityInAzipResponse> => {
    return __request(OpenAPI, {
      method: 'GET',
      url: '/site/logging/activity/zip',
    });
  };

/**
 * Set catalog logo
 * Logos are stored in the data directory resources/images/harvesting as PNG or GIF images. When a logo is assigned to the catalog, a new image is created in images/logos/<catalogUuid>.png.
 * @param data The data for the request.
 * @param data.file Logo to use for the catalog
 * @param data.asFavicon Create favicon too
 * @returns void Logo set.
 * @throws ApiError
 */
export const setLogo = (
  data: SetLogoData
): CancelablePromise<SetLogoResponse> => {
  return __request(OpenAPI, {
    method: 'PUT',
    url: '/site/logo',
    query: {
      file: data.file,
      asFavicon: data.asFavicon,
    },
    errors: {
      403: 'Operation not allowed. Only UserAdmins can access it.',
    },
  });
};

/**
 * Get settings
 * Return public settings for anonymous users, internals are allowed for authenticated.
 * @param data The data for the request.
 * @param data.set Setting set. A common set of settings to retrieve.
 * @param data.key Setting key
 * @returns SettingsListResponse Settings.
 * @throws ApiError
 */
export const getSettingsSet = (
  data: GetSettingsSetData = {}
): CancelablePromise<GetSettingsSetResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/site/settings',
    query: {
      set: data.set,
      key: data.key,
    },
  });
};

/**
 * Save settings
 * @param data The data for the request.
 * @param data.allRequestParams
 * @returns void Settings saved.
 * @throws ApiError
 */
export const saveSettings = (
  data: SaveSettingsData
): CancelablePromise<SaveSettingsResponse> => {
  return __request(OpenAPI, {
    method: 'POST',
    url: '/site/settings',
    query: {
      allRequestParams: data.allRequestParams,
    },
    errors: {
      403: 'Operation not allowed. Only Administrators can access it.',
    },
  });
};

/**
 * Get settings with details
 * Provides also setting properties.
 * @param data The data for the request.
 * @param data.set Setting set. A common set of settings to retrieve.
 * @param data.key Setting key
 * @returns Setting Settings with details.
 * @throws ApiError
 */
export const getSettingsDetails = (
  data: GetSettingsDetailsData = {}
): CancelablePromise<GetSettingsDetailsResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/site/settings/details',
    query: {
      set: data.set,
      key: data.key,
    },
  });
};

/**
 * Get sitemap
 * @param data The data for the request.
 * @param data.format Format (xml or html).
 * @param data.doc page.
 * @returns unknown Site map.
 * @throws ApiError
 */
export const getSitemap = (
  data: GetSitemapData = {}
): CancelablePromise<GetSitemapResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/sitemap',
    query: {
      format: data.format,
      doc: data.doc,
    },
  });
};

/**
 * Get all sources
 * Sources are the local catalogue, subportal, external catalogue (when importing MEF files) or harvesters.
 * @param data The data for the request.
 * @param data.group Group owner of the source (only applies to subportal).
 * @returns Source List of source catalogues.
 * @throws ApiError
 */
export const getSources = (
  data: GetSourcesData = {}
): CancelablePromise<GetSourcesResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/sources',
    query: {
      group: data.group,
    },
  });
};

/**
 * Add a source
 * @param data The data for the request.
 * @param data.requestBody
 * @returns string Source created.
 * @throws ApiError
 */
export const addSource = (
  data: AddSourceData
): CancelablePromise<AddSourceResponse> => {
  return __request(OpenAPI, {
    method: 'PUT',
    url: '/sources',
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
      403: 'Operation not allowed. Only Administrators can access it.',
    },
  });
};

/**
 * Remove a source
 * @param data The data for the request.
 * @param data.sourceIdentifier Source identifier
 * @returns string Source deleted.
 * @throws ApiError
 */
export const deleteSource = (
  data: DeleteSourceData
): CancelablePromise<DeleteSourceResponse> => {
  return __request(OpenAPI, {
    method: 'DELETE',
    url: '/sources/{sourceIdentifier}',
    path: {
      sourceIdentifier: data.sourceIdentifier,
    },
    errors: {
      403: 'Operation not allowed. Only Administrators can access it.',
    },
  });
};

/**
 * Update a source
 * @param data The data for the request.
 * @param data.sourceIdentifier Source identifier
 * @param data.requestBody
 * @returns string Source updated.
 * @throws ApiError
 */
export const updateSource = (
  data: UpdateSourceData
): CancelablePromise<UpdateSourceResponse> => {
  return __request(OpenAPI, {
    method: 'PUT',
    url: '/sources/{sourceIdentifier}',
    path: {
      sourceIdentifier: data.sourceIdentifier,
    },
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
      403: 'Operation not allowed. Only UserAdmins can access it.',
      404: 'Source not found.',
    },
  });
};

/**
 * Get all sources by type
 * Sources are the local catalogue, subportal, external catalogue (when importing MEF files) or harvesters.
 * @param data The data for the request.
 * @param data.type
 * @returns Source OK
 * @throws ApiError
 */
export const getSourcesByType = (
  data: GetSourcesByTypeData
): CancelablePromise<GetSourcesByTypeResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/sources/{type}',
    path: {
      type: data.type,
    },
  });
};

/**
 * Get standards
 * @returns unknown List of standards.
 * @throws ApiError
 */
export const getStandardConfigurations =
  (): CancelablePromise<GetStandardConfigurationsResponse> => {
    return __request(OpenAPI, {
      method: 'GET',
      url: '/standards',
    });
  };

/**
 * Get batch editor configuration for standards
 * @param data The data for the request.
 * @param data.schema Schema identifiers
 * @returns BatchEditing Batch editor configuration.
 * @throws ApiError
 */
export const getConfigurations = (
  data: GetConfigurationsData = {}
): CancelablePromise<GetConfigurationsResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/standards/batchconfiguration',
    query: {
      schema: data.schema,
    },
  });
};

/**
 * Reload standards
 * @returns unknown Standards reloaded.
 * @throws ApiError
 */
export const reloadSchema = (): CancelablePromise<ReloadSchemaResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/standards/reload',
  });
};

/**
 * Get batch editor configuration for a standard
 * @param data The data for the request.
 * @param data.schema Schema identifier
 * @returns BatchEditing OK
 * @throws ApiError
 */
export const getConfiguration = (
  data: GetConfigurationData
): CancelablePromise<GetConfigurationResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/standards/{schema}/batchconfiguration',
    path: {
      schema: data.schema,
    },
  });
};

/**
 * Get multiple codelist translations
 * All translations are combined in the same object. No distinction by codelist. This is useful if you need lots of codelists terms to be loaded.
 * @param data The data for the request.
 * @param data.schema Schema identifier
 * @param data.codelist Codelist element name or alias
 * @returns string OK
 * @throws ApiError
 */
export const getCodelistsTranslations = (
  data: GetCodelistsTranslationsData
): CancelablePromise<GetCodelistsTranslationsResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/standards/{schema}/codelists',
    path: {
      schema: data.schema,
    },
    query: {
      codelist: data.codelist,
    },
  });
};

/**
 * Get codelist translations
 * @param data The data for the request.
 * @param data.schema Schema identifier
 * @param data.codelist Codelist element name or alias
 * @param data.parent
 * @param data.displayIf
 * @param data.xpath
 * @param data.isoType
 * @returns string OK
 * @throws ApiError
 */
export const getSchemaTranslations = (
  data: GetSchemaTranslationsData
): CancelablePromise<GetSchemaTranslationsResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/standards/{schema}/codelists/{codelist}',
    path: {
      schema: data.schema,
      codelist: data.codelist,
    },
    query: {
      parent: data.parent,
      displayIf: data.displayIf,
      xpath: data.xpath,
      isoType: data.isoType,
    },
  });
};

/**
 * Get codelist details
 * @param data The data for the request.
 * @param data.schema Schema identifier
 * @param data.codelist Codelist element name or alias
 * @param data.parent Parent name with namespace which may indicate a more precise label as defined in context attribute.
 * @param data.displayIf Display if condition as defined in the codelist.xml file. Allows to select a more precise codelist when more than one is defined for same name.
 * @param data.xpath XPath of the element to target which may indicate a more precise label as defined in context attribute.
 * @param data.isoType ISO type of the element to target which may indicate a more precise label as defined in context attribute. (Same as context. TODO: Deprecate ?)
 * @returns Codelist OK
 * @throws ApiError
 */
export const getSchemaCodelistsWithDetails = (
  data: GetSchemaCodelistsWithDetailsData
): CancelablePromise<GetSchemaCodelistsWithDetailsResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/standards/{schema}/codelists/{codelist}/details',
    path: {
      schema: data.schema,
      codelist: data.codelist,
    },
    query: {
      parent: data.parent,
      displayIf: data.displayIf,
      xpath: data.xpath,
      isoType: data.isoType,
    },
  });
};

/**
 * Get descriptor details
 * @param data The data for the request.
 * @param data.schema Schema identifier
 * @param data.element Descriptor name
 * @param data.parent
 * @param data.displayIf
 * @param data.xpath
 * @param data.isoType
 * @returns Element OK
 * @throws ApiError
 */
export const getElementDetails = (
  data: GetElementDetailsData
): CancelablePromise<GetElementDetailsResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/standards/{schema}/descriptors/{element}/details',
    path: {
      schema: data.schema,
      element: data.element,
    },
    query: {
      parent: data.parent,
      displayIf: data.displayIf,
      xpath: data.xpath,
      isoType: data.isoType,
    },
  });
};

/**
 * Get editor associated resources panel configuration
 * @param data The data for the request.
 * @param data.schema Schema identifier
 * @param data.name Configuration identifier
 * @returns string OK
 * @throws ApiError
 */
export const getEditorAssociatedPanelConfiguration = (
  data: GetEditorAssociatedPanelConfigurationData
): CancelablePromise<GetEditorAssociatedPanelConfigurationResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/standards/{schema}/editor/associatedpanel/config/{name}.json',
    path: {
      schema: data.schema,
      name: data.name,
    },
  });
};

/**
 * Delete all record history and status
 * @returns void Status removed.
 * @throws ApiError
 */
export const deleteAllHistoryAndStatus =
  (): CancelablePromise<DeleteAllHistoryAndStatusResponse> => {
    return __request(OpenAPI, {
      method: 'DELETE',
      url: '/status',
      errors: {
        403: 'Operation not allowed. Only Administrators can access it.',
      },
    });
  };

/**
 * Get status
 * @returns StatusValue OK
 * @throws ApiError
 */
export const getStatusList = (): CancelablePromise<GetStatusListResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/status',
  });
};

/**
 * Get status by type
 * @param data The data for the request.
 * @param data.type Type
 * @returns StatusValue OK
 * @throws ApiError
 */
export const getStatusByType = (
  data: GetStatusByTypeData
): CancelablePromise<GetStatusByTypeResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/status/{type}',
    path: {
      type: data.type,
    },
  });
};

/**
 * Get tags
 * @returns MetadataCategory List of tags.
 * @throws ApiError
 */
export const getTags = (): CancelablePromise<GetTagsResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/tags',
  });
};

/**
 * Create a tag
 * If labels are not defined, a default label is created with the category name for all languages.
 * @param data The data for the request.
 * @param data.requestBody
 * @returns number Tag created. Return the new tag identifier.
 * @throws ApiError
 */
export const putTag = (data: PutTagData): CancelablePromise<PutTagResponse> => {
  return __request(OpenAPI, {
    method: 'PUT',
    url: '/tags',
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
      403: 'Operation not allowed. Only UserAdmins can access it.',
    },
  });
};

/**
 * Remove a tag
 * @param data The data for the request.
 * @param data.tagIdentifier Tag identifier
 * @returns string Tag removed.
 * @throws ApiError
 */
export const deleteTag = (
  data: DeleteTagData
): CancelablePromise<DeleteTagResponse> => {
  return __request(OpenAPI, {
    method: 'DELETE',
    url: '/tags/{tagIdentifier}',
    path: {
      tagIdentifier: data.tagIdentifier,
    },
    errors: {
      403: 'Operation not allowed. Only UserAdmins can access it.',
    },
  });
};

/**
 * Get a tag
 * @param data The data for the request.
 * @param data.tagIdentifier Tag identifier
 * @returns MetadataCategory Tag details.
 * @throws ApiError
 */
export const getTag = (data: GetTagData): CancelablePromise<GetTagResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/tags/{tagIdentifier}',
    path: {
      tagIdentifier: data.tagIdentifier,
    },
  });
};

/**
 * Update a tag
 * @param data The data for the request.
 * @param data.tagIdentifier Tag identifier
 * @param data.requestBody
 * @returns string Tag updated.
 * @throws ApiError
 */
export const updateTag = (
  data: UpdateTagData
): CancelablePromise<UpdateTagResponse> => {
  return __request(OpenAPI, {
    method: 'PUT',
    url: '/tags/{tagIdentifier}',
    path: {
      tagIdentifier: data.tagIdentifier,
    },
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
      403: 'Operation not allowed. Only UserAdmins can access it.',
    },
  });
};

/**
 * Test mail configuration
 * Send an email to the catalog feedback email.
 * @returns string Created
 * @throws ApiError
 */
export const testMailConfiguration =
  (): CancelablePromise<TestMailConfigurationResponse> => {
    return __request(OpenAPI, {
      method: 'GET',
      url: '/tools/mail/test',
    });
  };

/**
 * Call a migration step
 * @param data The data for the request.
 * @param data.stepName Class name to execute corresponding to a migration step. See DatabaseMigrationTask.
 * @returns string Created
 * @throws ApiError
 */
export const callStep = (
  data: CallStepData
): CancelablePromise<CallStepResponse> => {
  return __request(OpenAPI, {
    method: 'PUT',
    url: '/tools/migration/steps/{stepName}',
    path: {
      stepName: data.stepName,
    },
  });
};

/**
 * Generate an OGC filter
 * From a JSON filter, return an OGC filter expression.
 * @param data The data for the request.
 * @param data.filters The filters in JSON
 * @returns string Created
 * @throws ApiError
 */
export const buildFilter = (
  data: BuildFilterData
): CancelablePromise<BuildFilterResponse> => {
  return __request(OpenAPI, {
    method: 'POST',
    url: '/tools/ogc/filter',
    query: {
      filters: data.filters,
    },
  });
};

/**
 * Remove all SLD files
 * Clean all SLD generated previously
 * @returns unknown OK
 * @throws ApiError
 */
export const deteleSld = (): CancelablePromise<DeteleSldResponse> => {
  return __request(OpenAPI, {
    method: 'DELETE',
    url: '/tools/ogc/sld',
  });
};

/**
 * Get the list of SLD available
 * @returns string OK
 * @throws ApiError
 */
export const getSld = (): CancelablePromise<GetSldResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/tools/ogc/sld',
  });
};

/**
 * Generate a SLD with a new filter
 * Get the current SLD for the requested layers, add new filters in, save the SLD and return the new SLD URL.
 * @param data The data for the request.
 * @param data.url The WMS server URL
 * @param data.layers The layers
 * @param data.filters The filters in JSON
 * @returns string Created
 * @throws ApiError
 */
export const buildSld = (
  data: BuildSldData
): CancelablePromise<BuildSldResponse> => {
  return __request(OpenAPI, {
    method: 'POST',
    url: '/tools/ogc/sld',
    query: {
      url: data.url,
      layers: data.layers,
      filters: data.filters,
    },
  });
};

/**
 * Download a SLD
 * @param data The data for the request.
 * @param data.id The SLD identifier
 * @param data.extension
 * @returns unknown OK
 * @throws ApiError
 */
export const downloadSld = (
  data: DownloadSldData
): CancelablePromise<DownloadSldResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/tools/ogc/sld/{id}.{extension}',
    path: {
      id: data.id,
      extension: data.extension,
    },
  });
};

/**
 * Retrieve the list of translation provider.
 * @returns string List of translation provider names.
 * @throws ApiError
 */
export const getTranslationProviderNames =
  (): CancelablePromise<GetTranslationProviderNamesResponse> => {
    return __request(OpenAPI, {
      method: 'GET',
      url: '/translationproviders',
    });
  };

/**
 * Get UI configuration
 * @returns UiSetting List of configuration.
 * @throws ApiError
 */
export const getUiConfigurations =
  (): CancelablePromise<GetUiConfigurationsResponse> => {
    return __request(OpenAPI, {
      method: 'GET',
      url: '/ui',
    });
  };

/**
 * Create a UI configuration
 * @param data The data for the request.
 * @param data.requestBody
 * @returns string UI configuration created. Return the new UI configuration identifier.
 * @throws ApiError
 */
export const putUiConfiguration = (
  data: PutUiConfigurationData
): CancelablePromise<PutUiConfigurationResponse> => {
  return __request(OpenAPI, {
    method: 'PUT',
    url: '/ui',
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
      403: 'Operation not allowed. Only UserAdmins can access it.',
    },
  });
};

/**
 * Remove a UI Configuration
 * @param data The data for the request.
 * @param data.uiIdentifier UI configuration identifier
 * @returns string UI Configuration removed.
 * @throws ApiError
 */
export const deleteUiConfiguration = (
  data: DeleteUiConfigurationData
): CancelablePromise<DeleteUiConfigurationResponse> => {
  return __request(OpenAPI, {
    method: 'DELETE',
    url: '/ui/{uiIdentifier}',
    path: {
      uiIdentifier: data.uiIdentifier,
    },
    errors: {
      403: 'Operation not allowed. Only UserAdmins can access it.',
      404: 'UI Configuration not found.',
    },
  });
};

/**
 * Get a UI configuration
 * @param data The data for the request.
 * @param data.uiIdentifier UI identifier
 * @returns UiSetting UI configuration.
 * @throws ApiError
 */
export const getUiConfiguration = (
  data: GetUiConfigurationData
): CancelablePromise<GetUiConfigurationResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/ui/{uiIdentifier}',
    path: {
      uiIdentifier: data.uiIdentifier,
    },
  });
};

/**
 * Update a UI configuration
 * @param data The data for the request.
 * @param data.uiIdentifier UI configuration identifier
 * @param data.requestBody
 * @returns string UI configuration updated.
 * @throws ApiError
 */
export const updateUiConfiguration = (
  data: UpdateUiConfigurationData
): CancelablePromise<UpdateUiConfigurationResponse> => {
  return __request(OpenAPI, {
    method: 'PUT',
    url: '/ui/{uiIdentifier}',
    path: {
      uiIdentifier: data.uiIdentifier,
    },
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
      403: 'Operation not allowed. Only UserAdmins can access it.',
    },
  });
};

/**
 * Send user password reminder by email
 * An email is sent to the requested user with a link to reset his password. User MUST have an email to get the link. LDAP users will not be able to retrieve their password using this service.
 * @param data The data for the request.
 * @param data.username The user name
 * @returns string Created
 * @throws ApiError
 */
export const sendPasswordByEmail = (
  data: SendPasswordByEmailData
): CancelablePromise<SendPasswordByEmailResponse> => {
  return __request(OpenAPI, {
    method: 'PUT',
    url: '/user/actions/forgot-password',
    query: {
      username: data.username,
    },
  });
};

/**
 * Create user account
 * User is created with a registered user profile. username field is ignored and the email is used as username. Password is sent by email. Catalog administrator is also notified.
 * @param data The data for the request.
 * @param data.requestBody
 * @returns string Created
 * @throws ApiError
 */
export const registerUser = (
  data: RegisterUserData
): CancelablePromise<RegisterUserResponse> => {
  return __request(OpenAPI, {
    method: 'PUT',
    url: '/user/actions/register',
    body: data.requestBody,
    mediaType: 'application/json',
  });
};

/**
 * Update user password
 * Get a valid changekey by email first and then update your password.
 * @param data The data for the request.
 * @param data.username The user name
 * @param data.requestBody
 * @returns string Created
 * @throws ApiError
 */
export const updatePassword = (
  data: UpdatePasswordData
): CancelablePromise<UpdatePasswordResponse> => {
  return __request(OpenAPI, {
    method: 'PATCH',
    url: '/user/{username}',
    path: {
      username: data.username,
    },
    body: data.requestBody,
    mediaType: 'application/json',
  });
};

/**
 * Finds a list of user feedback records.
 *  This list will include also the draft user feedback if the client is logged as reviewer.
 * @param data The data for the request.
 * @param data.metadataUuid Metadata record UUID.
 * @param data.size Maximum number of feedback to return.
 * @returns UserFeedbackDTO OK
 * @throws ApiError
 */
export const getUserComments = (
  data: GetUserCommentsData = {}
): CancelablePromise<GetUserCommentsResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/userfeedback',
    query: {
      metadataUuid: data.metadataUuid,
      size: data.size,
    },
  });
};

/**
 * Creates a user feedback
 * Creates a user feedback in draft status if the user is not logged in.
 * @param data The data for the request.
 * @param data.requestBody
 * @returns string Created
 * @throws ApiError
 */
export const newUserFeedback = (
  data: NewUserFeedbackData
): CancelablePromise<NewUserFeedbackResponse> => {
  return __request(OpenAPI, {
    method: 'POST',
    url: '/userfeedback',
    body: data.requestBody,
    mediaType: 'application/json',
  });
};

/**
 * Get list of rating criteria
 * @returns RatingCriteria OK
 * @throws ApiError
 */
export const getRatingCriteria =
  (): CancelablePromise<GetRatingCriteriaResponse> => {
    return __request(OpenAPI, {
      method: 'GET',
      url: '/userfeedback/ratingcriteria',
    });
  };

/**
 * Removes a user feedback
 * Removes a user feedback
 * @param data The data for the request.
 * @param data.uuid User feedback UUID.
 * @returns string User feedback removed.
 * @throws ApiError
 */
export const deleteUserFeedback = (
  data: DeleteUserFeedbackData
): CancelablePromise<DeleteUserFeedbackResponse> => {
  return __request(OpenAPI, {
    method: 'DELETE',
    url: '/userfeedback/{uuid}',
    path: {
      uuid: data.uuid,
    },
    errors: {
      403: 'Operation not allowed. Only Reviewvers can access it.',
    },
  });
};

/**
 * Finds a specific user feedback
 * @param data The data for the request.
 * @param data.uuid User feedback UUID.
 * @returns UserFeedbackDTO OK
 * @throws ApiError
 */
export const getUserComment = (
  data: GetUserCommentData
): CancelablePromise<GetUserCommentResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/userfeedback/{uuid}',
    path: {
      uuid: data.uuid,
    },
  });
};

/**
 * Publishes a feedback
 * For reviewers
 * @param data The data for the request.
 * @param data.uuid User feedback UUID.
 * @returns string User feedback published.
 * @throws ApiError
 */
export const publishFeedback = (
  data: PublishFeedbackData
): CancelablePromise<PublishFeedbackResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/userfeedback/{uuid}/publish',
    path: {
      uuid: data.uuid,
    },
    errors: {
      403: 'Operation not allowed. Only Reviewvers can access it.',
      404: 'Resource not found.',
    },
  });
};

/**
 * Get users
 * @returns User OK
 * @throws ApiError
 */
export const getUsers = (): CancelablePromise<GetUsersResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/users',
  });
};

/**
 * Creates a user
 * Creates a catalog user.
 * @param data The data for the request.
 * @param data.requestBody
 * @returns string OK
 * @throws ApiError
 */
export const createUser = (
  data: CreateUserData
): CancelablePromise<CreateUserResponse> => {
  return __request(OpenAPI, {
    method: 'PUT',
    url: '/users',
    body: data.requestBody,
    mediaType: 'application/json',
  });
};

/**
 * Retrieve all user groups
 * @returns UserGroupsResponse OK
 * @throws ApiError
 */
export const retrieveAllUserGroups =
  (): CancelablePromise<RetrieveAllUserGroupsResponse> => {
    return __request(OpenAPI, {
      method: 'GET',
      url: '/users/groups',
    });
  };

/**
 * Get owners
 * Return users who actually owns one or more records.
 * @returns OwnerResponse OK
 * @throws ApiError
 */
export const getRecordOwners =
  (): CancelablePromise<GetRecordOwnersResponse> => {
    return __request(OpenAPI, {
      method: 'GET',
      url: '/users/owners',
    });
  };

/**
 * Transfer privileges
 * @param data The data for the request.
 * @param data.requestBody
 * @returns string OK
 * @throws ApiError
 */
export const saveOwners = (
  data: SaveOwnersData
): CancelablePromise<SaveOwnersResponse> => {
  return __request(OpenAPI, {
    method: 'PUT',
    url: '/users/owners',
    body: data.requestBody,
    mediaType: 'application/json',
  });
};

/**
 * Check if a user property already exist
 * @param data The data for the request.
 * @param data.property The user property to check
 * @param data.exist The value to search
 * @returns string Property does not exist.
 * @throws ApiError
 */
export const checkUserPropertyExist = (
  data: CheckUserPropertyExistData
): CancelablePromise<CheckUserPropertyExistResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/users/properties/{property}',
    path: {
      property: data.property,
    },
    query: {
      exist: data.exist,
    },
    errors: {
      403: 'Operation not allowed. Only UserAdmins can access it.',
      404: 'A property with that value already exist.',
    },
  });
};

/**
 * Delete a user
 * Deletes a catalog user by identifier.
 * @param data The data for the request.
 * @param data.userIdentifier User identifier.
 * @returns string OK
 * @throws ApiError
 */
export const deleteUser = (
  data: DeleteUserData
): CancelablePromise<DeleteUserResponse> => {
  return __request(OpenAPI, {
    method: 'DELETE',
    url: '/users/{userIdentifier}',
    path: {
      userIdentifier: data.userIdentifier,
    },
  });
};

/**
 * Get user
 * @param data The data for the request.
 * @param data.userIdentifier User identifier.
 * @returns User OK
 * @throws ApiError
 */
export const getUser = (
  data: GetUserData
): CancelablePromise<GetUserResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/users/{userIdentifier}',
    path: {
      userIdentifier: data.userIdentifier,
    },
  });
};

/**
 * Update a user
 * Updates a catalog user.
 * @param data The data for the request.
 * @param data.userIdentifier User identifier.
 * @param data.requestBody
 * @returns string OK
 * @throws ApiError
 */
export const updateUser = (
  data: UpdateUserData
): CancelablePromise<UpdateUserResponse> => {
  return __request(OpenAPI, {
    method: 'PUT',
    url: '/users/{userIdentifier}',
    path: {
      userIdentifier: data.userIdentifier,
    },
    body: data.requestBody,
    mediaType: 'application/json',
  });
};

/**
 * Get user identicon
 * @param data The data for the request.
 * @param data.userIdentifier User identifier.
 * @param data.size Size.
 * @returns unknown OK
 * @throws ApiError
 */
export const getUserIdenticon = (
  data: GetUserIdenticonData
): CancelablePromise<GetUserIdenticonResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/users/{userIdentifier}.png',
    path: {
      userIdentifier: data.userIdentifier,
    },
    query: {
      size: data.size,
    },
  });
};

/**
 * Resets user password
 * Resets the user password.
 * @param data The data for the request.
 * @param data.userIdentifier User identifier.
 * @param data.requestBody
 * @returns string OK
 * @throws ApiError
 */
export const resetUserPassword = (
  data: ResetUserPasswordData
): CancelablePromise<ResetUserPasswordResponse> => {
  return __request(OpenAPI, {
    method: 'POST',
    url: '/users/{userIdentifier}/actions/forget-password',
    path: {
      userIdentifier: data.userIdentifier,
    },
    body: data.requestBody,
    mediaType: 'application/json',
  });
};

/**
 * Retrieve user groups
 * Retrieve the user groups.
 * @param data The data for the request.
 * @param data.userIdentifier User identifier.
 * @returns UserGroup OK
 * @throws ApiError
 */
export const retrieveUserGroups = (
  data: RetrieveUserGroupsData
): CancelablePromise<RetrieveUserGroupsResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/users/{userIdentifier}/groups',
    path: {
      userIdentifier: data.userIdentifier,
    },
  });
};

/**
 * Get user custom searches
 * @returns UserSearchDto OK
 * @throws ApiError
 */
export const getUserCustomSearches =
  (): CancelablePromise<GetUserCustomSearchesResponse> => {
    return __request(OpenAPI, {
      method: 'GET',
      url: '/usersearches',
    });
  };

/**
 * Creates a user search
 * Creates a user search.
 * @param data The data for the request.
 * @param data.requestBody
 * @returns number User search created.
 * @throws ApiError
 */
export const createUserCustomSearch = (
  data: CreateUserCustomSearchData
): CancelablePromise<CreateUserCustomSearchResponse> => {
  return __request(OpenAPI, {
    method: 'PUT',
    url: '/usersearches',
    body: data.requestBody,
    mediaType: 'application/json',
  });
};

/**
 * Get user custom searches for all users (no paginated)
 * @param data The data for the request.
 * @param data.featuredType Featured type search.
 * @returns UserSearchDto OK
 * @throws ApiError
 */
export const getAllUserCustomSearches = (
  data: GetAllUserCustomSearchesData = {}
): CancelablePromise<GetAllUserCustomSearchesResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/usersearches/all',
    query: {
      featuredType: data.featuredType,
    },
  });
};

/**
 * Get user custom searches for all users (paginated)
 * @param data The data for the request.
 * @param data.featuredType Featured  type search.
 * @param data.search
 * @param data.offset From page
 * @param data.limit Number of records to return
 * @returns PaginatedUserSearchResponse OK
 * @throws ApiError
 */
export const getAllUserCustomSearchesPage = (
  data: GetAllUserCustomSearchesPageData = {}
): CancelablePromise<GetAllUserCustomSearchesPageResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/usersearches/allpaginated',
    query: {
      featuredType: data.featuredType,
      search: data.search,
      offset: data.offset,
      limit: data.limit,
    },
  });
};

/**
 * Get featured user custom searches
 * @param data The data for the request.
 * @param data.type Number of records to return
 * @returns UserSearchDto OK
 * @throws ApiError
 */
export const getFeaturedUserCustomSearches = (
  data: GetFeaturedUserCustomSearchesData = {}
): CancelablePromise<GetFeaturedUserCustomSearchesResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/usersearches/featured',
    query: {
      type: data.type,
    },
  });
};

/**
 * Delete a user search
 * Deletes a user search by identifier.
 * @param data The data for the request.
 * @param data.searchIdentifier Search identifier.
 * @returns string OK
 * @throws ApiError
 */
export const deleteUserCustomSerach = (
  data: DeleteUserCustomSerachData
): CancelablePromise<DeleteUserCustomSerachResponse> => {
  return __request(OpenAPI, {
    method: 'DELETE',
    url: '/usersearches/{searchIdentifier}',
    path: {
      searchIdentifier: data.searchIdentifier,
    },
  });
};

/**
 * Get custom search
 * @param data The data for the request.
 * @param data.searchIdentifier User search identifier
 * @returns UserSearchDto OK
 * @throws ApiError
 */
export const getUserCustomSearch = (
  data: GetUserCustomSearchData
): CancelablePromise<GetUserCustomSearchResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/usersearches/{searchIdentifier}',
    path: {
      searchIdentifier: data.searchIdentifier,
    },
  });
};

/**
 * Update a user search
 * @param data The data for the request.
 * @param data.searchIdentifier User search identifier
 * @param data.requestBody
 * @returns void User search  updated.
 * @throws ApiError
 */
export const updateCustomUserSearch = (
  data: UpdateCustomUserSearchData
): CancelablePromise<UpdateCustomUserSearchResponse> => {
  return __request(OpenAPI, {
    method: 'PUT',
    url: '/usersearches/{searchIdentifier}',
    path: {
      searchIdentifier: data.searchIdentifier,
    },
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
      404: 'Resource not found.',
    },
  });
};

/**
 * Get list of user selection sets
 * @returns Selection OK
 * @throws ApiError
 */
export const getSelectionList =
  (): CancelablePromise<GetSelectionListResponse> => {
    return __request(OpenAPI, {
      method: 'GET',
      url: '/userselections',
    });
  };

/**
 * Add a user selection set
 * @param data The data for the request.
 * @param data.requestBody
 * @returns string Selection created.
 * @throws ApiError
 */
export const createPersistentSelectionType = (
  data: CreatePersistentSelectionTypeData
): CancelablePromise<CreatePersistentSelectionTypeResponse> => {
  return __request(OpenAPI, {
    method: 'PUT',
    url: '/userselections',
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
      400: 'A selection with that id or name already exist.',
      403: 'Operation not allowed. Only UserAdmins can access it.',
    },
  });
};

/**
 * Remove a user selection set
 * @param data The data for the request.
 * @param data.selectionIdentifier Selection identifier
 * @returns string Selection removed.
 * @throws ApiError
 */
export const deleteUserSelection = (
  data: DeleteUserSelectionData
): CancelablePromise<DeleteUserSelectionResponse> => {
  return __request(OpenAPI, {
    method: 'DELETE',
    url: '/userselections/{selectionIdentifier}',
    path: {
      selectionIdentifier: data.selectionIdentifier,
    },
    errors: {
      403: 'Operation not allowed. Only UserAdmins can access it.',
      404: 'Selection not found.',
    },
  });
};

/**
 * Update a user selection set
 * @param data The data for the request.
 * @param data.selectionIdentifier Selection identifier
 * @param data.requestBody
 * @returns string Selection updated.
 * @throws ApiError
 */
export const updateUserSelection = (
  data: UpdateUserSelectionData
): CancelablePromise<UpdateUserSelectionResponse> => {
  return __request(OpenAPI, {
    method: 'PUT',
    url: '/userselections/{selectionIdentifier}',
    path: {
      selectionIdentifier: data.selectionIdentifier,
    },
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
      403: 'Operation not allowed. Only UserAdmins can access it.',
      404: 'Selection not found.',
    },
  });
};

/**
 * Remove items to a user selection set
 * @param data The data for the request.
 * @param data.selectionIdentifier Selection identifier
 * @param data.userIdentifier User identifier
 * @param data.uuid One or more record UUIDs. If null, remove all.
 * @returns string Items removed from a set.
 * @throws ApiError
 */
export const deleteFromUserSelection = (
  data: DeleteFromUserSelectionData
): CancelablePromise<DeleteFromUserSelectionResponse> => {
  return __request(OpenAPI, {
    method: 'DELETE',
    url: '/userselections/{selectionIdentifier}/{userIdentifier}',
    path: {
      selectionIdentifier: data.selectionIdentifier,
      userIdentifier: data.userIdentifier,
    },
    query: {
      uuid: data.uuid,
    },
    errors: {
      403: 'Operation not allowed. Only UserAdmins can access it.',
      404: 'Selection or user not found.',
    },
  });
};

/**
 * Get record in a user selection set
 * @param data The data for the request.
 * @param data.selectionIdentifier Selection identifier
 * @param data.userIdentifier User identifier
 * @returns string OK
 * @throws ApiError
 */
export const getSelectionRecords = (
  data: GetSelectionRecordsData
): CancelablePromise<GetSelectionRecordsResponse> => {
  return __request(OpenAPI, {
    method: 'GET',
    url: '/userselections/{selectionIdentifier}/{userIdentifier}',
    path: {
      selectionIdentifier: data.selectionIdentifier,
      userIdentifier: data.userIdentifier,
    },
  });
};

/**
 * Add items to a user selection set
 * @param data The data for the request.
 * @param data.selectionIdentifier Selection identifier
 * @param data.userIdentifier User identifier
 * @param data.uuid One or more record UUIDs.
 * @returns string Records added to selection set.
 * @throws ApiError
 */
export const addToUserSelection = (
  data: AddToUserSelectionData
): CancelablePromise<AddToUserSelectionResponse> => {
  return __request(OpenAPI, {
    method: 'PUT',
    url: '/userselections/{selectionIdentifier}/{userIdentifier}',
    path: {
      selectionIdentifier: data.selectionIdentifier,
      userIdentifier: data.userIdentifier,
    },
    query: {
      uuid: data.uuid,
    },
    errors: {
      403: 'Operation not allowed. Only UserAdmins can access it.',
      404: 'Selection or user or at least one UUID not found.',
    },
  });
};
