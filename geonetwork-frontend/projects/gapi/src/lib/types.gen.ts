// This file is auto-generated by @hey-api/openapi-ts

import { estypes } from '@elastic/elasticsearch';

export type Address = {
  address?: string;
  city?: string;
  country?: string;
  id?: number;
  state?: string;
  zip?: string;
};

export type AnonymousMapserver = {
  configurl?: string;
  description?: string;
  id?: number;
  name?: string;
  namespace?: string;
  namespacePrefix?: string;
  password?: string;
  pushStyleInWorkspace?: MapServer;
  pushStyleInWorkspace_JpaWorkaround?: string;
  stylerurl?: string;
  username?: string;
  wcsurl?: string;
  wfsurl?: string;
  wmsurl?: string;
};

export type Associated = {
  item?: Array<AssociatedSiblingMetadataItem>;
};

export type AssociatedRecord = {
  _id?: string;
  _source?: JsonNode;
  origin?: string;
  properties?: {
    [key: string]: string;
  };
};

export type AssociatedSiblingMetadataItem = {
  agg_isDescriptionOf?: Array<string>;
  agg_isTemporalStatOf?: Array<string>;
  agg_largerWorkCitation?: Array<string>;
  description: Description;
  hash?: string;
  id?: string;
  idx?: string;
  mdType: Array<string>;
  origin?: string;
  title: MultilingualValue;
  type?: string;
  url?: MultilingualValue;
};

export type AttributeTable = {
  element?: Array<FCRelatedElement>;
};

export type BatchEditParameter = {
  condition?: string;
  value: string;
  xpath: string;
};

export type BatchEditing = {
  section: Array<Section>;
};

export type Category = {
  id?: string;
  label?: string;
};

export type CategoryResponse = {
  label?: {
    [key: string]: string;
  };
};

export type Children = {
  item?: Array<RelatedMetadataItem>;
};

export type Codelist = {
  alias?: string;
  entry?: Array<Entry>;
  name?: string;
};

export type Crs = {
  authority?: string;
  code?: string;
  codeSpace?: string;
  description?: string;
  version?: string;
};

export type Dataset = {
  item?: Array<RelatedMetadataItem>;
};

export type Description = {
  value?: Array<LocalizedString>;
};

export type Direction = 'up' | 'down';

export type Element = {
  condition?: string;
  context?: string;
  description?: string;
  example?: string;
  help?: string;
  helper?: Helper;
  id?: number;
  label: string;
  name?: string;
};

export type Entry = {
  code: string;
  description: string;
  hideInEditMode?: string;
  label: string;
};

export type ExtentDto = {
  description?: string;
  href?: string;
  type?: string;
  xpath?: string;
};

export type FCRelatedElement = {
  code?: string;
  definition?: string;
  link?: string;
  name?: string;
  type?: string;
  values?: Array<Values>;
};

export type FCRelatedMetadataItem = {
  description: Description;
  featureType: FeatureType;
  hash?: string;
  id?: string;
  idx?: string;
  mdType: Array<string>;
  origin?: string;
  title: MultilingualValue;
  type?: string;
  url?: MultilingualValue;
};

export type Fcat = {
  item?: Array<FCRelatedMetadataItem>;
};

export type FeatureResponse = {
  decodeMap?: {
    [key: string]: Array<string>;
  };
};

export type FeatureType = {
  attributeTable?: AttributeTable;
};

export type Field = {
  codelist?: string;
  indexField?: string;
  insertMode?: string;
  name?: string;
  removable?: boolean;
  template?: string;
  use?: string;
  xpath?: string;
};

export type FormatterData = {
  id?: string;
  schema?: string;
};

export type FormatterDataResponse = {
  formatters?: Array<FormatterData>;
};

export type GrantedAuthority = {
  authority?: string;
};

/**
 * Group details
 */
export type Group = {
  allowedCategories?: Array<MetadataCategory>;
  defaultCategory?: MetadataCategory;
  description?: string;
  email?: string;
  enableAllowedCategories?: boolean;
  id?: number;
  label?: {
    [key: string]: string;
  };
  logo?: string;
  name?: string;
  referrer?: number;
  reserved?: boolean;
  website?: string;
};

export type GroupOperations = {
  group?: number;
  operations?: {
    [key: string]: boolean;
  };
};

export type GroupPrivilege = {
  group?: number;
  operations?: {
    [key: string]: boolean;
  };
  reserved?: boolean;
  userGroup?: boolean;
  userProfile?: Array<
    | 'Administrator'
    | 'UserAdmin'
    | 'Reviewer'
    | 'Editor'
    | 'RegisteredUser'
    | 'Guest'
    | 'Monitor'
  >;
  userProfiles?: Array<
    | 'Administrator'
    | 'UserAdmin'
    | 'Reviewer'
    | 'Editor'
    | 'RegisteredUser'
    | 'Guest'
    | 'Monitor'
  >;
};

export type Hasfeaturecats = {
  item?: Array<RelatedMetadataItem>;
};

export type Hassource = {
  item?: Array<RelatedMetadataItem>;
};

export type Helper = {
  displayIf?: string;
  editorMode?: string;
  option: Array<Option>;
  rel?: string;
  relAtt?: string;
  sort?: boolean;
};

export type IProcessingReport = {
  ellapsedTimeInSeconds?: number;
  endIsoDateTime?: string;
  running?: boolean;
  startIsoDateTime?: string;
  totalTimeInSeconds?: number;
  type?: string;
  uuid?: string;
};

export type ISODate = {
  dateAndTime?: string;
  dateAndTimeUtc?: string;
  dateAsString?: string;
  dateOnly?: boolean;
  dateYearMonthOnly?: boolean;
  dateYearOnly?: boolean;
  days?: number;
  hours?: number;
  internalDateTime?: string;
  minutes?: number;
  months?: number;
  seconds?: number;
  timeAsString?: string;
  timeInSeconds?: number;
  years?: number;
};

export type IndexResponse = {
  count?: number;
  success?: boolean;
};

export type InfoReport = {
  approved?: boolean;
  date?: string;
  draft?: boolean;
  message?: string;
  uuid?: string;
};

export type IsoLanguage = {
  code?: string;
  id?: number;
  label?: {
    [key: string]: string;
  };
  shortCode?: string;
};

export type JsonNode = {
  [key: string]: unknown;
};

export type Language = {
  id?: string;
  inspire?: boolean;
  inspire_JPAWorkaround?: string;
  name?: string;
};

export type Link = {
  id?: number;
  lastCheck?: ISODate;
  lastState?: number;
  linkStatus?: Array<LinkStatus>;
  linkType?: 'HTTP' | 'METADATA';
  protocol?: string;
  records?: Array<MetadataLink>;
  url?: string;
};

export type linkType = 'HTTP' | 'METADATA';

export type LinkFilter = {
  lastState?: string;
  records?: string;
  url?: string;
};

export type LinkStatus = {
  batchKey?: string;
  checkDate?: ISODate;
  failing?: boolean;
  id?: number;
  statusInfo?: string;
  statusValue?: string;
};

export type ListRegionsResponse = {
  categories?: {
    [key: string]: CategoryResponse;
  };
  count?: number;
  region?: Array<RegionResponse>;
  regions?: Array<RegionResponse>;
};

export type LocalizedString = {
  href?: string;
  lang?: string;
  value?: string;
};

export type LogFileResponse = {
  file?: string;
  name?: string;
};

/**
 * Mapserver details
 */
export type MapServer = {
  configurl?: string;
  description?: string;
  id?: number;
  name?: string;
  namespace?: string;
  namespacePrefix?: string;
  password?: string;
  pushStyleInWorkspace?: MapServer;
  pushStyleInWorkspace_JpaWorkaround?: string;
  stylerurl?: string;
  username?: string;
  wcsurl?: string;
  wfsurl?: string;
  wmsurl?: string;
};

export type MapService = {
  authType?: string;
  url?: string;
  urlType?: string;
  useProxy?: boolean;
};

export type MeResponse = {
  admin?: boolean;
  email?: string;
  groupsWithEditor?: Array<number>;
  groupsWithRegisteredUser?: Array<number>;
  groupsWithReviewer?: Array<number>;
  groupsWithUserAdmin?: Array<number>;
  hash?: string;
  id?: string;
  name?: string;
  organisation?: string;
  profile?: string;
  surname?: string;
  username?: string;
};

export type MetadataBatchApproveParameter = {
  bucket?: string;
  directApproval?: boolean;
  message?: string;
  uuids?: Array<string>;
};

export type MetadataBatchSubmitParameter = {
  bucket?: string;
  message?: string;
  uuids?: Array<string>;
};

export type MetadataCategory = {
  id?: number;
  label?: {
    [key: string]: string;
  };
  name?: string;
};

/**
 * Identifier template details
 */
export type MetadataIdentifierTemplate = {
  id?: number;
  name?: string;
  systemDefault?: boolean;
  systemProvided?: boolean;
  systemProvided_JPAWorkaround?: string;
  template?: string;
};

export type MetadataLink = {
  metadataId?: number;
  metadataUuid?: string;
};

export type MetadataProcessingReport = {
  ellapsedTimeInSeconds?: number;
  endIsoDateTime?: string;
  errors?: Array<Report>;
  infos?: Array<InfoReport>;
  metadata?: Array<number>;
  metadataErrors?: {
    [key: string]: Array<Report>;
  };
  metadataInfos?: {
    [key: string]: Array<InfoReport>;
  };
  numberOfNullRecords?: number;
  numberOfRecordNotFound?: number;
  numberOfRecords?: number;
  numberOfRecordsNotEditable?: number;
  numberOfRecordsProcessed?: number;
  numberOfRecordsUnchanged?: number;
  numberOfRecordsWithErrors?: number;
  running?: boolean;
  startIsoDateTime?: string;
  totalRecords?: number;
  totalTimeInSeconds?: number;
  type?: string;
  uuid?: string;
};

export type MetadataReplacementProcessingReport = {
  ellapsedTimeInSeconds?: number;
  endIsoDateTime?: string;
  errors?: Array<Report>;
  infos?: Array<InfoReport>;
  metadata?: Array<number>;
  metadataChanges?: {
    [key: string]: ReplaceReport;
  };
  metadataErrors?: {
    [key: string]: Array<Report>;
  };
  metadataInfos?: {
    [key: string]: Array<InfoReport>;
  };
  noProcessFoundCount?: number;
  numberOfNullRecords?: number;
  numberOfRecordNotFound?: number;
  numberOfRecords?: number;
  numberOfRecordsChanged?: number;
  numberOfRecordsNotChanged?: number;
  numberOfRecordsNotEditable?: number;
  numberOfRecordsProcessed?: number;
  numberOfRecordsUnchanged?: number;
  numberOfRecordsWithErrors?: number;
  processId?: string;
  running?: boolean;
  startIsoDateTime?: string;
  totalRecords?: number;
  totalTimeInSeconds?: number;
  type?: string;
  uuid?: string;
};

export type MetadataResource = {
  approved?: boolean;
  filename?: string;
  id?: string;
  lastModification?: string;
  metadataId?: number;
  metadataResourceExternalManagementProperties?: MetadataResourceExternalManagementProperties;
  metadataUuid?: string;
  size?: number;
  url?: string;
  version?: string;
  visibility?: 'PUBLIC' | 'PRIVATE';
};

export type visibility = 'PUBLIC' | 'PRIVATE';

export type MetadataResourceExternalManagementProperties = {
  id?: string;
  url?: string;
  validationStatus?: 'UNKNOWN' | 'VALID' | 'INCOMPLETE';
};

export type validationStatus = 'UNKNOWN' | 'VALID' | 'INCOMPLETE';

export type MetadataStatusDto = {
  changeDate?: ISODate;
  changeMessage?: string;
  closeDate?: ISODate;
  currentState?: string;
  dueDate?: ISODate;
  id?: number;
  metadataId?: number;
  owner?: number;
  previousState?: string;
  relatedMetadataStatusId?: number;
  statusValue?: StatusValue;
  titles?: {
    [key: string]: string;
  };
  userId?: number;
  uuid?: string;
};

/**
 * Metadata status
 */
export type MetadataStatusParameter = {
  changeMessage?: string;
  closeDate?: string;
  dueDate?: string;
  owner?: number;
  status?: number;
  type?: 'workflow' | 'task' | 'event';
};

export type type = 'workflow' | 'task' | 'event';

export type MetadataStatusResponse = {
  authorEmail?: string;
  authorName?: string;
  authorProfile?: string;
  changeDate?: ISODate;
  changeMessage?: string;
  closeDate?: ISODate;
  currentState?: string;
  currentStateEmpty?: boolean;
  currentStatus?: string;
  dateChange?: string;
  dateClose?: string;
  dateDue?: string;
  dueDate?: ISODate;
  id?: number;
  metadataId?: number;
  owner?: number;
  ownerEmail?: string;
  ownerName?: string;
  ownerProfile?: string;
  previousState?: string;
  previousStateEmpty?: boolean;
  previousStatus?: string;
  relatedMetadataStatusId?: number;
  statusId?: number;
  statusValue?: StatusValue;
  title?: string;
  titles?: {
    [key: string]: string;
  };
  userId?: number;
  uuid?: string;
};

export type MetadataWorkflowStatusResponse = {
  currentStatus?: MetadataStatusDto;
  hasEditPermission?: boolean;
  reviewers?: Array<User>;
  status?: Array<StatusValue>;
};

export type MultilingualValue = {
  value?: Array<LocalizedString>;
};

export type Online = {
  item?: Array<RelatedLinkItem>;
};

export type Operation = {
  id?: number;
  label?: {
    [key: string]: string;
  };
  name?: string;
  reserved?: boolean;
  reservedOperation?:
    | 'view'
    | 'download'
    | 'editing'
    | 'notify'
    | 'dynamic'
    | 'featured';
};

export type reservedOperation =
  | 'view'
  | 'download'
  | 'editing'
  | 'notify'
  | 'dynamic'
  | 'featured';

export type Option = {
  description?: string;
  isDefault?: boolean;
  label?: string;
  value?: string;
};

export type OwnerResponse = {
  id?: number;
  name?: string;
  records?: number;
};

export type PageLink = {
  content?: Array<Link>;
  empty?: boolean;
  first?: boolean;
  last?: boolean;
  number?: number;
  numberOfElements?: number;
  pageable?: PageableObject;
  size?: number;
  sort?: Array<SortObject>;
  totalElements?: number;
  totalPages?: number;
};

export type PageProperties = {
  content?: string;
  format?: 'LINK' | 'HTML' | 'HTMLPAGE' | 'TEXT';
  icon?: string;
  label?: string;
  language?: string;
  link?: string;
  pageId?: string;
  sections?: Array<
    | 'TOP'
    | 'FOOTER'
    | 'MENU'
    | 'SUBMENU'
    | 'CUSTOM_MENU1'
    | 'CUSTOM_MENU2'
    | 'CUSTOM_MENU3'
  >;
  status?: 'PUBLIC' | 'PUBLIC_ONLY' | 'PRIVATE' | 'HIDDEN';
};

export type format = 'LINK' | 'HTML' | 'HTMLPAGE' | 'TEXT';

export type status = 'PUBLIC' | 'PUBLIC_ONLY' | 'PRIVATE' | 'HIDDEN';

export type PageableObject = {
  offset?: number;
  pageNumber?: number;
  pageSize?: number;
  paged?: boolean;
  sort?: Array<SortObject>;
  unpaged?: boolean;
};

export type PaginatedUserSearchResponse = {
  rows?: Array<UserSearchDto>;
  total?: number;
};

export type Parent = {
  item?: Array<RelatedMetadataItem>;
};

export type PasswordResetDto = {
  password?: string;
  password2?: string;
  passwordOld?: string;
};

/**
 * The new password and a valid change key
 */
export type PasswordUpdateParameter = {
  changeKey?: string;
  password?: string;
};

export type Pattern = {
  rules: Rules;
  title: string;
};

export type Patterns = {
  pattern: Array<Pattern>;
};

export type ProcessingReport = {
  ellapsedTimeInSeconds?: number;
  endIsoDateTime?: string;
  errors?: Array<Report>;
  infos?: Array<InfoReport>;
  running?: boolean;
  startIsoDateTime?: string;
  totalTimeInSeconds?: number;
  type?: string;
  uuid?: string;
};

export type ProxyConfiguration = {
  enabled?: boolean;
  host?: string;
  ignoreHostList?: string;
  password?: string;
  port?: string;
  proxyConfiguredInSystemProperties?: boolean;
  username?: string;
};

export type PublicationOption = {
  additionalPublications?: {
    [key: string]: Array<ReservedOperation>;
  };
  name?: string;
  publicationGroup?: ReservedGroup;
  publicationOperations?: Array<ReservedOperation>;
};

export type RatingAverage = {
  lastComment?: string;
  ratingAverages?: {
    [key: string]: number;
  };
  ratingCount?: number;
  userfeedbackCount?: number;
};

export type RatingCriteria = {
  id?: number;
  internal?: boolean;
  label?: {
    [key: string]: string;
  };
  name?: string;
};

export type RegionResponse = {
  categoryId?: string;
  east?: number;
  hasGeom?: boolean;
  id?: string;
  label?: {
    [key: string]: string;
  };
  north?: number;
  south?: number;
  west?: number;
};

export type Related = {
  item?: Array<RelatedMetadataItem>;
};

export type RelatedItemType =
  | 'children'
  | 'parent'
  | 'brothersAndSisters'
  | 'siblings'
  | 'associated'
  | 'services'
  | 'datasets'
  | 'fcats'
  | 'hasfeaturecats'
  | 'sources'
  | 'hassources'
  | 'related'
  | 'onlines'
  | 'thumbnails';

export type RelatedLinkItem = {
  applicationProfile?: string;
  description: Description;
  function?: string;
  hash?: string;
  id?: string;
  idx?: string;
  mimeType?: string;
  protocol?: string;
  title: MultilingualValue;
  type?: string;
  url?: MultilingualValue;
};

export type RelatedMetadataItem = {
  description: Description;
  hash?: string;
  id?: string;
  idx?: string;
  mdType: Array<string>;
  origin?: string;
  title: MultilingualValue;
  type?: string;
  url?: MultilingualValue;
};

export type RelatedResponse = {
  associated?: Associated;
  children?: Children;
  datasets?: Dataset;
  fcats?: Fcat;
  hasfeaturecats?: Hasfeaturecats;
  hassources?: Hassource;
  onlines?: Online;
  parent?: Parent;
  related?: Related;
  services?: Service;
  siblings?: Siblings;
  sources?: RelatedSource;
  thumbnails?: Thumbnail;
};

export type RelatedSiblingMetadataItem = {
  associationType: string;
  description: Description;
  hash?: string;
  id?: string;
  idx?: string;
  initiativeType: string;
  mdType: Array<string>;
  origin?: string;
  title: MultilingualValue;
  type?: string;
  url?: MultilingualValue;
};

export type RelatedSource = {
  item?: Array<RelatedMetadataItem>;
};

export type RelatedThumbnailItem = {
  hash?: string;
  id?: string;
  idx?: string;
  title: MultilingualValue;
  type?: string;
  url?: MultilingualValue;
};

export type ReplaceEntryChange = {
  changedVal?: string;
  fieldId?: string;
  originalVal?: string;
};

export type ReplaceReport = {
  approved?: boolean;
  date?: string;
  draft?: boolean;
  elementChanges?: Array<ReplaceEntryChange>;
  message?: string;
  uuid?: string;
};

export type Report = {
  approved?: boolean;
  date?: string;
  draft?: boolean;
  message?: string;
  uuid?: string;
};

export type Reports = {
  report?: Array<ValidationReport>;
};

export type ReservedGroup = 'all' | 'intranet' | 'guest';

export type ReservedOperation =
  | 'view'
  | 'download'
  | 'editing'
  | 'notify'
  | 'dynamic'
  | 'featured';

export type Rule = {
  details: string;
  group?: string;
  id?: string;
  msg?: string;
  ref?: string;
  test?: string;
  type?: string;
};

export type Rules = {
  rule?: Array<Rule>;
};

export type SavedQuery = {
  cleanValues?: string;
  id?: string;
  label?: string;
  parameters?: Array<string>;
  xpath?: string;
};

export type Section = {
  field: Array<Field>;
  name?: string;
};

export type Selection = {
  id?: number;
  label?: {
    [key: string]: string;
  };
  name?: string;
  watchable?: boolean;
};

export type Service = {
  item?: Array<RelatedMetadataItem>;
};

export type Setting = {
  dataType?: 'STRING' | 'INT' | 'BOOLEAN' | 'JSON';
  editable?: boolean;
  editable_JpaWorkaround?: string;
  encrypted?: boolean;
  encrypted_JpaWorkaround?: string;
  internal?: boolean;
  internal_JpaWorkaround?: string;
  name?: string;
  position?: number;
  storedValue?: string;
  value?: string;
};

export type dataType = 'STRING' | 'INT' | 'BOOLEAN' | 'JSON';

export type SettingsListResponse = {
  settings?: Array<Setting>;
};

/**
 * Privileges
 */
export type SharingParameter = {
  clear?: boolean;
  privileges?: Array<GroupOperations>;
};

export type SharingResponse = {
  groupOwner?: string;
  owner?: string;
  privileges?: Array<GroupPrivilege>;
};

export type Siblings = {
  item?: Array<RelatedSiblingMetadataItem>;
};

export type SimpleMetadataProcessingReport = {
  ellapsedTimeInSeconds?: number;
  endIsoDateTime?: string;
  errors?: Array<Report>;
  infos?: Array<InfoReport>;
  metadata?: Array<number>;
  metadataErrors?: {
    [key: string]: Array<Report>;
  };
  metadataInfos?: {
    [key: string]: Array<InfoReport>;
  };
  numberOfNullRecords?: number;
  numberOfRecordNotFound?: number;
  numberOfRecords?: number;
  numberOfRecordsNotEditable?: number;
  numberOfRecordsProcessed?: number;
  numberOfRecordsUnchanged?: number;
  numberOfRecordsWithErrors?: number;
  running?: boolean;
  startIsoDateTime?: string;
  totalRecords?: number;
  totalTimeInSeconds?: number;
  type?: string;
  uuid?: string;
};

export type SiteInformation = {
  catalogue?: {
    [key: string]: string;
  };
  database?: {
    [key: string]: string;
  };
  env?: {
    [key: string]: string;
  };
  index?: {
    [key: string]: string;
  };
  main?: {
    [key: string]: string;
  };
  version?: {
    [key: string]: string;
  };
};

export type SortObject = {
  ascending?: boolean;
  direction?: string;
  ignoreCase?: boolean;
  nullHandling?: string;
  property?: string;
};

export type Source = {
  creationDate?: ISODate;
  filter?: string;
  groupOwner?: number;
  label?: {
    [key: string]: string;
  };
  listableInHeaderSelector?: boolean;
  logo?: string;
  name?: string;
  serviceRecord?: string;
  type?: 'portal' | 'subportal' | 'externalportal' | 'harvester';
  uiConfig?: string;
  uuid?: string;
};

export type type2 = 'portal' | 'subportal' | 'externalportal' | 'harvester';

export type Status = {
  date?: string;
  id?: string;
  message?: string;
  state?: 'RED' | 'UNINITIALIZED' | 'YELLOW' | 'GREEN' | 'DISABLED';
};

export type state = 'RED' | 'UNINITIALIZED' | 'YELLOW' | 'GREEN' | 'DISABLED';

export type StatusValue = {
  displayOrder?: number;
  id?: number;
  label?: {
    [key: string]: string;
  };
  name?: string;
  notificationLevel?:
    | 'statusUserOwner'
    | 'catalogueAdministrator'
    | 'catalogueProfileAdministrator'
    | 'catalogueProfileUserAdmin'
    | 'catalogueProfileReviewer'
    | 'catalogueProfileEditor'
    | 'catalogueProfileRegisteredUser'
    | 'catalogueProfileGuest'
    | 'recordProfileReviewer'
    | 'recordUserAuthor'
    | 'recordGroupEmail';
  reserved?: boolean;
  reserved_JpaWorkaround?: string;
  type?: 'workflow' | 'task' | 'event';
};

export type notificationLevel =
  | 'statusUserOwner'
  | 'catalogueAdministrator'
  | 'catalogueProfileAdministrator'
  | 'catalogueProfileUserAdmin'
  | 'catalogueProfileReviewer'
  | 'catalogueProfileEditor'
  | 'catalogueProfileRegisteredUser'
  | 'catalogueProfileGuest'
  | 'recordProfileReviewer'
  | 'recordUserAuthor'
  | 'recordGroupEmail';

export type SuggestionType = {
  category?: string;
  id?: string;
  name: string;
  operational: string;
  params?: string;
  process?: string;
  target?: string;
};

export type SystemInfo = {
  buildDate?: string;
  buildJavaVendor?: string;
  buildJavaVersion?: string;
  buildOsInfo?: string;
  devMode?: boolean;
  scmRevision?: string;
  scmUrl?: string;
  stagingProfile?: string;
  subVersion?: string;
  version?: string;
};

/**
 * Thesaurus information
 */
export type ThesaurusInfo = {
  defaultNamespace?: string;
  description?: string;
  dname?: string;
  filename?: string;
  multilingualDescriptions?: {
    [key: string]: string;
  };
  multilingualTitles?: {
    [key: string]: string;
  };
  title?: string;
  type?: string;
};

export type Thumbnail = {
  item?: Array<RelatedThumbnailItem>;
};

export type TransferRequest = {
  sourceGroup?: number;
  sourceUser?: number;
  targetGroup?: number;
  targetUser?: number;
};

export type Translations = {
  fieldName?: string;
  id?: number;
  langId?: string;
  value?: string;
};

export type UiSetting = {
  configuration?: string;
  id?: string;
};

export type User = {
  accountNonExpired?: boolean;
  accountNonLocked?: boolean;
  addresses?: Array<Address>;
  authorities?: Array<GrantedAuthority>;
  credentialsNonExpired?: boolean;
  email?: string;
  emailAddresses?: Array<string>;
  enabled?: boolean;
  id?: number;
  kind?: string;
  lastLoginDate?: string;
  name?: string;
  organisation?: string;
  primaryAddress?: Address;
  profile?:
    | 'Administrator'
    | 'UserAdmin'
    | 'Reviewer'
    | 'Editor'
    | 'RegisteredUser'
    | 'Guest'
    | 'Monitor';
  security?: UserSecurity;
  surname?: string;
  username?: string;
};

export type profile =
  | 'Administrator'
  | 'UserAdmin'
  | 'Reviewer'
  | 'Editor'
  | 'RegisteredUser'
  | 'Guest'
  | 'Monitor';

export type UserDto = {
  addresses?: Array<Address>;
  email?: UserDto;
  emailAddresses?: Array<string>;
  enabled?: boolean;
  groupsEditor?: Array<string>;
  groupsRegisteredUser?: Array<string>;
  groupsReviewer?: Array<string>;
  groupsUserAdmin?: Array<string>;
  id?: string;
  kind?: string;
  name?: string;
  organisation?: string;
  password?: string;
  profile?: string;
  surname?: string;
  username?: string;
};

export type UserFeedbackDTO = {
  approverName?: string;
  authorEmail?: string;
  authorName?: string;
  authorOrganization?: string;
  authorUserId?: number;
  captcha?: string;
  comment?: string;
  date?: string;
  keywords?: Array<string>;
  metadataTitle?: string;
  metadataUUID?: string;
  optionPrivacy?: boolean;
  parentUuid?: string;
  published?: boolean;
  rating?: {
    [key: string]: number;
  };
  ratingAVG?: number;
  showApproveButton?: boolean;
  uuid?: string;
};

export type UserGroup = {
  group?: Group;
  id?: UserGroupId;
  profile?:
    | 'Administrator'
    | 'UserAdmin'
    | 'Reviewer'
    | 'Editor'
    | 'RegisteredUser'
    | 'Guest'
    | 'Monitor';
  user?: User;
};

export type UserGroupId = {
  groupId?: number;
  profile?:
    | 'Administrator'
    | 'UserAdmin'
    | 'Reviewer'
    | 'Editor'
    | 'RegisteredUser'
    | 'Guest'
    | 'Monitor';
  userId?: number;
};

export type UserGroupsResponse = {
  groupId?: number;
  groupName?: string;
  userId?: number;
  userName?: string;
  userProfile?: string;
};

/**
 * User details
 */
export type UserRegisterDto = {
  address?: Address;
  captcha?: string;
  email?: string;
  name?: string;
  organisation?: string;
  profile?: string;
  surname?: string;
  username?: string;
};

/**
 * User search details
 */
export type UserSearchDto = {
  creationDate?: string;
  creator?: string;
  creatorId?: number;
  featuredType?: string;
  groups?: Array<number>;
  id?: number;
  logo?: string;
  names?: {
    [key: string]: string;
  };
  url?: string;
};

export type UserSecurity = {
  authType?: string;
  nodeId?: string;
  securityNotifications?: Array<'UPDATE_HASH_REQUIRED' | 'UNKNOWN'>;
  securityNotificationsString?: UserSecurity;
};

export type ValidationReport = {
  displayPriority: number;
  error: number;
  id: string;
  label: string;
  patterns: Patterns;
  requirement: string;
  schematronVerificationError?: string;
  success: string;
  total: string;
};

export type Values = {
  code?: string;
  definition?: string;
  label?: string;
};

export type XsltMetadataProcessingReport = {
  ellapsedTimeInSeconds?: number;
  endIsoDateTime?: string;
  errors?: Array<Report>;
  infos?: Array<InfoReport>;
  metadata?: Array<number>;
  metadataErrors?: {
    [key: string]: Array<Report>;
  };
  metadataInfos?: {
    [key: string]: Array<InfoReport>;
  };
  noProcessFoundCount?: number;
  numberOfNullRecords?: number;
  numberOfRecordNotFound?: number;
  numberOfRecords?: number;
  numberOfRecordsNotEditable?: number;
  numberOfRecordsProcessed?: number;
  numberOfRecordsUnchanged?: number;
  numberOfRecordsWithErrors?: number;
  processId?: string;
  running?: boolean;
  startIsoDateTime?: string;
  totalRecords?: number;
  totalTimeInSeconds?: number;
  type?: string;
  uuid?: string;
};

export type DescribeResourceData = {
  /**
   * fileIdentifier
   */
  fileIdentifier?: string;
  /**
   * spatial_dataset_identifier_code
   */
  spatialDatasetIdentifierCode?: string;
  /**
   * spatial_dataset_identifier_namespace
   */
  spatialDatasetIdentifierNamespace?: string;
};

export type DescribeResourceResponse = unknown | void;

export type DescribeData = {
  /**
   * metadataUuid
   */
  metadataUuid: string;
};

export type DescribeResponse = unknown | void;

export type DownloadResourceData = {
  /**
   * crs
   */
  crs: string;
  /**
   * spatial_dataset_identifier_code
   */
  spatialDatasetIdentifierCode: string;
  /**
   * spatial_dataset_identifier_namespace
   */
  spatialDatasetIdentifierNamespace: string;
};

export type DownloadResourceResponse = unknown | void;

export type FeedsData = {
  /**
   * fileIdentifier
   */
  fileIdentifier?: string;
};

export type FeedsResponse = {
  [key: string]: unknown;
};

export type ScanResponse = {
  [key: string]: unknown;
};

export type GetCssStyleResponse = {
  [key: string]: string;
};

export type SaveCssStyleData = {
  requestBody: string;
};

export type SaveCssStyleResponse = string;

export type ListFormattersData = {
  id?: string;
  pluginOnly?: boolean;
  publishedOnly?: boolean;
  schema?: string;
  uuid?: string;
};

export type ListFormattersResponse = FormatterDataResponse;

export type AddFormatterData = {
  file: Array<Blob | File>;
};

export type AddFormatterResponse = unknown;

export type ClearFormatterCacheResponse = void;

export type DeleteFormatterData = {
  formatter: string;
  schema: string;
};

export type DeleteFormatterResponse = void;

export type DownloadFormatterData = {
  formatter: string;
  schema: string;
};

export type DownloadFormatterResponse = unknown;

export type GetFormatterFilesData = {
  formatter: string;
  schema: string;
};

export type GetFormatterFilesResponse = string;

export type GetFormatterFileContentData = {
  file: string;
  formatter: string;
  schema: string;
};

export type GetFormatterFileContentResponse = string;

export type UpdateFormatterFileData = {
  data: string;
  file: string;
  formatter: string;
  schema: string;
};

export type UpdateFormatterFileResponse = unknown;

export type GetGroupsData = {
  /**
   * For a specific profile
   */
  profile?: string;
  /**
   * Including Internet, Intranet, Guest groups or not
   */
  withReservedGroup?: boolean;
};

export type GetGroupsResponse = Array<Group>;

export type AddGroupData = {
  requestBody: Group;
};

export type AddGroupResponse = number;

export type DeleteGroupData = {
  /**
   * Force removal even if records are assigned to that group.
   */
  force?: boolean;
  /**
   * Group identifier.
   */
  groupIdentifier: number;
};

export type DeleteGroupResponse = void;

export type GetGroupData = {
  /**
   * Group identifier
   */
  groupIdentifier: number;
};

export type GetGroupResponse = Group;

export type UpdateGroupData = {
  /**
   * Group identifier
   */
  groupIdentifier: number;
  requestBody: Group;
};

export type UpdateGroupResponse = void;

export type GetGroupUsersData = {
  /**
   * Group identifier
   */
  groupIdentifier: number;
};

export type GetGroupUsersResponse = Array<User>;

export type GetGroupLogoData = {
  /**
   * Group identifier
   */
  groupId: number;
};

export type GetGroupLogoResponse = unknown;

export type CheckHarvesterPropertyExistData = {
  /**
   * The value to search
   */
  exist: string;
  /**
   * The harvester property to check
   */
  property: string;
};

export type CheckHarvesterPropertyExistResponse =
  | 'CONTINUE'
  | 'SWITCHING_PROTOCOLS'
  | 'PROCESSING'
  | 'CHECKPOINT'
  | 'OK'
  | 'CREATED'
  | 'ACCEPTED'
  | 'NON_AUTHORITATIVE_INFORMATION'
  | 'NO_CONTENT'
  | 'RESET_CONTENT'
  | 'PARTIAL_CONTENT'
  | 'MULTI_STATUS'
  | 'ALREADY_REPORTED'
  | 'IM_USED'
  | 'MULTIPLE_CHOICES'
  | 'MOVED_PERMANENTLY'
  | 'FOUND'
  | 'MOVED_TEMPORARILY'
  | 'SEE_OTHER'
  | 'NOT_MODIFIED'
  | 'USE_PROXY'
  | 'TEMPORARY_REDIRECT'
  | 'PERMANENT_REDIRECT'
  | 'BAD_REQUEST'
  | 'UNAUTHORIZED'
  | 'PAYMENT_REQUIRED'
  | 'FORBIDDEN'
  | 'NOT_FOUND'
  | 'METHOD_NOT_ALLOWED'
  | 'NOT_ACCEPTABLE'
  | 'PROXY_AUTHENTICATION_REQUIRED'
  | 'REQUEST_TIMEOUT'
  | 'CONFLICT'
  | 'GONE'
  | 'LENGTH_REQUIRED'
  | 'PRECONDITION_FAILED'
  | 'PAYLOAD_TOO_LARGE'
  | 'REQUEST_ENTITY_TOO_LARGE'
  | 'URI_TOO_LONG'
  | 'REQUEST_URI_TOO_LONG'
  | 'UNSUPPORTED_MEDIA_TYPE'
  | 'REQUESTED_RANGE_NOT_SATISFIABLE'
  | 'EXPECTATION_FAILED'
  | 'I_AM_A_TEAPOT'
  | 'INSUFFICIENT_SPACE_ON_RESOURCE'
  | 'METHOD_FAILURE'
  | 'DESTINATION_LOCKED'
  | 'UNPROCESSABLE_ENTITY'
  | 'LOCKED'
  | 'FAILED_DEPENDENCY'
  | 'TOO_EARLY'
  | 'UPGRADE_REQUIRED'
  | 'PRECONDITION_REQUIRED'
  | 'TOO_MANY_REQUESTS'
  | 'REQUEST_HEADER_FIELDS_TOO_LARGE'
  | 'UNAVAILABLE_FOR_LEGAL_REASONS'
  | 'INTERNAL_SERVER_ERROR'
  | 'NOT_IMPLEMENTED'
  | 'BAD_GATEWAY'
  | 'SERVICE_UNAVAILABLE'
  | 'GATEWAY_TIMEOUT'
  | 'HTTP_VERSION_NOT_SUPPORTED'
  | 'VARIANT_ALSO_NEGOTIATES'
  | 'INSUFFICIENT_STORAGE'
  | 'LOOP_DETECTED'
  | 'BANDWIDTH_LIMIT_EXCEEDED'
  | 'NOT_EXTENDED'
  | 'NETWORK_AUTHENTICATION_REQUIRED';

export type AssignHarvestedRecordToSourceData = {
  /**
   * The harvester UUID
   */
  harvesterUuid: string;
  /**
   * The target source UUID
   */
  source: string;
};

export type AssignHarvestedRecordToSourceResponse =
  | 'CONTINUE'
  | 'SWITCHING_PROTOCOLS'
  | 'PROCESSING'
  | 'CHECKPOINT'
  | 'OK'
  | 'CREATED'
  | 'ACCEPTED'
  | 'NON_AUTHORITATIVE_INFORMATION'
  | 'NO_CONTENT'
  | 'RESET_CONTENT'
  | 'PARTIAL_CONTENT'
  | 'MULTI_STATUS'
  | 'ALREADY_REPORTED'
  | 'IM_USED'
  | 'MULTIPLE_CHOICES'
  | 'MOVED_PERMANENTLY'
  | 'FOUND'
  | 'MOVED_TEMPORARILY'
  | 'SEE_OTHER'
  | 'NOT_MODIFIED'
  | 'USE_PROXY'
  | 'TEMPORARY_REDIRECT'
  | 'PERMANENT_REDIRECT'
  | 'BAD_REQUEST'
  | 'UNAUTHORIZED'
  | 'PAYMENT_REQUIRED'
  | 'FORBIDDEN'
  | 'NOT_FOUND'
  | 'METHOD_NOT_ALLOWED'
  | 'NOT_ACCEPTABLE'
  | 'PROXY_AUTHENTICATION_REQUIRED'
  | 'REQUEST_TIMEOUT'
  | 'CONFLICT'
  | 'GONE'
  | 'LENGTH_REQUIRED'
  | 'PRECONDITION_FAILED'
  | 'PAYLOAD_TOO_LARGE'
  | 'REQUEST_ENTITY_TOO_LARGE'
  | 'URI_TOO_LONG'
  | 'REQUEST_URI_TOO_LONG'
  | 'UNSUPPORTED_MEDIA_TYPE'
  | 'REQUESTED_RANGE_NOT_SATISFIABLE'
  | 'EXPECTATION_FAILED'
  | 'I_AM_A_TEAPOT'
  | 'INSUFFICIENT_SPACE_ON_RESOURCE'
  | 'METHOD_FAILURE'
  | 'DESTINATION_LOCKED'
  | 'UNPROCESSABLE_ENTITY'
  | 'LOCKED'
  | 'FAILED_DEPENDENCY'
  | 'TOO_EARLY'
  | 'UPGRADE_REQUIRED'
  | 'PRECONDITION_REQUIRED'
  | 'TOO_MANY_REQUESTS'
  | 'REQUEST_HEADER_FIELDS_TOO_LARGE'
  | 'UNAVAILABLE_FOR_LEGAL_REASONS'
  | 'INTERNAL_SERVER_ERROR'
  | 'NOT_IMPLEMENTED'
  | 'BAD_GATEWAY'
  | 'SERVICE_UNAVAILABLE'
  | 'GATEWAY_TIMEOUT'
  | 'HTTP_VERSION_NOT_SUPPORTED'
  | 'VARIANT_ALSO_NEGOTIATES'
  | 'INSUFFICIENT_STORAGE'
  | 'LOOP_DETECTED'
  | 'BANDWIDTH_LIMIT_EXCEEDED'
  | 'NOT_EXTENDED'
  | 'NETWORK_AUTHENTICATION_REQUIRED';

export type CleanTranslationsPackagesCacheResponse = unknown;

export type GetTranslationsData = {
  type?: Array<string>;
};

export type GetTranslationsResponse = {
  [key: string]: string;
};

export type GetCustomTranslationsData = {
  type?: Array<string>;
};

export type GetCustomTranslationsResponse = Array<Translations>;

export type RemoveAllTranslationsResponse = unknown;

export type GetDbTranslationsResponse = {
  [key: string]: string;
};

export type AddTranslationsData = {
  replace?: boolean;
  requestBody: Array<Translations>;
};

export type AddTranslationsResponse = string;

export type DeleteTranslationsData = {
  /**
   * Untranslated key for which all translations will be deleted.
   */
  key: string;
};

export type DeleteTranslationsResponse = unknown;

export type AddTranslationsForData = {
  /**
   * Untranslated key for which translations are provided.
   */
  key: string;
  /**
   * Set to `true` to erase all existing translations for that key
   */
  replace?: boolean;
  /**
   * An object where keys are valid 3-letter language codes (e.g. `eng` or `fre`) and values are custom translations for the corresponding language.
   */
  requestBody: {
    [key: string]: string;
  };
};

export type AddTranslationsForResponse = string;

export type GetTranslationsPackagesResponse = {
  [key: string]: Array<string>;
};

export type GetTranslationsPackageData = {
  pack: string;
};

export type GetTranslationsPackageResponse = {
  [key: string]: string;
};

export type GetIdentifiersData = {
  /**
   * Only user defined ones
   */
  userDefinedOnly?: boolean;
};

export type GetIdentifiersResponse = Array<MetadataIdentifierTemplate>;

export type AddIdentifierData = {
  requestBody: MetadataIdentifierTemplate;
};

export type AddIdentifierResponse = number;

export type DeleteIdentifierData = {
  /**
   * Identifier template identifier
   */
  identifier: number;
};

export type DeleteIdentifierResponse = void;

export type UpdateIdentifierData = {
  /**
   * Identifier template identifier
   */
  identifier: number;
  requestBody: MetadataIdentifierTemplate;
};

export type UpdateIdentifierResponse = void;

export type GetIsoLanguagesResponse = Array<IsoLanguage>;

export type GetLanguagesResponse = Array<Language>;

export type GetApplicationLanguagesResponse = Array<Language>;

export type DeleteLanguageData = {
  /**
   * ISO 3 letter code
   */
  langCode: string;
};

export type DeleteLanguageResponse = void;

export type AddLanguagesData = {
  /**
   * ISO 3 letter code
   */
  langCode: string;
};

export type AddLanguagesResponse = unknown;

export type GetLogosResponse = Array<string>;

export type AddLogoData = {
  /**
   * The logo image to upload
   */
  file: Array<Blob | File>;
  /**
   * Overwrite if exists
   */
  overwrite?: boolean;
};

export type AddLogoResponse = string;

export type DeleteLogoData = {
  /**
   * The logo filename to delete
   */
  file: string;
};

export type DeleteLogoResponse = void;

export type GetLogoData = {
  /**
   * The logo filename
   */
  file: string;
};

export type GetLogoResponse = unknown;

export type GetMapserversResponse = Array<AnonymousMapserver>;

export type AddMapserverData = {
  requestBody: MapServer;
};

export type AddMapserverResponse = number;

export type DeleteMapserverData = {
  /**
   * Mapserver identifier
   */
  mapserverId: number;
};

export type DeleteMapserverResponse = void;

export type GetMapserverData = {
  /**
   * Mapserver identifier
   */
  mapserverId: string;
};

export type UpdateMapserverData = {
  /**
   * Mapserver identifier
   */
  mapserverId: number;
  requestBody: MapServer;
};

export type UpdateMapserverResponse = void;

export type UpdateMapserverAuthData = {
  /**
   * Mapserver identifier
   */
  mapserverId: number;
  /**
   * Password
   */
  password: string;
  /**
   * User name
   */
  username: string;
};

export type UpdateMapserverAuthResponse = void;

export type DeleteMapserverResourceData = {
  /**
   * Mapserver identifier
   */
  mapserverId: string;
  /**
   * Metadata abstract
   */
  metadataAbstract?: string;
  /**
   * Metadata title
   */
  metadataTitle?: string;
  /**
   * Record UUID.
   */
  metadataUuid: string;
  /**
   * Resource name (could be a file or a db connection)
   */
  resource: string;
};

export type GetMapserverResourceData = {
  /**
   * Mapserver identifier
   */
  mapserverId: string;
  /**
   * Metadata abstract
   */
  metadataAbstract?: string;
  /**
   * Metadata title
   */
  metadataTitle?: string;
  /**
   * Record UUID.
   */
  metadataUuid: string;
  /**
   * Resource name (could be a file or a db connection)
   */
  resource: string;
};

export type PublishMapserverResourceData = {
  /**
   * Mapserver identifier
   */
  mapserverId: string;
  /**
   * Metadata abstract
   */
  metadataAbstract?: string;
  /**
   * Metadata title
   */
  metadataTitle?: string;
  /**
   * Record UUID.
   */
  metadataUuid: string;
  /**
   * Resource name (could be a file or a db connection)
   */
  resource: string;
};

export type GetMapservicesResponse = Array<MapService>;

export type GetMeResponse = MeResponse;

export type GetOperationsResponse = Array<Operation>;

export type ListPagesData = {
  format?: 'LINK' | 'HTML' | 'HTMLPAGE' | 'TEXT';
  language?: string;
  section?:
    | 'TOP'
    | 'FOOTER'
    | 'MENU'
    | 'SUBMENU'
    | 'CUSTOM_MENU1'
    | 'CUSTOM_MENU2'
    | 'CUSTOM_MENU3';
};

export type AddPageUploadingFileData = {
  format?: 'LINK' | 'HTML' | 'HTMLPAGE' | 'TEXT';
  formData?: {
    data: Blob | File;
  };
  language: string;
  pageId: string;
  sections?: Array<
    | 'TOP'
    | 'FOOTER'
    | 'MENU'
    | 'SUBMENU'
    | 'CUSTOM_MENU1'
    | 'CUSTOM_MENU2'
    | 'CUSTOM_MENU3'
  >;
  status?: 'PUBLIC' | 'PUBLIC_ONLY' | 'PRIVATE' | 'HIDDEN';
};

export type AddPageUploadingFileResponse = string;

export type AddPageWithoutUploadingFileData = {
  requestBody: PageProperties;
};

export type AddPageWithoutUploadingFileResponse = string;

export type GetPageFormatsResponse = Array<
  'LINK' | 'HTML' | 'HTMLPAGE' | 'TEXT'
>;

export type GetPageSectionsResponse = Array<
  | 'TOP'
  | 'FOOTER'
  | 'MENU'
  | 'SUBMENU'
  | 'CUSTOM_MENU1'
  | 'CUSTOM_MENU2'
  | 'CUSTOM_MENU3'
>;

export type GetPageStatusResponse = Array<
  'PUBLIC' | 'PUBLIC_ONLY' | 'PRIVATE' | 'HIDDEN'
>;

export type DeletePageData = {
  language: string;
  pageId: string;
};

export type DeletePageResponse = unknown;

export type GetPageData = {
  language: string;
  pageId: string;
};

export type GetPageResponse = PageProperties;

export type UpdatePageData = {
  language: string;
  pageId: string;
  requestBody: PageProperties;
};

export type UpdatePageResponse = unknown;

export type GetPageContentData = {
  language: string;
  pageId: string;
};

export type GetPageContentResponse = string;

export type PreviewProcessSearchAndReplaceData = {
  /**
   * Selection bucket name
   */
  bucket?: string;
  /**
   * Return differences with diff, diffhtml or patch
   */
  diffType?: 'patch' | 'diff' | 'diffhtml';
  /**
   * regexpFlags
   */
  regexpFlags?: string;
  /**
   * Replacement
   */
  replace?: string;
  /**
   * Value to search for
   */
  search: string;
  /**
   * Use regular expression (may not be supported by all databases - tested with H2 and PostgreSQL)
   */
  useRegexp?: boolean;
  /**
   * Record UUIDs. If null current selection is used.
   */
  uuids?: Array<string>;
};

export type PreviewProcessSearchAndReplaceResponse = {
  [key: string]: unknown;
};

export type ProcessSearchAndReplaceData = {
  /**
   * Selection bucket name
   */
  bucket?: string;
  /**
   * Index after processing
   */
  index?: boolean;
  /**
   * regexpFlags
   */
  regexpFlags?: string;
  /**
   * Replacement
   */
  replace?: string;
  /**
   * Value to search for
   */
  search: string;
  /**
   * If true updates the DateStamp (or equivalent in standards different to ISO 19139) field in the metadata with the current timestamp
   */
  updateDateStamp?: boolean;
  /**
   * Use regular expression (may not be supported by all databases - tested with H2 and PostgreSQL)
   */
  useRegexp?: boolean;
  /**
   * Record UUIDs. If null current selection is used.
   */
  uuids?: Array<string>;
};

export type ProcessSearchAndReplaceResponse = XsltMetadataProcessingReport;

export type DeleteResponse = void;

export type GetProcessReportResponse = Array<ProcessingReport>;

export type SearchAndReplaceData = {
  /**
   * Selection bucket name
   */
  bucket?: string;
  /**
   * Case insensitive search.
   */
  isCaseInsensitive?: boolean;
  /**
   * Test only (ie. metadata are not saved). Return the report only.
   */
  isTesting?: boolean;
  process?: string;
  /**
   * Record UUIDs. If null current selection is used.
   */
  uuids?: Array<string>;
  /**
   * 'record' to apply vacuum.xsl, 'element' to remove empty elements. Empty to not affect empty elements.
   */
  vacuumMode?: string;
};

export type SearchAndReplaceResponse = MetadataReplacementProcessingReport;

export type PreviewProcessRecordsData = {
  /**
   * Append documents before processing
   */
  appendFirst?: boolean;
  /**
   * Apply update fixed info
   */
  applyUpdateFixedInfo?: boolean;
  /**
   * Selection bucket name
   */
  bucket?: string;
  /**
   * Return differences with diff, diffhtml or patch
   */
  diffType?: 'patch' | 'diff' | 'diffhtml';
  /**
   * Process identifier
   */
  process: string;
  /**
   * Record UUIDs. If null current selection is used.
   */
  uuids?: Array<string>;
};

export type PreviewProcessRecordsResponse = {
  [key: string]: unknown;
};

export type ProcessRecordsData = {
  /**
   * Selection bucket name
   */
  bucket?: string;
  /**
   * Index after processing
   */
  index?: boolean;
  /**
   * Process identifier
   */
  process: string;
  /**
   * If true updates the DateStamp (or equivalent in standards different to ISO 19139) field in the metadata with the current timestamp
   */
  updateDateStamp?: boolean;
  /**
   * Record UUIDs. If null current selection is used.
   */
  uuids?: Array<string>;
};

export type ProcessRecordsResponse = XsltMetadataProcessingReport;

export type DeleteRecordsData = {
  /**
   * Selection bucket name
   */
  bucket?: string;
  /**
   * Record UUIDs. If null current selection is used.
   */
  uuids?: Array<string>;
  /**
   * Backup first the record as MEF in the metadata removed folder.
   */
  withBackup?: boolean;
};

export type DeleteRecordsResponse = SimpleMetadataProcessingReport;

export type GetAsRdfData = {
  /**
   * Search key
   */
  any?: string;
  /**
   * A search facet in the Lucene index. Use the GeoNetwork GUI search to generate the suitable filter values. Example: standard/dcat-ap&createDateYear/2018&sourceCatalog/6d93613e-2b76-4e26-94af-4b4c420a1758 (filter by creation year and source catalog).
   */
  facetQ?: string;
  /**
   * Indicates the start position in a sorted list of matches that the client wants to use as the beginning of a page result.
   */
  from?: number;
  /**
   * Indicates the number of hits per page.
   */
  hitsPerPage?: number;
  /**
   * Use the Lucene FuzzyQuery. Values range from 0.0 to 1.0 and defaults to 0.8.
   */
  similarity?: number;
  /**
   * Lucene sortBy criteria. Relevant values: relevance, title, changeDate.
   */
  sortBy?: string;
  /**
   * Sort order. Possible values: reverse.
   */
  sortOrder?: string;
  /**
   * A search key for the title.
   */
  title?: string;
};

export type GetAsRdfResponse = unknown;

export type InsertFileData = {
  /**
   * Is editable by group members with editor profile? If not, only the author and administrator can edit the record.
   */
  allowEditGroupMembers?: boolean;
  /**
   * (MEF file only) Assign to current catalog.
   */
  assignToCatalog?: boolean;
  /**
   * Tags to assign to the record.
   */
  category?: Array<string>;
  /**
   * (experimental) Add extra information to the record.
   */
  extra?: string;
  /**
   * XML or MEF file to upload
   */
  file?: Array<Blob | File>;
  /**
   * The group the record is attached to.
   */
  group?: string;
  /**
   * The type of record.
   */
  metadataType?:
    | 'METADATA'
    | 'TEMPLATE'
    | 'SUB_TEMPLATE'
    | 'TEMPLATE_OF_SUB_TEMPLATE';
  /**
   * (XML file only) Publish record.
   */
  publishToAll?: boolean;
  /**
   * Validate the record first and reject it if not valid.
   */
  rejectIfInvalid?: boolean;
  /**
   * Force the schema of the record. If not set, schema autodetection is used (and is the preferred method).
   */
  schema?: string;
  /**
   * XSL transformation to apply to the record.
   */
  transformWith?: string;
  /**
   * Record identifier processing.
   */
  uuidProcessing?:
    | 'GENERATEUUID'
    | 'NOTHING'
    | 'OVERWRITE'
    | 'REMOVE_AND_REPLACE';
};

export type InsertFileResponse = SimpleMetadataProcessingReport;

export type InsertData = {
  /**
   * Is editable by group members with editor profile? If not, only the author and administrator can edit the record.
   */
  allowEditGroupMembers?: boolean;
  /**
   * (MEF file only) Assign to current catalog.
   */
  assignToCatalog?: boolean;
  /**
   * Tags to assign to the record.
   */
  category?: Array<string>;
  /**
   * (experimental) Add extra information to the record.
   */
  extra?: string;
  /**
   * The group the record is attached to.
   */
  group?: string;
  /**
   * The type of record.
   */
  metadataType?:
    | 'METADATA'
    | 'TEMPLATE'
    | 'SUB_TEMPLATE'
    | 'TEMPLATE_OF_SUB_TEMPLATE';
  /**
   * (XML file only and if workflow is not enabled) Publish record.
   */
  publishToAll?: boolean;
  /**
   * (Server folder import only) Recursive search in folder.
   */
  recursiveSearch?: boolean;
  /**
   * Validate the record first and reject it if not valid.
   */
  rejectIfInvalid?: boolean;
  requestBody?: string;
  /**
   * Force the schema of the record. If not set, schema autodetection is used (and is the preferred method).
   */
  schema?: string;
  /**
   * Server folder where to look for files.
   */
  serverFolder?: string;
  /**
   * XSL transformation to apply to the record.
   */
  transformWith?: string;
  /**
   * URL of a file to download and insert.
   */
  url?: Array<string>;
  /**
   * Record identifier processing.
   */
  uuidProcessing?:
    | 'GENERATEUUID'
    | 'NOTHING'
    | 'OVERWRITE'
    | 'REMOVE_AND_REPLACE';
};

export type InsertResponse = SimpleMetadataProcessingReport;

export type ApproveData = {
  requestBody: MetadataBatchApproveParameter;
};

export type ApproveResponse = MetadataProcessingReport;

export type TriggerResponse = string;

export type BatchEditData = {
  /**
   * Selection bucket name
   */
  bucket?: string;
  requestBody: Array<BatchEditParameter>;
  /**
   * If true updates the DateStamp (or equivalent in standards different to ISO 19139) field in the metadata with the current timestamp
   */
  updateDateStamp?: boolean;
  /**
   * Record UUIDs. If null current selection is used.
   */
  uuids?: Array<string>;
};

export type BatchEditResponse = IProcessingReport;

export type PreviewBatchEditData = {
  /**
   * Selection bucket name
   */
  bucket?: string;
  /**
   * Return differences with diff, diffhtml or patch
   */
  diffType?: 'patch' | 'diff' | 'diffhtml';
  requestBody: Array<BatchEditParameter>;
  /**
   * Record UUIDs. If null current selection is used.
   */
  uuids?: Array<string>;
};

export type PreviewBatchEditResponse = {
  [key: string]: unknown;
};

export type ExportAsCsvData = {
  /**
   * Selection bucket name
   */
  bucket?: string;
  /**
   * Multiple values separator
   */
  internalSep?: string;
  /**
   * XPath pointing to the XML element to loop on.
   */
  loopElementXpath?: string;
  /**
   * Properties to collect
   */
  propertiesXpath?: Array<string>;
  /**
   * Column separator
   */
  sep?: string;
  /**
   * Record UUIDs. If null current selection is used.
   */
  uuids?: Array<string>;
};

export type ExportAsCsvResponse = unknown;

export type CreateData = {
  /**
   * Is editable by group members with editor profile? If not, only the author and administrator can edit the record.
   */
  allowEditGroupMembers?: boolean;
  /**
   * Tags to assign to the record.
   */
  category?: Array<string>;
  /**
   * The group the record is attached to.
   */
  group: string;
  /**
   * Copy attachments from source?
   */
  hasAttachmentsOfSource?: boolean;
  /**
   * Copy categories from source?
   */
  hasCategoryOfSource?: boolean;
  /**
   * Is child of the record to copy?
   */
  isChildOfSource?: boolean;
  /**
   * The type of record.
   */
  metadataType?:
    | 'METADATA'
    | 'TEMPLATE'
    | 'SUB_TEMPLATE'
    | 'TEMPLATE_OF_SUB_TEMPLATE';
  /**
   * UUID of the source record to copy.
   */
  sourceUuid: string;
  /**
   * Assign a custom UUID. If this UUID already exist an error is returned. This is enabled only if metadata create / generate UUID settings is activated.
   */
  targetUuid?: string;
};

export type CreateResponse = string;

export type InsertOgcMapContextFileData = {
  /**
   * OGC OWS context file name
   */
  filename?: string;
  /**
   * The group the record is attached to.
   */
  group?: string;
  /**
   * Map overview as PNG (base64 encoded)
   */
  overview?: string;
  /**
   * Map overview filename
   */
  overviewFilename?: string;
  /**
   * Publish record.
   */
  publishToAll?: boolean;
  /**
   * A map abstract
   */
  recordAbstract?: string;
  /**
   * A map title
   */
  title: string;
  /**
   * Topic category
   */
  topic?: string;
  /**
   * OGC OWS context URL
   */
  url?: string;
  /**
   * Record identifier processing.
   */
  uuidProcessing?:
    | 'GENERATEUUID'
    | 'NOTHING'
    | 'OVERWRITE'
    | 'REMOVE_AND_REPLACE';
  /**
   * A map viewer URL to visualize the map
   */
  viewerUrl?: string;
  /**
   * OGC OWS context as string
   */
  xml?: string;
};

export type InsertOgcMapContextFileResponse = SimpleMetadataProcessingReport;

export type IndexData = {
  /**
   * Selection bucket name
   */
  bucket?: string;
  /**
   * Record UUIDs. If null current selection is used.
   */
  uuids?: Array<string>;
};

export type IndexResponse2 = IndexResponse;

export type PurgeAllResponse = unknown;

export type GetRecordLinksData = {
  /**
   * Optional, filter links excluding harvested metadata.
   */
  excludeHarvestedMetadataFilter?: boolean;
  /**
   * Filter, e.g. "{url: 'png', lastState: 'ko', records: 'e421'}", lastState being 'ok'/'ko'/'unknown'
   */
  filter?: LinkFilter;
  /**
   * Optional, filter links to records published in that group.
   */
  groupIdFilter?: Array<number>;
  /**
   * Optional, filter links to records created in that group.
   */
  groupOwnerIdFilter?: Array<number>;
  /**
   * Optional, filter links to http status.
   */
  httpErrorStatusValueFilter?: Array<number>;
  /**
   * Results page you want to retrieve (0..N)
   */
  page?: number;
  /**
   * Number of records per page.
   */
  size?: number;
  /**
   * Sorting criteria in the format: property(,asc|desc). Default sort order is ascending.
   */
  sort?: string;
};

export type GetRecordLinksResponse = PageLink;

export type GetRecordLinksPostData = {
  /**
   * Optional, filter links excluding harvested metadata.
   */
  excludeHarvestedMetadataFilter?: boolean;
  /**
   * Filter, e.g. "{url: 'png', lastState: 'ko', records: 'e421'}", lastState being 'ok'/'ko'/'unknown'
   */
  filter?: LinkFilter;
  /**
   * Optional, filter links to records published in that group.
   */
  groupIdFilter?: Array<number>;
  /**
   * Optional, filter links to records created in that group.
   */
  groupOwnerIdFilter?: Array<number>;
  /**
   * Optional, filter links to http status.
   */
  httpStatusValueFilter?: Array<number>;
  /**
   * Results page you want to retrieve (0..N)
   */
  page?: number;
  /**
   * Number of records per page.
   */
  size?: number;
  /**
   * Sorting criteria in the format: property(,asc|desc). Default sort order is ascending.
   */
  sort?: string;
};

export type GetRecordLinksPostResponse = PageLink;

export type AnalyzeRecordLinksData = {
  analyze?: boolean;
  /**
   * Selection bucket name
   */
  bucket?: string;
  /**
   * Only allowed if Administrator.
   */
  removeFirst?: boolean;
  /**
   * Record UUIDs. If null current selection is used.
   */
  uuids?: Array<string>;
};

export type AnalyzeRecordLinksResponse = SimpleMetadataProcessingReport;

export type AnalyzeLinksData = {
  /**
   * URL
   */
  url?: Array<string>;
};

export type AnalyzeLinksResponse = unknown;

export type GetRecordLinksAsCsvData = {
  /**
   * Optional, filter links excluding harvested metadata.
   */
  excludeHarvestedMetadataFilter?: boolean;
  /**
   * Filter, e.g. "{url: 'png', lastState: 'ko', records: 'e421'}", lastState being 'ok'/'ko'/'unknown'
   */
  filter?: LinkFilter;
  /**
   * Optional, filter links to records published in that group.
   */
  groupIdFilter?: Array<number>;
  /**
   * Optional, filter links to records created in that group.
   */
  groupOwnerIdFilter?: Array<number>;
  /**
   * Optional, filter links to http status.
   */
  httpStatusValueFilter?: Array<number>;
  /**
   * Results page you want to retrieve (0..N)
   */
  page?: number;
  /**
   * Number of records per page.
   */
  size?: number;
  /**
   * Sorting criteria in the format: property(,asc|desc). Default sort order is ascending.
   */
  sort?: string;
};

export type GetRecordLinksAsCsvResponse = unknown;

export type SetGroupAndOwnerData = {
  /**
   * Use approved version or not
   */
  approved?: boolean;
  /**
   * Selection bucket name
   */
  bucket?: string;
  /**
   * Group identifier
   */
  groupIdentifier: number;
  /**
   * User identifier
   */
  userIdentifier: number;
  /**
   * Record UUIDs. If null current selection is used.
   */
  uuids?: Array<string>;
};

export type SetGroupAndOwnerResponse = MetadataProcessingReport;

export type ExportAsPdfData = {
  /**
   * Selection bucket name
   */
  bucket?: string;
  /**
   * Record UUIDs. If null current selection is used.
   */
  uuids?: Array<string>;
};

export type ExportAsPdfResponse = unknown;

export type PublishMultipleRecordsData = {
  /**
   * Selection bucket name
   */
  bucket?: string;
  /**
   * Publication type
   */
  publicationType: string;
  /**
   * Record UUIDs. If null current selection is used.
   */
  uuids?: Array<string>;
};

export type PublishMultipleRecordsResponse = MetadataProcessingReport;

export type AddSamplesData = {
  /**
   * Schema identifiers
   */
  schema: Array<string>;
};

export type AddSamplesResponse = SimpleMetadataProcessingReport;

export type GetSharingSettingsResponse = SharingResponse;

export type ShareMultipleRecordsData = {
  /**
   * Selection bucket name
   */
  bucket?: string;
  requestBody: SharingParameter;
  /**
   * Record UUIDs. If null current selection is used.
   */
  uuids?: Array<string>;
};

export type ShareMultipleRecordsResponse = MetadataProcessingReport;

export type GetPublicationOptionsResponse = Array<PublicationOption>;

export type GetWorkflowStatusByTypeData = {
  /**
   * One or more event author. Default is all.
   */
  author?: Array<number>;
  /**
   * Start date
   */
  dateFrom?: string;
  /**
   * End date
   */
  dateTo?: string;
  /**
   * All event details including XML changes. Responses are bigger. Default is false
   */
  details?: boolean;
  /**
   * From page
   */
  from?: number;
  /**
   * One or more record identifier. Default is all.
   */
  id?: Array<number>;
  /**
   * One or more event owners. Default is all.
   */
  owner?: Array<number>;
  /**
   * One or more metadata record identifier. Default is all.
   */
  recordIdentifier?: Array<number>;
  /**
   * Number of records to return
   */
  size?: number;
  /**
   * Sort Order (ie. DESC or ASC). Default is none.
   */
  sortOrder?: 'ASC' | 'DESC';
  /**
   * One or more status id. Default is all.
   */
  statusIds?: Array<string>;
  /**
   * One or more types to retrieve (ie. worflow, event, task). Default is all.
   */
  type?: Array<'workflow' | 'task' | 'event'>;
  /**
   * One or more metadata uuid. Default is all.
   */
  uuid?: Array<string>;
};

export type GetWorkflowStatusByTypeResponse = Array<MetadataStatusResponse>;

export type SubmitData = {
  requestBody: MetadataBatchSubmitParameter;
};

export type SubmitResponse = MetadataProcessingReport;

export type DeleteTagForRecordsData = {
  /**
   * Selection bucket name
   */
  bucket?: string;
  /**
   * Tag identifier
   */
  id: Array<number>;
  /**
   * Record UUIDs. If null current selection is used.
   */
  uuids?: Array<string>;
};

export type DeleteTagForRecordsResponse = MetadataProcessingReport;

export type TagRecordsData = {
  /**
   * Selection bucket name
   */
  bucket?: string;
  /**
   * Clear all before adding new ones
   */
  clear?: boolean;
  /**
   * Tag identifier
   */
  id?: Array<number>;
  /**
   * Tag identifier to remove.
   */
  removeId?: Array<number>;
  /**
   * Record UUIDs. If null current selection is used.
   */
  uuids?: Array<string>;
};

export type TagRecordsResponse = MetadataProcessingReport;

export type AddTemplatesData = {
  /**
   * Schema identifiers
   */
  schema: Array<string>;
};

export type AddTemplatesResponse = SimpleMetadataProcessingReport;

export type UnpublishMultipleRecordsData = {
  /**
   * Selection bucket name
   */
  bucket?: string;
  /**
   * Publication type
   */
  publicationType: string;
  /**
   * Record UUIDs. If null current selection is used.
   */
  uuids?: Array<string>;
};

export type UnpublishMultipleRecordsResponse = MetadataProcessingReport;

export type CleanValidationStatusData = {
  /**
   * Selection bucket name
   */
  bucket?: string;
  /**
   * Record UUIDs. If null current selection is used.
   */
  uuids?: Array<string>;
};

export type CleanValidationStatusResponse = SimpleMetadataProcessingReport;

export type ValidateRecordsData = {
  /**
   * Use approved version or not
   */
  approved?: boolean;
  /**
   * Selection bucket name
   */
  bucket?: string;
  /**
   * Record UUIDs. If null current selection is used.
   */
  uuids?: Array<string>;
};

export type ValidateRecordsResponse = SimpleMetadataProcessingReport;

export type ValidateRecordsInspireData = {
  /**
   * Selection bucket name
   */
  bucket?: string;
  /**
   * Define the encoding of the record to use. By default, ISO19139 are used as is and ISO19115-3 are converted to ISO19139.If mode = csw, a GetRecordById request is used.If mode = any portal id, then a GetRecordById request is used on this portal CSW entry point which may define custom CSW post processing. See https://github.com/geonetwork/core-geonetwork/pull/4493.
   */
  mode?: string;
  /**
   * Record UUIDs. If null current selection is used.
   */
  uuids?: Array<string>;
};

export type ValidateRecordsInspireResponse = string;

export type EnableVersionControlForRecordsData = {
  /**
   * Selection bucket name
   */
  bucket?: string;
  /**
   * Record UUIDs. If null current selection is used.
   */
  uuids?: Array<string>;
};

export type EnableVersionControlForRecordsResponse = MetadataProcessingReport;

export type ExportAsMefData = {
  addSchemaLocation?: boolean;
  /**
   * Download the approved version
   */
  approved?: boolean;
  /**
   * Selection bucket name
   */
  bucket?: string;
  /**
   * MEF file format.
   */
  format?: 'SIMPLE' | 'PARTIAL' | 'FULL';
  /**
   * Record UUIDs. If null current selection is used.
   */
  uuids?: Array<string>;
  /**
   * With related records (parent and service).
   */
  withRelated?: boolean;
  /**
   * Preserve XLink URLs in the records.
   */
  withXlinkAttribute?: boolean;
  /**
   * Resolve XLinks in the records.
   */
  withXlinksResolved?: boolean;
};

export type ExportAsMefResponse = unknown;

export type DeleteRecordData = {
  /**
   * Record UUID.
   */
  metadataUuid: string;
  /**
   * Backup first the record as MEF in the metadata removed folder.
   */
  withBackup?: boolean;
};

export type DeleteRecordResponse = void;

export type GetRecordData = {
  /**
   * Record UUID.
   */
  metadataUuid: string;
};

export type GetRecordResponse = Blob | File;

export type SendEmailToContactData = {
  /**
   * User function.
   */
  _function?: string;
  /**
   * Comment category.
   */
  category?: string;
  /**
   * A comment or question.
   */
  comments: string;
  /**
   * User email address.
   */
  email: string;
  /**
   * List of record's contact to send this email (separated by comma).
   */
  metadataEmail?: string;
  /**
   * Metadata record UUID.
   */
  metadataUuid: string;
  /**
   * User name.
   */
  name: string;
  /**
   * User organisation.
   */
  org: string;
  /**
   * User phone number.
   */
  phone?: string;
  /**
   * Recaptcha validation key.
   */
  recaptcha?: string;
  /**
   * Email subject.
   */
  subject?: string;
  /**
   * Comment type.
   */
  type?: string;
};

export type SendEmailToContactResponse = string;

export type GetAssociatedResourcesData = {
  /**
   * Use approved version or not
   */
  approved?: boolean;
  /**
   * Record UUID.
   */
  metadataUuid: string;
  /**
   * Number of rows returned. Default 100.
   */
  rows?: number;
  /**
   * Start offset for paging. Default 1. Only applies to related metadata records (ie. not for thumbnails).
   */
  start?: number;
  /**
   * Type of related resource. If none, all resources are returned.
   */
  type?: Array<RelatedItemType>;
};

export type GetAssociatedResourcesResponse = {
  [key: string]: Array<AssociatedRecord>;
};

export type DelResourcesData = {
  /**
   * Use approved version or not
   */
  approved?: boolean;
  /**
   * The metadata UUID
   */
  metadataUuid: string;
};

export type DelResourcesResponse = void;

export type GetAllResourcesData = {
  /**
   * Use approved version or not
   */
  approved?: boolean;
  filter?: string;
  /**
   * The metadata UUID
   */
  metadataUuid: string;
  /**
   * Sort by
   */
  sort?: 'type' | 'name';
};

export type GetAllResourcesResponse = Array<MetadataResource>;

export type PutResourceData = {
  /**
   * Use approved version or not
   */
  approved?: boolean;
  /**
   * The metadata UUID
   */
  metadataUuid: string;
  requestBody?: {
    /**
     * The file to upload
     */
    file: Blob | File;
  };
  /**
   * The sharing policy
   */
  visibility?: 'PUBLIC' | 'PRIVATE';
};

export type PutResourceResponse = MetadataResource;

export type PutResourceFromUrlData = {
  /**
   * Use approved version or not
   */
  approved?: boolean;
  /**
   * The metadata UUID
   */
  metadataUuid: string;
  /**
   * The URL to load in the store
   */
  url: string;
  /**
   * The sharing policy
   */
  visibility?: 'PUBLIC' | 'PRIVATE';
};

export type PutResourceFromUrlResponse = MetadataResource;

export type SaveThumbnailData = {
  /**
   * The mapprint module JSON configuration
   */
  jsonConfig: string;
  /**
   * Record UUID.
   */
  metadataUuid: string;
  /**
   * The rotation angle of the map
   */
  rotationAngle?: number;
};

export type SaveThumbnailResponse = MetadataResource;

export type DelResourceData = {
  /**
   * Use approved version or not
   */
  approved?: boolean;
  /**
   * The metadata UUID
   */
  metadataUuid: string;
  /**
   * The resource identifier (ie. filename)
   */
  resourceId: string;
};

export type DelResourceResponse = void;

export type GetResourceData = {
  /**
   * Use approved version or not
   */
  approved?: boolean;
  /**
   * The metadata UUID
   */
  metadataUuid: string;
  /**
   * The resource identifier (ie. filename)
   */
  resourceId: string;
  /**
   * Size (only applies to images). From 1px to 2048px.
   */
  size?: number;
};

export type GetResourceResponse = Blob | File;

export type PatchResourceData = {
  /**
   * Use approved version or not
   */
  approved?: boolean;
  /**
   * The metadata UUID
   */
  metadataUuid: string;
  /**
   * The resource identifier (ie. filename)
   */
  resourceId: string;
  /**
   * The visibility
   */
  visibility: 'PUBLIC' | 'PRIVATE';
};

export type PatchResourceResponse = MetadataResource;

export type UnregisterDoiData = {
  /**
   * Record UUID.
   */
  metadataUuid: string;
};

export type UnregisterDoiResponse = string;

export type CreateDoiData = {
  /**
   * Record UUID.
   */
  metadataUuid: string;
};

export type CreateDoiResponse = {
  [key: string]: string;
};

export type CheckDoiUrlData = {
  /**
   * Record UUID.
   */
  metadataUuid: string;
};

export type CheckDoiUrlResponse = string;

export type CheckDoiStatusData = {
  /**
   * Record UUID.
   */
  metadataUuid: string;
};

export type CheckDoiStatusResponse = {
  [key: string]: boolean;
};

export type CancelEditsData = {
  /**
   * Record UUID.
   */
  metadataUuid: string;
};

export type CancelEditsResponse = void;

export type StartEditingData = {
  /**
   * Tab
   */
  currTab?: string;
  /**
   * Record UUID.
   */
  metadataUuid: string;
  withAttributes?: boolean;
};

export type StartEditingResponse = unknown;

export type SaveEditsData = {
  /**
   * Save current edits.
   */
  commit?: boolean;
  /**
   * Record as XML. TODO: rename xml
   */
  data?: string;
  /**
   * Record UUID.
   */
  metadataUuid: string;
  minor?: boolean;
  /**
   * Submit for review directly after save.
   */
  status?: string;
  /**
   * Tab
   */
  tab?: string;
  /**
   * Save and terminate session.
   */
  terminate?: boolean;
  withAttributes?: boolean;
  withValidationErrors?: boolean;
};

export type SaveEditsResponse = unknown;

export type DeleteAttributeData = {
  /**
   * Should attributes be shown on the editor snippet?
   */
  displayAttributes?: boolean;
  /**
   * Record UUID.
   */
  metadataUuid: string;
  /**
   * Reference of the attribute to remove.
   */
  ref: string;
};

export type DeleteAttributeResponse = void;

export type DeleteElementData = {
  /**
   * Should attributes be shown on the editor snippet?
   */
  displayAttributes?: boolean;
  /**
   * Record UUID.
   */
  metadataUuid: string;
  /**
   * Name of the parent.
   */
  parent: string;
  /**
   * Reference of the element to remove.
   */
  ref: Array<string>;
};

export type DeleteElementResponse = void;

export type AddElementData = {
  /**
   * Use geonet:attribute for attributes or child name.
   */
  child?: string;
  /**
   * Should attributes be shown on the editor snippet?
   */
  displayAttributes?: boolean;
  /**
   * Record UUID.
   */
  metadataUuid: string;
  /**
   * Name of the element to add (with prefix)
   */
  name: string;
  /**
   * Reference of the insertion point.
   */
  ref: string;
};

export type AddElementResponse = unknown;

export type ReorderElementData = {
  /**
   * Direction
   */
  direction: Direction;
  /**
   * Should attributes be shown on the editor snippet?
   */
  displayAttributes?: boolean;
  /**
   * Record UUID.
   */
  metadataUuid: string;
  /**
   * Reference of the element to move.
   */
  ref: string;
};

export type ReorderElementResponse = unknown;

export type GetAllRecordExtentAsJsonData = {
  /**
   * Record UUID.
   */
  metadataUuid: string;
};

export type GetAllRecordExtentAsJsonResponse = Array<ExtentDto>;

export type GetAllRecordExtentAsImageData = {
  /**
   * (optional) URL for loading a background image for regions or a key that references the namedBackgrounds (configured in config-spring-geonetwork.xml). A WMS GetMap request is the typical example. The URL must be parameterized with the following parameters: minx, maxx, miny, maxy, width, height
   */
  background?: string;
  /**
   * (optional) Fill color with format RED,GREEN,BLUE,ALPHA
   */
  fillColor?: string;
  /**
   * (optional) height of the image that is created. Only one of width and height are permitted
   */
  height?: number;
  /**
   * (optional) the background map projection. If not passed uses the region/getmap/mapproj setting. If the setting is not set defaults to EPSG:4326
   */
  mapsrs?: string;
  /**
   * Record UUID.
   */
  metadataUuid: string;
  /**
   * (optional) Stroke color with format RED,GREEN,BLUE,ALPHA
   */
  strokeColor?: string;
  /**
   * (optional) width of the image that is created. Only one of width and height are permitted
   */
  width?: number;
};

export type GetAllRecordExtentAsImageResponse = Array<string>;

export type GetOneRecordExtentAsImageData = {
  /**
   * (optional) URL for loading a background image for regions or a key that references the namedBackgrounds (configured in config-spring-geonetwork.xml). A WMS GetMap request is the typical example. The URL must be parameterized with the following parameters: minx, maxx, miny, maxy, width, height
   */
  background?: string;
  /**
   * (optional) Fill color with format RED,GREEN,BLUE,ALPHA
   */
  fillColor?: string;
  /**
   * Index of the geometry or bounding box to display. Starts at 1.
   */
  geometryIndex: number;
  /**
   * (optional) height of the image that is created. Only one of width and height are permitted
   */
  height?: number;
  /**
   * (optional) the background map projection. If not passed uses the region/getmap/mapproj setting. If the setting is not set defaults to EPSG:4326
   */
  mapsrs?: string;
  /**
   * Record UUID.
   */
  metadataUuid: string;
  /**
   * (optional) Stroke color with format RED,GREEN,BLUE,ALPHA
   */
  strokeColor?: string;
  /**
   * (optional) width of the image that is created. Only one of width and height are permitted
   */
  width?: number;
};

export type GetOneRecordExtentAsImageResponse = Array<string>;

export type GetFeatureCatalogData = {
  /**
   * Use approved version or not
   */
  approved?: boolean;
  /**
   * Record UUID.
   */
  metadataUuid: string;
};

export type GetFeatureCatalogResponse = FeatureResponse;

export type GetRecordAsJsonData = {
  /**
   * Add XSD schema location based on standard configuration (see schema-ident.xml).
   */
  addSchemaLocation?: boolean;
  /**
   * Download the approved version
   */
  approved?: boolean;
  /**
   * Download as a file
   */
  attachment?: boolean;
  /**
   * Increase record popularity
   */
  increasePopularity?: boolean;
  /**
   * Record UUID.
   */
  metadataUuid: string;
  /**
   * Add geonet:info details
   */
  withInfo?: boolean;
};

export type GetRecordAsJsonResponse = Blob | File;

export type GetRecordAsXmlData = {
  /**
   * Add XSD schema location based on standard configuration (see schema-ident.xml).
   */
  addSchemaLocation?: boolean;
  /**
   * Download the approved version
   */
  approved?: boolean;
  /**
   * Download as a file
   */
  attachment?: boolean;
  /**
   * Increase record popularity
   */
  increasePopularity?: boolean;
  /**
   * Record UUID.
   */
  metadataUuid: string;
  /**
   * Add geonet:info details
   */
  withInfo?: boolean;
};

export type GetRecordAsXmlResponse = Blob | File;

export type GetRecordAsZipData = {
  addSchemaLocation?: boolean;
  /**
   * Download the approved version
   */
  approved?: boolean;
  /**
   * MEF file format.
   */
  format?: 'SIMPLE' | 'PARTIAL' | 'FULL';
  /**
   * Record UUID.
   */
  metadataUuid: string;
  /**
   * With related records (parent and service).
   */
  withRelated?: boolean;
  /**
   * Preserve XLink URLs in the records.
   */
  withXlinkAttribute?: boolean;
  /**
   * Resolve XLinks in the records.
   */
  withXlinksResolved?: boolean;
};

export type GetRecordAsZipResponse = unknown;

export type GetRecordFormattedByData = {
  /**
   * Download the approved version
   */
  approved?: boolean;
  /**
   * Formatter type to use.
   */
  formatterId: string;
  /**
   * Optional language ISO 3 letters code to override HTTP Accept-language header.
   */
  language?: string;
  mdpath?: string;
  /**
   * Record UUID.
   */
  metadataUuid: string;
  output?: 'txt' | 'html' | 'xml' | 'json' | 'jsonld' | 'pdf' | 'testpdf';
  width?: '_25' | '_50' | '_75' | '_100';
};

export type GetRecordFormattedByResponse = unknown;

export type SetRecordGroupData = {
  /**
   * Record UUID.
   */
  metadataUuid: string;
  requestBody: number;
};

export type SetRecordGroupResponse = void;

export type SetRecordOwnershipData = {
  /**
   * Use approved version or not
   */
  approved?: boolean;
  /**
   * Group identifier
   */
  groupIdentifier: number;
  /**
   * Record UUID.
   */
  metadataUuid: string;
  /**
   * User identifier
   */
  userIdentifier: number;
};

export type SetRecordOwnershipResponse = MetadataProcessingReport;

export type GetRecordPermalinkData = {
  /**
   * Record UUID.
   */
  metadataUuid: string;
};

export type GetRecordPermalinkResponse = string;

export type GetRecordPopularityData = {
  /**
   * Record UUID.
   */
  metadataUuid: string;
};

export type GetRecordPopularityResponse = string;

export type IncreaseRecordPopularityData = {
  /**
   * Record UUID.
   */
  metadataUuid: string;
};

export type IncreaseRecordPopularityResponse = string;

export type GetSuggestionsData = {
  /**
   * Record UUID.
   */
  metadataUuid: string;
};

export type GetSuggestionsResponse = Array<SuggestionType>;

export type ProcessRecordPreviewData = {
  /**
   * Record UUID.
   */
  metadataUuid: string;
  /**
   * Process identifier
   */
  process: string;
};

export type ProcessRecordPreviewResponse = unknown;

export type ProcessRecordData = {
  /**
   * Record UUID.
   */
  metadataUuid: string;
  /**
   * Process identifier
   */
  process: string;
};

export type ProcessRecordResponse = string;

export type PublishData = {
  /**
   * Record UUID.
   */
  metadataUuid: string;
  /**
   * Publication type
   */
  publicationType: string;
};

export type PublishResponse = void;

export type GetSavedQueriesData = {
  /**
   * Record UUID.
   */
  metadataUuid: string;
};

export type GetSavedQueriesResponse = Array<SavedQuery>;

export type ApplyQueryData = {
  /**
   * The metadata UUID
   */
  metadataUuid: string;
  requestBody?: {
    [key: string]: string;
  };
  /**
   * The saved query to apply
   */
  savedQuery: string;
};

export type ApplyQueryResponse = {
  [key: string]: string;
};

export type RateRecordData = {
  /**
   * Record UUID.
   */
  metadataUuid: string;
  requestBody: number;
};

export type RateRecordResponse = number;

export type GetRelatedResourcesData = {
  /**
   * Use approved version or not
   */
  approved?: boolean;
  /**
   * Record UUID.
   */
  metadataUuid: string;
  /**
   * Number of rows returned. Default 100.
   */
  rows?: number;
  /**
   * Start offset for paging. Default 1. Only applies to related metadata records (ie. not for thumbnails).
   */
  start?: number;
  /**
   * Type of related resource. If none, all resources are returned.
   */
  type?: Array<RelatedItemType>;
};

export type GetRelatedResourcesResponse = RelatedResponse;

export type GetRecordSharingSettingsData = {
  /**
   * Record UUID.
   */
  metadataUuid: string;
};

export type GetRecordSharingSettingsResponse = SharingResponse;

export type ShareData = {
  /**
   * Record UUID.
   */
  metadataUuid: string;
  requestBody: SharingParameter;
};

export type ShareResponse = void;

export type DeleteAllRecordStatusData = {
  /**
   * Record UUID.
   */
  metadataUuid: string;
};

export type DeleteAllRecordStatusResponse = void;

export type GetRecordStatusHistoryData = {
  details?: boolean;
  /**
   * Record UUID.
   */
  metadataUuid: string;
  /**
   * Sort direction
   */
  sortOrder?: 'ASC' | 'DESC';
};

export type GetRecordStatusHistoryResponse = Array<MetadataStatusResponse>;

export type SetStatusData = {
  /**
   * Record UUID.
   */
  metadataUuid: string;
  requestBody: MetadataStatusParameter;
};

export type SetStatusResponse = {
  [key: string]: 'UPDATED' | 'UNCHANGED' | 'DELETED';
};

export type GetStatusData = {
  /**
   * Record UUID.
   */
  metadataUuid: string;
};

export type GetStatusResponse = MetadataWorkflowStatusResponse;

export type DeleteRecordStatusData = {
  /**
   * Change date
   */
  changeDate: string;
  /**
   * Record UUID.
   */
  metadataUuid: string;
  /**
   * Status identifier
   */
  statusId: number;
  /**
   * User identifier
   */
  userId: number;
};

export type DeleteRecordStatusResponse = void;

export type ShowStatusAfterData = {
  /**
   * Change date
   */
  changeDate: string;
  /**
   * Record UUID.
   */
  metadataUuid: string;
  /**
   * Status identifier
   */
  statusId: number;
  /**
   * User identifier
   */
  userId: number;
};

export type ShowStatusAfterResponse = string;

export type ShowStatusBeforeData = {
  /**
   * Change date
   */
  changeDate: string;
  /**
   * Record UUID.
   */
  metadataUuid: string;
  /**
   * Status identifier
   */
  statusId: number;
  /**
   * User identifier
   */
  userId: number;
};

export type ShowStatusBeforeResponse = string;

export type CloseTaskData = {
  /**
   * Change date
   */
  changeDate: string;
  /**
   * Close date
   */
  closeDate: string;
  /**
   * Record UUID.
   */
  metadataUuid: string;
  /**
   * Status identifier
   */
  statusId: number;
  /**
   * User identifier
   */
  userId: number;
};

export type CloseTaskResponse = void;

export type RestoreAtStatusSaveData = {
  /**
   * Change date
   */
  changeDate: string;
  /**
   * Record UUID.
   */
  metadataUuid: string;
  /**
   * Status identifier
   */
  statusId: number;
  /**
   * User identifier
   */
  userId: number;
};

export type RestoreAtStatusSaveResponse = unknown;

export type GetRecordStatusHistoryByTypeData = {
  details?: boolean;
  /**
   * Record UUID.
   */
  metadataUuid: string;
  /**
   * Sort direction
   */
  sortOrder?: 'ASC' | 'DESC';
  /**
   * Type
   */
  type: 'workflow' | 'task' | 'event';
};

export type GetRecordStatusHistoryByTypeResponse =
  Array<MetadataStatusResponse>;

export type DeleteTagsData = {
  /**
   * Tag identifier. If none, all tags are removed.
   */
  id?: Array<number>;
  /**
   * Record UUID.
   */
  metadataUuid: string;
};

export type DeleteTagsResponse = void;

export type GetRecordTagsData = {
  /**
   * Record UUID.
   */
  metadataUuid: string;
};

export type GetRecordTagsResponse = Array<MetadataCategory>;

export type TagRecordData = {
  /**
   * Clear all before adding new ones
   */
  clear?: boolean;
  /**
   * Tag identifier
   */
  id: Array<number>;
  /**
   * Record UUID.
   */
  metadataUuid: string;
};

export type TagRecordResponse = unknown;

export type UnpublishData = {
  /**
   * Record UUID.
   */
  metadataUuid: string;
  /**
   * Publication type
   */
  publicationType: string;
};

export type UnpublishResponse = void;

export type GetUserCommentsOnArecordData = {
  /**
   * Metadata record UUID.
   */
  metadataUuid: string;
  /**
   * Maximum number of feedback to return.
   */
  size?: number;
};

export type GetUserCommentsOnArecordResponse = Array<UserFeedbackDTO>;

export type GetMetadataRatingData = {
  /**
   * Metadata record UUID.
   */
  metadataUuid: string;
};

export type GetMetadataRatingResponse = RatingAverage;

export type ValidateRecordForInspireData = {
  /**
   * Record UUID.
   */
  metadataUuid: string;
  /**
   * Define the encoding of the record to use. By default, ISO19139 are used as is and ISO19115-3 are converted to ISO19139.If mode = csw, a GetRecordById request is used.If mode = any portal id, then a GetRecordById request is used on this portal CSW entry point which may define custom CSW post processing. See https://github.com/geonetwork/core-geonetwork/pull/4493.
   */
  mode?: string;
  /**
   * Test suite to run
   */
  testsuite: string;
};

export type ValidateRecordForInspireResponse = string;

export type GetTestSuitesData = {
  /**
   * Record UUID.
   */
  metadataUuid: string;
};

export type GetTestSuitesResponse = {
  [key: string]: Array<string>;
};

export type ValidateRecordData = {
  /**
   * Validation status. Should be provided only in case of SUBTEMPLATE validation. If provided for another type, throw a BadParameter Exception
   */
  isvalid?: boolean;
  /**
   * Record UUID.
   */
  metadataUuid: string;
};

export type ValidateRecordResponse = Reports;

export type EnableVersionControlData = {
  /**
   * Record UUID.
   */
  metadataUuid: string;
};

export type EnableVersionControlResponse = string;

export type CheckValidationData = {
  /**
   * Test identifier
   */
  testId: string;
};

export type CheckValidationResponse = {
  [key: string]: string;
};

export type GetRegionsData = {
  categoryId?: string;
  label?: string;
  maxRecords?: number;
};

export type GetRegionsResponse = ListRegionsResponse;

export type GetGeomAsImageData = {
  /**
   * (optional) URL for loading a background image for regions or a key that references the namedBackgrounds (configured in config-spring-geonetwork.xml). A WMS Getmap request is the typical example. The URL must be parameterized with the following parameters: minx, maxx, miny, maxy, width, height
   */
  background?: string;
  /**
   * (optional) Fill color with format RED,GREEN,BLUE,ALPHA
   */
  fillColor?: string;
  /**
   * (optional) a wkt or gml encoded geometry.
   */
  geom?: string;
  geomsrs?: string;
  /**
   * (optional) defines if geom is wkt or gml. Allowed values are wkt and gml. if not specified the it is assumed the geometry is wkt
   */
  geomtype?: string;
  /**
   * (optional) height of the image that is created. Only one of width and height are permitted
   */
  height?: number;
  /**
   * (optional) the background map projection. If not passed uses the region/getmap/mapproj setting. If the setting is not set defaults to EPSG:4326
   */
  mapsrs?: string;
  /**
   * (optional) Stroke color with format RED,GREEN,BLUE,ALPHA
   */
  strokeColor?: string;
  /**
   * (optional) width of the image that is created. Only one of width and height are permitted
   */
  width?: number;
};

export type GetGeomAsImageResponse = Array<string>;

export type GetRegionTypesResponse = Array<Category>;

export type PreviewExtractedEntriesData = {
  /**
   * Selection bucket name
   */
  bucket?: string;
  /**
   * XPath of the element identifier. If not defined a random UUID is generated and analysis will not check for duplicates.
   */
  identifierXpath?: string;
  /**
   * Record UUIDs. If null current selection is used.
   */
  uuids?: Array<string>;
  /**
   * XPath of the elements to extract as entry.
   */
  xpath: string;
};

export type PreviewExtractedEntriesResponse = {
  [key: string]: unknown;
};

export type ExtractEntriesData = {
  /**
   * Selection bucket name
   */
  bucket?: string;
  /**
   * XPath of the element identifier. If not defined a random UUID is generated and analysis will not check for duplicates.
   */
  identifierXpath?: string;
  /**
   * Record UUIDs. If null current selection is used.
   */
  uuids?: Array<string>;
  /**
   * XPath of the elements to extract as entry.
   */
  xpath: string;
};

export type ExtractEntriesResponse = {
  [key: string]: unknown;
};

export type ImportSpatialEntriesData = {
  /**
   * Attribute table charset
   */
  charset?: string;
  /**
   * Attribute to use for extent description. If none, no extent description defined. TODO: Add per language desc ?
   */
  descriptionAttribute?: string;
  formData?: {
    /**
     * The ZIP file to upload containing the Shapefile.
     */
    file: Blob | File;
  };
  /**
   * geomProjectionTo
   */
  geomProjectionTo?: string;
  /**
   * The group the record is attached to.
   */
  group?: number;
  /**
   * lenient
   */
  lenient?: boolean;
  /**
   * Create only bounding box for each spatial objects.
   */
  onlyBoundingBox?: boolean;
  /**
   * Process
   */
  process?: string;
  /**
   * Schema identifier
   */
  schema?: string;
  /**
   * Attribute to use for UUID. If none, random UUID are generated.
   */
  uuidAttribute?: string;
  /**
   * Pattern to build UUID from. Default is '{{uuid}}'.
   */
  uuidPattern?: string;
  /**
   * Record identifier processing.
   */
  uuidProcessing?:
    | 'GENERATEUUID'
    | 'NOTHING'
    | 'OVERWRITE'
    | 'REMOVE_AND_REPLACE';
};

export type ImportSpatialEntriesResponse = SimpleMetadataProcessingReport;

export type PreviewUpdatedRecordEntriesData = {
  /**
   * Selection bucket name
   */
  bucket?: string;
  /**
   * Filter query for directory search.
   */
  fq?: string;
  /**
   * XPath of the element identifier. If not defined a random UUID is generated and analysis will not check for duplicates.
   */
  identifierXpath?: string;
  /**
   * List of XPath of properties to copy from record to matching entry. Only support text or attribute eg. ./gmd:role*@codeListValue
   */
  propertiesToCopy?: Array<string>;
  /**
   * Replace entry by XLink.
   */
  substituteAsXlink?: boolean;
  /**
   * Record UUIDs. If null current selection is used.
   */
  uuids?: Array<string>;
  /**
   * XPath of the elements to extract as entry.
   */
  xpath: string;
};

export type PreviewUpdatedRecordEntriesResponse = {
  [key: string]: unknown;
};

export type UpdateRecordEntriesData = {
  /**
   * Selection bucket name
   */
  bucket?: string;
  /**
   * Filter query for directory search.
   */
  fq?: string;
  /**
   * XPath of the element identifier. If not defined a random UUID is generated and analysis will not check for duplicates.
   */
  identifierXpath?: string;
  /**
   * List of XPath of properties to copy from record to matching entry. Only support text or attribute eg. ./gmd:role*@codeListValue
   */
  propertiesToCopy?: Array<string>;
  /**
   * Replace entry by XLink.
   */
  substituteAsXlink?: boolean;
  /**
   * Record UUIDs. If null current selection is used.
   */
  uuids?: Array<string>;
  /**
   * XPath of the elements to extract as entry.
   */
  xpath: string;
};

export type UpdateRecordEntriesResponse = {
  [key: string]: unknown;
};

export type SearchCrsData = {
  /**
   * Search value
   */
  q?: string;
  /**
   * Number of results. Default is: 100
   */
  rows?: number;
  /**
   * Type of CRS
   */
  type?:
    | 'CoordinateReferenceSystem'
    | 'VerticalCRS'
    | 'GeographicCRS'
    | 'ProjectedCRS';
};

export type SearchCrsResponse = Array<Crs>;

export type GetCrsTypesResponse = Array<
  'CoordinateReferenceSystem' | 'VerticalCRS' | 'GeographicCRS' | 'ProjectedCRS'
>;

export type GetCrsData = {
  /**
   * CRS identifier
   */
  id: string;
};

export type GetCrsResponse = Crs;

export type GetEntryData = {
  /**
   * lang
   */
  lang?: Array<string>;
  /**
   * Process
   */
  process?: Array<string>;
  /**
   * schema
   */
  schema?: string;
  /**
   * Transformation
   */
  transformation?: string;
  /**
   * Directory entry UUID.
   */
  uuid: string;
};

export type GetEntryResponse = unknown;

export type UploadThesaurusData = {
  /**
   * Type of thesaurus, usually one of the ISO thesaurus type codelist value. Default is theme.
   */
  dir?: string;
  requestBody?: {
    /**
     * If set, do a file upload.
     */
    file?: Blob | File;
  };
  /**
   * XSL to be use to convert the thesaurus before load. Default _none_.
   */
  stylesheet?: string;
  /**
   * Local or external (default).
   */
  type?: 'external' | 'local';
};

export type UploadThesaurusResponse = string;

export type UploadThesaurusFromUrlData = {
  /**
   * Type of thesaurus, usually one of the ISO thesaurus type codelist value. Default is theme.
   */
  dir?: string;
  /**
   * Languages to download from a registry.
   */
  registryLanguage?: Array<string>;
  /**
   * If using registryUrl, then define the type of registry. If not set, default mode is re3gistry.
   */
  registryType?: 're3gistry' | 'ldRegistry';
  /**
   * If set, try to download from a registry.
   */
  registryUrl?: string;
  requestBody?: ThesaurusInfo;
  /**
   * XSL to be use to convert the thesaurus before load. Default _none_.
   */
  stylesheet?: string;
  /**
   * Local or external (default).
   */
  type?: 'external' | 'local';
  /**
   * If set, try to download from the Internet.
   */
  url?: string;
};

export type UploadThesaurusFromUrlResponse = string;

export type ImportCsvAsThesaurusData = {
  /**
   * Column name for broader concept id. Default is broader.
   */
  conceptBroaderIdColumn?: string;
  /**
   * Column name for concept description. Default is description.
   */
  conceptDescriptionColumn?: string;
  /**
   * Column name for concept id. Default is id.
   */
  conceptIdColumn?: string;
  /**
   * Column name for concept label. Default is label.
   */
  conceptLabelColumn?: string;
  /**
   * Separator used when multiple broader/narrower/related ids are in the same column. Default is '|'.
   */
  conceptLinkSeparator?: string;
  /**
   * Column name for narrower concept id. Default is narrower.
   */
  conceptNarrowerIdColumn?: string;
  /**
   * Column name for related concept id. Default is related.
   */
  conceptRelatedIdColumn?: string;
  /**
   * Type of thesaurus, usually one of the ISO thesaurus type codelist value. Default is theme.
   */
  dir?: string;
  /**
   * Encoding. Default is UTF-8.
   */
  encoding?: string;
  /**
   * Import CSV file as thesaurus if true (detault) or return it in  SKOS format.
   */
  importAsThesaurus?: boolean;
  /**
   * Thesaurus languages
   */
  languages?: Array<string>;
  requestBody?: {
    /**
     * If set, do a file upload.
     */
    file?: Blob | File;
  };
  /**
   * Thesaurus namespace. Default is filename.
   */
  thesaurusNs?: string;
  /**
   * Thesaurus title. Default is filename.
   */
  thesaurusTitle?: string;
  /**
   * Local or external (default).
   */
  type?: 'external' | 'local';
};

export type ImportCsvAsThesaurusResponse = unknown;

export type GetKeywordByIdData = {
  /**
   * Keyword identifier or list of keyword identifiers comma separated.
   */
  id: string;
  /**
   * Only print the keyword, no thesaurus information.
   */
  keywordOnly?: boolean;
  /**
   * Languages.
   */
  lang?: Array<string>;
  /**
   * langMap, that converts the values in the 'lang' parameter to how they will be actually represented in the record. {'fre':'fra'} or {'fre':'fr'}.  Missing/empty means to convert to iso 2 letter.
   */
  langMap?: string;
  /**
   * Thesaurus to look info for the keyword(s).
   */
  thesaurus: string;
  /**
   * XSL template to use (ISO19139 keyword by default, see convert.xsl).
   */
  transformation?: string;
};

export type GetKeywordByIdResponse = {
  [key: string]: unknown;
};

export type GetKeywordByIdsData = {
  /**
   * Keyword identifier or list of keyword identifiers comma separated.
   */
  id: string;
  /**
   * Only print the keyword, no thesaurus information.
   */
  keywordOnly?: boolean;
  /**
   * Languages.
   */
  lang?: Array<string>;
  /**
   * langMap, that converts the values in the 'lang' parameter to how they will be actually represented in the record. {'fre':'fra'} or {'fre':'fr'}.  Missing/empty means to convert to iso 2 letter.
   */
  langMap?: string;
  /**
   * Thesaurus to look info for the keyword(s).
   */
  thesaurus: string;
  /**
   * XSL template to use (ISO19139 keyword by default, see convert.xsl).
   */
  transformation?: string;
};

export type GetKeywordByIdsResponse = {
  [key: string]: unknown;
};

export type SearchKeywordsData = {
  /**
   * Query in that language
   */
  lang?: string;
  /**
   * Return keyword information in one or more languages
   */
  pLang?: Array<string>;
  /**
   * Query
   */
  q?: string;
  /**
   * Number of rows
   */
  rows?: number;
  /**
   * Sort by
   */
  sort?: string;
  /**
   * Start from
   */
  start?: number;
  /**
   * Thesaurus identifier
   */
  thesaurus?: Array<string>;
  /**
   * Type of search
   */
  type?: 'STARTS_WITH' | 'CONTAINS' | 'MATCH';
  /**
   * URI query
   */
  uri?: string;
};

export type SearchKeywordsResponse = {
  [key: string]: unknown;
};

export type DeleteThesaurusData = {
  /**
   * Thesaurus to delete.
   */
  thesaurus: string;
};

export type DeleteThesaurusResponse = unknown;

export type GetThesaurusData = {
  /**
   * Thesaurus to download.
   */
  thesaurus: string;
};

export type GetThesaurusResponse = Blob | File;

export type UpdateThesaurusData = {
  requestBody: ThesaurusInfo;
  /**
   * Thesaurus to update.
   */
  thesaurus: string;
};

export type UpdateThesaurusResponse = unknown;

export type GetAssociatedResourcesForRecordsData = {
  /**
   * Use approved version or not
   */
  approved?: boolean;
  /**
   * Type of related resource. If none, all resources are returned.
   */
  type?: Array<RelatedItemType>;
  /**
   * Uuids of the metadatas you request the relations from.
   */
  uuid?: Array<string>;
};

export type GetAssociatedResourcesForRecordsResponse = {
  [key: string]: RelatedResponse;
};

export type GetReportDataDownloadsData = {
  /**
   * From date of the metadata downloads
   */
  dateFrom: string;
  /**
   * To date of the metadata downloads
   */
  dateTo: string;
  /**
   * Metadata group(s)
   */
  groups?: Array<number>;
};

export type GetReportDataDownloadsResponse = unknown;

export type GetReportDataUploadsData = {
  /**
   * From date of the metadata uploads
   */
  dateFrom: string;
  /**
   * To date of the metadata uploads
   */
  dateTo: string;
  /**
   * Metadata group(s)
   */
  groups?: Array<number>;
};

export type GetReportDataUploadsResponse = unknown;

export type GetReportInternalMetadataData = {
  /**
   * From date of metadata change date
   */
  dateFrom: string;
  /**
   * To date of metadata change date
   */
  dateTo: string;
  /**
   * Metadata group(s)
   */
  groups?: Array<number>;
};

export type GetReportInternalMetadataResponse = unknown;

export type GetReportUpdatedMetadataData = {
  /**
   * From date of metadata change date
   */
  dateFrom: string;
  /**
   * To date of metadata change date
   */
  dateTo: string;
  /**
   * Metadata group(s)
   */
  groups?: Array<number>;
};

export type GetReportUpdatedMetadataResponse = unknown;

export type GetActiveUsersData = {
  /**
   * From date of users login date
   */
  dateFrom: string;
  /**
   * To date of users login date
   */
  dateTo: string;
  /**
   * Group(s) for the users
   */
  groups?: Array<number>;
};

export type GetActiveUsersResponse = unknown;

export type GetRobotsTextResponse = unknown;

export type MsearchData = {
  bucket?: string;
  /**
   * Type of related resource. If none, no associated resource returned.
   */
  relatedType?: Array<RelatedItemType>;
  /**
   * JSON request based on Elasticsearch API.
   */
  requestBody: string;
};

export type MsearchResponse = string;

export type SearchData = {
  bucket?: string;
  /**
   * Type of related resource. If none, no associated resource returned.
   */
  relatedType?: Array<RelatedItemType>;
  /**
   * JSON request based on Elasticsearch API.
   */
  requestBody: estypes.SearchRequest;
};

export type SearchResponse = estypes.SearchResponse<any>;

export type GetSelectionsAndSizeResponse = {
  [key: string]: number;
};

export type ClearData = {
  /**
   * Selection bucket name
   */
  bucket: string;
  /**
   * One or more record UUIDs
   */
  uuid?: Array<string>;
};

export type ClearResponse = number;

export type GetData = {
  /**
   * Bucket name
   */
  bucket: string;
};

export type GetResponse = Array<string>;

export type AddData = {
  /**
   * Bucket name
   */
  bucket: string;
  /**
   * One or more record UUIDs. If null, select all in current search if bucket name is 'metadata' (TODO: remove this limitation?).
   */
  uuid?: Array<string>;
};

export type AddResponse = number;

export type GetSiteOrPortalDescriptionResponse = SettingsListResponse;

export type IndexSiteData = {
  /**
   * Asynchronous mode (only on all records. ie. no selection bucket)
   */
  asynchronous?: boolean;
  /**
   * Selection bucket name
   */
  bucket?: string;
  /**
   * Index. By default only remove record index.
   */
  indices?: Array<string>;
  /**
   * Drop and recreate index
   */
  reset?: boolean;
};

export type IndexSiteResponse = string;

export type IndexCommitResponse = unknown;

export type CommitIndexChangesResponse = unknown;

export type IndexStatusResponse = Status;

export type IndexAndDbSynchronizationStatusResponse = {
  [key: string]: {
    [key: string]: unknown;
  };
};

export type IsIndexingResponse = boolean;

export type GetInformationResponse = SiteInformation;

export type GetSystemInfoResponse = SystemInfo;

export type IsCasEnabledResponse = boolean;

export type GetNotificationLevelResponse = Array<
  | 'statusUserOwner'
  | 'catalogueAdministrator'
  | 'catalogueProfileAdministrator'
  | 'catalogueProfileUserAdmin'
  | 'catalogueProfileReviewer'
  | 'catalogueProfileEditor'
  | 'catalogueProfileRegisteredUser'
  | 'catalogueProfileGuest'
  | 'recordProfileReviewer'
  | 'recordUserAuthor'
  | 'recordGroupEmail'
>;

export type GetProxyConfigurationResponse = ProxyConfiguration;

export type IsReadOnlyResponse = boolean;

export type UpdateStagingProfileData = {
  profile: 'testing' | 'development' | 'production';
};

export type UpdateStagingProfileResponse = void;

export type GetXslTransformationsResponse = Array<string>;

export type GetLogFilesResponse = Array<LogFileResponse>;

export type GetLastActivityData = {
  /**
   * Number of lines to return
   */
  lines?: number;
};

export type GetLastActivityResponse = string;

export type GetLastActivityInAzipResponse = unknown;

export type SetLogoData = {
  /**
   * Create favicon too
   */
  asFavicon?: boolean;
  /**
   * Logo to use for the catalog
   */
  file: string;
};

export type SetLogoResponse = void;

export type GetSettingsSetData = {
  /**
   * Setting key
   */
  key?: Array<string>;
  /**
   * Setting set. A common set of settings to retrieve.
   */
  set?: Array<
    | 'INSPIRE'
    | 'CSW'
    | 'HARVESTER'
    | 'USER_GROUP_ONLY'
    | 'AUTH'
    | 'READ_ONLY'
    | 'INDEX'
    | 'SYSTEMINFO'
    | 'STAGING_PROFILE'
    | 'TYPE'
  >;
};

export type GetSettingsSetResponse = SettingsListResponse;

export type SaveSettingsData = {
  allRequestParams: {
    [key: string]: string;
  };
};

export type SaveSettingsResponse = void;

export type GetSettingsDetailsData = {
  /**
   * Setting key
   */
  key?: Array<string>;
  /**
   * Setting set. A common set of settings to retrieve.
   */
  set?: Array<
    | 'INSPIRE'
    | 'CSW'
    | 'HARVESTER'
    | 'USER_GROUP_ONLY'
    | 'AUTH'
    | 'READ_ONLY'
    | 'INDEX'
    | 'SYSTEMINFO'
    | 'STAGING_PROFILE'
    | 'TYPE'
  >;
};

export type GetSettingsDetailsResponse = Array<Setting>;

export type GetSitemapData = {
  /**
   * page.
   */
  doc?: number;
  /**
   * Format (xml or html).
   */
  format?: string;
};

export type GetSitemapResponse = unknown;

export type GetSourcesData = {
  /**
   * Group owner of the source (only applies to subportal).
   */
  group?: number;
};

export type GetSourcesResponse = Array<Source>;

export type AddSourceData = {
  requestBody: Source;
};

export type AddSourceResponse = string;

export type DeleteSourceData = {
  /**
   * Source identifier
   */
  sourceIdentifier: string;
};

export type DeleteSourceResponse = string;

export type UpdateSourceData = {
  requestBody: Source;
  /**
   * Source identifier
   */
  sourceIdentifier: string;
};

export type UpdateSourceResponse = string;

export type GetSourcesByTypeData = {
  type: 'portal' | 'subportal' | 'externalportal' | 'harvester';
};

export type GetSourcesByTypeResponse = Array<Source>;

export type GetStandardConfigurationsResponse = unknown;

export type GetConfigurationsData = {
  /**
   * Schema identifiers
   */
  schema?: Array<string>;
};

export type GetConfigurationsResponse = {
  [key: string]: BatchEditing;
};

export type ReloadSchemaResponse = unknown;

export type GetConfigurationData = {
  /**
   * Schema identifier
   */
  schema: string;
};

export type GetConfigurationResponse = {
  [key: string]: BatchEditing;
};

export type GetCodelistsTranslationsData = {
  /**
   * Codelist element name or alias
   */
  codelist: Array<string>;
  /**
   * Schema identifier
   */
  schema: string;
};

export type GetCodelistsTranslationsResponse = {
  [key: string]: string;
};

export type GetSchemaTranslationsData = {
  /**
   * Codelist element name or alias
   */
  codelist: string;
  displayIf?: string;
  isoType?: string;
  parent?: string;
  /**
   * Schema identifier
   */
  schema: string;
  xpath?: string;
};

export type GetSchemaTranslationsResponse = {
  [key: string]: string;
};

export type GetSchemaCodelistsWithDetailsData = {
  /**
   * Codelist element name or alias
   */
  codelist: string;
  /**
   * Display if condition as defined in the codelist.xml file. Allows to select a more precise codelist when more than one is defined for same name.
   */
  displayIf?: string;
  /**
   * ISO type of the element to target which may indicate a more precise label as defined in context attribute. (Same as context. TODO: Deprecate ?)
   */
  isoType?: string;
  /**
   * Parent name with namespace which may indicate a more precise label as defined in context attribute.
   */
  parent?: string;
  /**
   * Schema identifier
   */
  schema: string;
  /**
   * XPath of the element to target which may indicate a more precise label as defined in context attribute.
   */
  xpath?: string;
};

export type GetSchemaCodelistsWithDetailsResponse = Codelist;

export type GetElementDetailsData = {
  displayIf?: string;
  /**
   * Descriptor name
   */
  element: string;
  isoType?: string;
  parent?: string;
  /**
   * Schema identifier
   */
  schema: string;
  xpath?: string;
};

export type GetElementDetailsResponse = Element;

export type GetEditorAssociatedPanelConfigurationData = {
  /**
   * Configuration identifier
   */
  name: string;
  /**
   * Schema identifier
   */
  schema: string;
};

export type GetEditorAssociatedPanelConfigurationResponse = string;

export type DeleteAllHistoryAndStatusResponse = void;

export type GetStatusListResponse = Array<StatusValue>;

export type GetStatusByTypeData = {
  /**
   * Type
   */
  type: 'workflow' | 'task' | 'event';
};

export type GetStatusByTypeResponse = Array<StatusValue>;

export type GetTagsResponse = Array<MetadataCategory>;

export type PutTagData = {
  requestBody: MetadataCategory;
};

export type PutTagResponse = number;

export type DeleteTagData = {
  /**
   * Tag identifier
   */
  tagIdentifier: number;
};

export type DeleteTagResponse = string;

export type GetTagData = {
  /**
   * Tag identifier
   */
  tagIdentifier: number;
};

export type GetTagResponse = MetadataCategory;

export type UpdateTagData = {
  requestBody: MetadataCategory;
  /**
   * Tag identifier
   */
  tagIdentifier: number;
};

export type UpdateTagResponse = string;

export type TestMailConfigurationResponse = string;

export type CallStepData = {
  /**
   * Class name to execute corresponding to a migration step. See DatabaseMigrationTask.
   */
  stepName: string;
};

export type CallStepResponse = string;

export type BuildFilterData = {
  /**
   * The filters in JSON
   */
  filters: string;
};

export type BuildFilterResponse = string;

export type DeteleSldResponse = unknown;

export type GetSldResponse = Array<string>;

export type BuildSldData = {
  /**
   * The filters in JSON
   */
  filters: string;
  /**
   * The layers
   */
  layers: string;
  /**
   * The WMS server URL
   */
  url: string;
};

export type BuildSldResponse = string;

export type DownloadSldData = {
  extension: string;
  /**
   * The SLD identifier
   */
  id: number;
};

export type DownloadSldResponse = unknown;

export type GetTranslationProviderNamesResponse = Array<string>;

export type GetUiConfigurationsResponse = Array<UiSetting>;

export type PutUiConfigurationData = {
  requestBody: UiSetting;
};

export type PutUiConfigurationResponse = string;

export type DeleteUiConfigurationData = {
  /**
   * UI configuration identifier
   */
  uiIdentifier: string;
};

export type DeleteUiConfigurationResponse = string;

export type GetUiConfigurationData = {
  /**
   * UI identifier
   */
  uiIdentifier: string;
};

export type GetUiConfigurationResponse = UiSetting;

export type UpdateUiConfigurationData = {
  requestBody: UiSetting;
  /**
   * UI configuration identifier
   */
  uiIdentifier: string;
};

export type UpdateUiConfigurationResponse = string;

export type SendPasswordByEmailData = {
  /**
   * The user name
   */
  username: string;
};

export type SendPasswordByEmailResponse = string;

export type RegisterUserData = {
  requestBody: UserRegisterDto;
};

export type RegisterUserResponse = string;

export type UpdatePasswordData = {
  requestBody: PasswordUpdateParameter;
  /**
   * The user name
   */
  username: string;
};

export type UpdatePasswordResponse = string;

export type GetUserCommentsData = {
  /**
   * Metadata record UUID.
   */
  metadataUuid?: string;
  /**
   * Maximum number of feedback to return.
   */
  size?: number;
};

export type GetUserCommentsResponse = Array<UserFeedbackDTO>;

export type NewUserFeedbackData = {
  requestBody: UserFeedbackDTO;
};

export type NewUserFeedbackResponse = string;

export type GetRatingCriteriaResponse = Array<RatingCriteria>;

export type DeleteUserFeedbackData = {
  /**
   * User feedback UUID.
   */
  uuid: string;
};

export type DeleteUserFeedbackResponse = string;

export type GetUserCommentData = {
  /**
   * User feedback UUID.
   */
  uuid: string;
};

export type GetUserCommentResponse = UserFeedbackDTO;

export type PublishFeedbackData = {
  /**
   * User feedback UUID.
   */
  uuid: string;
};

export type PublishFeedbackResponse = string;

export type GetUsersResponse = Array<User>;

export type CreateUserData = {
  requestBody: UserDto;
};

export type CreateUserResponse = string;

export type RetrieveAllUserGroupsResponse = Array<UserGroupsResponse>;

export type GetRecordOwnersResponse = Array<OwnerResponse>;

export type SaveOwnersData = {
  requestBody: TransferRequest;
};

export type SaveOwnersResponse = string;

export type CheckUserPropertyExistData = {
  /**
   * The value to search
   */
  exist: string;
  /**
   * The user property to check
   */
  property: string;
};

export type CheckUserPropertyExistResponse =
  | 'CONTINUE'
  | 'SWITCHING_PROTOCOLS'
  | 'PROCESSING'
  | 'CHECKPOINT'
  | 'OK'
  | 'CREATED'
  | 'ACCEPTED'
  | 'NON_AUTHORITATIVE_INFORMATION'
  | 'NO_CONTENT'
  | 'RESET_CONTENT'
  | 'PARTIAL_CONTENT'
  | 'MULTI_STATUS'
  | 'ALREADY_REPORTED'
  | 'IM_USED'
  | 'MULTIPLE_CHOICES'
  | 'MOVED_PERMANENTLY'
  | 'FOUND'
  | 'MOVED_TEMPORARILY'
  | 'SEE_OTHER'
  | 'NOT_MODIFIED'
  | 'USE_PROXY'
  | 'TEMPORARY_REDIRECT'
  | 'PERMANENT_REDIRECT'
  | 'BAD_REQUEST'
  | 'UNAUTHORIZED'
  | 'PAYMENT_REQUIRED'
  | 'FORBIDDEN'
  | 'NOT_FOUND'
  | 'METHOD_NOT_ALLOWED'
  | 'NOT_ACCEPTABLE'
  | 'PROXY_AUTHENTICATION_REQUIRED'
  | 'REQUEST_TIMEOUT'
  | 'CONFLICT'
  | 'GONE'
  | 'LENGTH_REQUIRED'
  | 'PRECONDITION_FAILED'
  | 'PAYLOAD_TOO_LARGE'
  | 'REQUEST_ENTITY_TOO_LARGE'
  | 'URI_TOO_LONG'
  | 'REQUEST_URI_TOO_LONG'
  | 'UNSUPPORTED_MEDIA_TYPE'
  | 'REQUESTED_RANGE_NOT_SATISFIABLE'
  | 'EXPECTATION_FAILED'
  | 'I_AM_A_TEAPOT'
  | 'INSUFFICIENT_SPACE_ON_RESOURCE'
  | 'METHOD_FAILURE'
  | 'DESTINATION_LOCKED'
  | 'UNPROCESSABLE_ENTITY'
  | 'LOCKED'
  | 'FAILED_DEPENDENCY'
  | 'TOO_EARLY'
  | 'UPGRADE_REQUIRED'
  | 'PRECONDITION_REQUIRED'
  | 'TOO_MANY_REQUESTS'
  | 'REQUEST_HEADER_FIELDS_TOO_LARGE'
  | 'UNAVAILABLE_FOR_LEGAL_REASONS'
  | 'INTERNAL_SERVER_ERROR'
  | 'NOT_IMPLEMENTED'
  | 'BAD_GATEWAY'
  | 'SERVICE_UNAVAILABLE'
  | 'GATEWAY_TIMEOUT'
  | 'HTTP_VERSION_NOT_SUPPORTED'
  | 'VARIANT_ALSO_NEGOTIATES'
  | 'INSUFFICIENT_STORAGE'
  | 'LOOP_DETECTED'
  | 'BANDWIDTH_LIMIT_EXCEEDED'
  | 'NOT_EXTENDED'
  | 'NETWORK_AUTHENTICATION_REQUIRED';

export type DeleteUserData = {
  /**
   * User identifier.
   */
  userIdentifier: number;
};

export type DeleteUserResponse = string;

export type GetUserData = {
  /**
   * User identifier.
   */
  userIdentifier: number;
};

export type GetUserResponse = User;

export type UpdateUserData = {
  requestBody: UserDto;
  /**
   * User identifier.
   */
  userIdentifier: number;
};

export type UpdateUserResponse = string;

export type GetUserIdenticonData = {
  /**
   * Size.
   */
  size?: number;
  /**
   * User identifier.
   */
  userIdentifier: number;
};

export type GetUserIdenticonResponse = unknown;

export type ResetUserPasswordData = {
  requestBody: PasswordResetDto;
  /**
   * User identifier.
   */
  userIdentifier: number;
};

export type ResetUserPasswordResponse = string;

export type RetrieveUserGroupsData = {
  /**
   * User identifier.
   */
  userIdentifier: number;
};

export type RetrieveUserGroupsResponse = Array<UserGroup>;

export type GetUserCustomSearchesResponse = Array<UserSearchDto>;

export type CreateUserCustomSearchData = {
  requestBody: UserSearchDto;
};

export type CreateUserCustomSearchResponse = number;

export type GetAllUserCustomSearchesData = {
  /**
   * Featured type search.
   */
  featuredType?: 'HOME' | 'EDITOR_BOARD';
};

export type GetAllUserCustomSearchesResponse = Array<UserSearchDto>;

export type GetAllUserCustomSearchesPageData = {
  /**
   * Featured  type search.
   */
  featuredType?: 'HOME' | 'EDITOR_BOARD';
  /**
   * Number of records to return
   */
  limit?: number;
  /**
   * From page
   */
  offset?: number;
  search?: string;
};

export type GetAllUserCustomSearchesPageResponse = PaginatedUserSearchResponse;

export type GetFeaturedUserCustomSearchesData = {
  /**
   * Number of records to return
   */
  type?: 'HOME' | 'EDITOR_BOARD';
};

export type GetFeaturedUserCustomSearchesResponse = Array<UserSearchDto>;

export type DeleteUserCustomSerachData = {
  /**
   * Search identifier.
   */
  searchIdentifier: number;
};

export type DeleteUserCustomSerachResponse = string;

export type GetUserCustomSearchData = {
  /**
   * User search identifier
   */
  searchIdentifier: number;
};

export type GetUserCustomSearchResponse = UserSearchDto;

export type UpdateCustomUserSearchData = {
  requestBody: UserSearchDto;
  /**
   * User search identifier
   */
  searchIdentifier: number;
};

export type UpdateCustomUserSearchResponse = void;

export type GetSelectionListResponse = Array<Selection>;

export type CreatePersistentSelectionTypeData = {
  requestBody: Selection;
};

export type CreatePersistentSelectionTypeResponse = string;

export type DeleteUserSelectionData = {
  /**
   * Selection identifier
   */
  selectionIdentifier: number;
};

export type DeleteUserSelectionResponse = string;

export type UpdateUserSelectionData = {
  requestBody: Selection;
  /**
   * Selection identifier
   */
  selectionIdentifier: number;
};

export type UpdateUserSelectionResponse = string;

export type DeleteFromUserSelectionData = {
  /**
   * Selection identifier
   */
  selectionIdentifier: number;
  /**
   * User identifier
   */
  userIdentifier: number;
  /**
   * One or more record UUIDs. If null, remove all.
   */
  uuid?: Array<string>;
};

export type DeleteFromUserSelectionResponse = string;

export type GetSelectionRecordsData = {
  /**
   * Selection identifier
   */
  selectionIdentifier: number;
  /**
   * User identifier
   */
  userIdentifier: number;
};

export type GetSelectionRecordsResponse = Array<string>;

export type AddToUserSelectionData = {
  /**
   * Selection identifier
   */
  selectionIdentifier: number;
  /**
   * User identifier
   */
  userIdentifier: number;
  /**
   * One or more record UUIDs.
   */
  uuid?: Array<string>;
};

export type AddToUserSelectionResponse = string;

export type $OpenApiTs = {
  '/atom/describe/resource': {
    get: {
      req: DescribeResourceData;
      res: {
        /**
         * Feeds.
         */
        200: unknown;
        /**
         * Not authenticated.
         */
        204: void;
      };
    };
  };
  '/atom/describe/service/{metadataUuid}': {
    get: {
      req: DescribeData;
      res: {
        /**
         * Feeds.
         */
        200: unknown;
        /**
         * Not authenticated.
         */
        204: void;
      };
    };
  };
  '/atom/download/resource': {
    get: {
      req: DownloadResourceData;
      res: {
        /**
         * Get a data file related to dataset
         */
        200: unknown;
        /**
         * Not authenticated.
         */
        204: void;
      };
    };
  };
  '/atom/feeds': {
    get: {
      req: FeedsData;
      res: {
        /**
         * Get a list of feeds.
         */
        200: {
          [key: string]: unknown;
        };
      };
    };
  };
  '/atom/scan': {
    get: {
      res: {
        /**
         * Scan completed.
         */
        201: {
          [key: string]: unknown;
        };
      };
    };
  };
  '/customstyle': {
    get: {
      res: {
        /**
         * OK
         */
        200: {
          [key: string]: string;
        };
      };
    };
    post: {
      req: SaveCssStyleData;
      res: {
        /**
         * Created
         */
        201: string;
      };
    };
  };
  '/formatters': {
    get: {
      req: ListFormattersData;
      res: {
        /**
         * OK
         */
        200: FormatterDataResponse;
      };
    };
    post: {
      req: AddFormatterData;
      res: {
        /**
         * Created
         */
        201: unknown;
      };
    };
  };
  '/formatters/cache': {
    delete: {
      res: {
        /**
         * Cache cleared.
         */
        204: void;
        /**
         * Operation not allowed. Only Administrator can access it.
         */
        403: unknown;
      };
    };
  };
  '/formatters/{schema}/{formatter}': {
    delete: {
      req: DeleteFormatterData;
      res: {
        /**
         * No Content
         */
        204: void;
      };
    };
    get: {
      req: DownloadFormatterData;
      res: {
        /**
         * OK
         */
        200: unknown;
      };
    };
  };
  '/formatters/{schema}/{formatter}/files': {
    get: {
      req: GetFormatterFilesData;
      res: {
        /**
         * OK
         */
        200: string;
      };
    };
  };
  '/formatters/{schema}/{formatter}/files/{file}': {
    get: {
      req: GetFormatterFileContentData;
      res: {
        /**
         * OK
         */
        200: string;
      };
    };
    post: {
      req: UpdateFormatterFileData;
      res: {
        /**
         * Created
         */
        201: unknown;
      };
    };
  };
  '/groups': {
    get: {
      req: GetGroupsData;
      res: {
        /**
         * OK
         */
        200: Array<Group>;
      };
    };
    put: {
      req: AddGroupData;
      res: {
        /**
         * Group created.
         */
        201: number;
        /**
         * Group with that id or name already exist.
         */
        400: number;
        /**
         * Operation not allowed. Only UserAdmins can access it.
         */
        403: number;
      };
    };
  };
  '/groups/{groupIdentifier}': {
    delete: {
      req: DeleteGroupData;
      res: {
        /**
         * Group removed.
         */
        204: void;
        /**
         * Operation not allowed. Only UserAdmins can access it.
         */
        403: unknown;
        /**
         * Resource not found.
         */
        404: unknown;
      };
    };
    get: {
      req: GetGroupData;
      res: {
        /**
         * Group information for the group id supplied.
         */
        200: Group;
        /**
         * Resource not found.
         */
        404: Group;
      };
    };
    put: {
      req: UpdateGroupData;
      res: {
        /**
         * Group updated.
         */
        204: void;
        /**
         * Operation not allowed. Only UserAdmins can access it.
         */
        403: unknown;
        /**
         * Resource not found.
         */
        404: unknown;
      };
    };
  };
  '/groups/{groupIdentifier}/users': {
    get: {
      req: GetGroupUsersData;
      res: {
        /**
         * List of users in that group.
         */
        200: Array<User>;
        /**
         * Operation not allowed. Only UserAdmins can access it.
         */
        403: Array<User>;
        /**
         * Resource not found.
         */
        404: Array<User>;
      };
    };
  };
  '/groups/{groupId}/logo': {
    get: {
      req: GetGroupLogoData;
      res: {
        /**
         * OK
         */
        200: unknown;
      };
    };
  };
  '/harvesters/properties/{property}': {
    get: {
      req: CheckHarvesterPropertyExistData;
      res: {
        /**
         * Property does not exist.
         */
        200:
          | 'CONTINUE'
          | 'SWITCHING_PROTOCOLS'
          | 'PROCESSING'
          | 'CHECKPOINT'
          | 'OK'
          | 'CREATED'
          | 'ACCEPTED'
          | 'NON_AUTHORITATIVE_INFORMATION'
          | 'NO_CONTENT'
          | 'RESET_CONTENT'
          | 'PARTIAL_CONTENT'
          | 'MULTI_STATUS'
          | 'ALREADY_REPORTED'
          | 'IM_USED'
          | 'MULTIPLE_CHOICES'
          | 'MOVED_PERMANENTLY'
          | 'FOUND'
          | 'MOVED_TEMPORARILY'
          | 'SEE_OTHER'
          | 'NOT_MODIFIED'
          | 'USE_PROXY'
          | 'TEMPORARY_REDIRECT'
          | 'PERMANENT_REDIRECT'
          | 'BAD_REQUEST'
          | 'UNAUTHORIZED'
          | 'PAYMENT_REQUIRED'
          | 'FORBIDDEN'
          | 'NOT_FOUND'
          | 'METHOD_NOT_ALLOWED'
          | 'NOT_ACCEPTABLE'
          | 'PROXY_AUTHENTICATION_REQUIRED'
          | 'REQUEST_TIMEOUT'
          | 'CONFLICT'
          | 'GONE'
          | 'LENGTH_REQUIRED'
          | 'PRECONDITION_FAILED'
          | 'PAYLOAD_TOO_LARGE'
          | 'REQUEST_ENTITY_TOO_LARGE'
          | 'URI_TOO_LONG'
          | 'REQUEST_URI_TOO_LONG'
          | 'UNSUPPORTED_MEDIA_TYPE'
          | 'REQUESTED_RANGE_NOT_SATISFIABLE'
          | 'EXPECTATION_FAILED'
          | 'I_AM_A_TEAPOT'
          | 'INSUFFICIENT_SPACE_ON_RESOURCE'
          | 'METHOD_FAILURE'
          | 'DESTINATION_LOCKED'
          | 'UNPROCESSABLE_ENTITY'
          | 'LOCKED'
          | 'FAILED_DEPENDENCY'
          | 'TOO_EARLY'
          | 'UPGRADE_REQUIRED'
          | 'PRECONDITION_REQUIRED'
          | 'TOO_MANY_REQUESTS'
          | 'REQUEST_HEADER_FIELDS_TOO_LARGE'
          | 'UNAVAILABLE_FOR_LEGAL_REASONS'
          | 'INTERNAL_SERVER_ERROR'
          | 'NOT_IMPLEMENTED'
          | 'BAD_GATEWAY'
          | 'SERVICE_UNAVAILABLE'
          | 'GATEWAY_TIMEOUT'
          | 'HTTP_VERSION_NOT_SUPPORTED'
          | 'VARIANT_ALSO_NEGOTIATES'
          | 'INSUFFICIENT_STORAGE'
          | 'LOOP_DETECTED'
          | 'BANDWIDTH_LIMIT_EXCEEDED'
          | 'NOT_EXTENDED'
          | 'NETWORK_AUTHENTICATION_REQUIRED';
        /**
         * Operation not allowed. Only UserAdmins can access it.
         */
        403:
          | 'CONTINUE'
          | 'SWITCHING_PROTOCOLS'
          | 'PROCESSING'
          | 'CHECKPOINT'
          | 'OK'
          | 'CREATED'
          | 'ACCEPTED'
          | 'NON_AUTHORITATIVE_INFORMATION'
          | 'NO_CONTENT'
          | 'RESET_CONTENT'
          | 'PARTIAL_CONTENT'
          | 'MULTI_STATUS'
          | 'ALREADY_REPORTED'
          | 'IM_USED'
          | 'MULTIPLE_CHOICES'
          | 'MOVED_PERMANENTLY'
          | 'FOUND'
          | 'MOVED_TEMPORARILY'
          | 'SEE_OTHER'
          | 'NOT_MODIFIED'
          | 'USE_PROXY'
          | 'TEMPORARY_REDIRECT'
          | 'PERMANENT_REDIRECT'
          | 'BAD_REQUEST'
          | 'UNAUTHORIZED'
          | 'PAYMENT_REQUIRED'
          | 'FORBIDDEN'
          | 'NOT_FOUND'
          | 'METHOD_NOT_ALLOWED'
          | 'NOT_ACCEPTABLE'
          | 'PROXY_AUTHENTICATION_REQUIRED'
          | 'REQUEST_TIMEOUT'
          | 'CONFLICT'
          | 'GONE'
          | 'LENGTH_REQUIRED'
          | 'PRECONDITION_FAILED'
          | 'PAYLOAD_TOO_LARGE'
          | 'REQUEST_ENTITY_TOO_LARGE'
          | 'URI_TOO_LONG'
          | 'REQUEST_URI_TOO_LONG'
          | 'UNSUPPORTED_MEDIA_TYPE'
          | 'REQUESTED_RANGE_NOT_SATISFIABLE'
          | 'EXPECTATION_FAILED'
          | 'I_AM_A_TEAPOT'
          | 'INSUFFICIENT_SPACE_ON_RESOURCE'
          | 'METHOD_FAILURE'
          | 'DESTINATION_LOCKED'
          | 'UNPROCESSABLE_ENTITY'
          | 'LOCKED'
          | 'FAILED_DEPENDENCY'
          | 'TOO_EARLY'
          | 'UPGRADE_REQUIRED'
          | 'PRECONDITION_REQUIRED'
          | 'TOO_MANY_REQUESTS'
          | 'REQUEST_HEADER_FIELDS_TOO_LARGE'
          | 'UNAVAILABLE_FOR_LEGAL_REASONS'
          | 'INTERNAL_SERVER_ERROR'
          | 'NOT_IMPLEMENTED'
          | 'BAD_GATEWAY'
          | 'SERVICE_UNAVAILABLE'
          | 'GATEWAY_TIMEOUT'
          | 'HTTP_VERSION_NOT_SUPPORTED'
          | 'VARIANT_ALSO_NEGOTIATES'
          | 'INSUFFICIENT_STORAGE'
          | 'LOOP_DETECTED'
          | 'BANDWIDTH_LIMIT_EXCEEDED'
          | 'NOT_EXTENDED'
          | 'NETWORK_AUTHENTICATION_REQUIRED';
        /**
         * A property with that value already exist.
         */
        404:
          | 'CONTINUE'
          | 'SWITCHING_PROTOCOLS'
          | 'PROCESSING'
          | 'CHECKPOINT'
          | 'OK'
          | 'CREATED'
          | 'ACCEPTED'
          | 'NON_AUTHORITATIVE_INFORMATION'
          | 'NO_CONTENT'
          | 'RESET_CONTENT'
          | 'PARTIAL_CONTENT'
          | 'MULTI_STATUS'
          | 'ALREADY_REPORTED'
          | 'IM_USED'
          | 'MULTIPLE_CHOICES'
          | 'MOVED_PERMANENTLY'
          | 'FOUND'
          | 'MOVED_TEMPORARILY'
          | 'SEE_OTHER'
          | 'NOT_MODIFIED'
          | 'USE_PROXY'
          | 'TEMPORARY_REDIRECT'
          | 'PERMANENT_REDIRECT'
          | 'BAD_REQUEST'
          | 'UNAUTHORIZED'
          | 'PAYMENT_REQUIRED'
          | 'FORBIDDEN'
          | 'NOT_FOUND'
          | 'METHOD_NOT_ALLOWED'
          | 'NOT_ACCEPTABLE'
          | 'PROXY_AUTHENTICATION_REQUIRED'
          | 'REQUEST_TIMEOUT'
          | 'CONFLICT'
          | 'GONE'
          | 'LENGTH_REQUIRED'
          | 'PRECONDITION_FAILED'
          | 'PAYLOAD_TOO_LARGE'
          | 'REQUEST_ENTITY_TOO_LARGE'
          | 'URI_TOO_LONG'
          | 'REQUEST_URI_TOO_LONG'
          | 'UNSUPPORTED_MEDIA_TYPE'
          | 'REQUESTED_RANGE_NOT_SATISFIABLE'
          | 'EXPECTATION_FAILED'
          | 'I_AM_A_TEAPOT'
          | 'INSUFFICIENT_SPACE_ON_RESOURCE'
          | 'METHOD_FAILURE'
          | 'DESTINATION_LOCKED'
          | 'UNPROCESSABLE_ENTITY'
          | 'LOCKED'
          | 'FAILED_DEPENDENCY'
          | 'TOO_EARLY'
          | 'UPGRADE_REQUIRED'
          | 'PRECONDITION_REQUIRED'
          | 'TOO_MANY_REQUESTS'
          | 'REQUEST_HEADER_FIELDS_TOO_LARGE'
          | 'UNAVAILABLE_FOR_LEGAL_REASONS'
          | 'INTERNAL_SERVER_ERROR'
          | 'NOT_IMPLEMENTED'
          | 'BAD_GATEWAY'
          | 'SERVICE_UNAVAILABLE'
          | 'GATEWAY_TIMEOUT'
          | 'HTTP_VERSION_NOT_SUPPORTED'
          | 'VARIANT_ALSO_NEGOTIATES'
          | 'INSUFFICIENT_STORAGE'
          | 'LOOP_DETECTED'
          | 'BANDWIDTH_LIMIT_EXCEEDED'
          | 'NOT_EXTENDED'
          | 'NETWORK_AUTHENTICATION_REQUIRED';
      };
    };
  };
  '/harvesters/{harvesterUuid}/assign': {
    post: {
      req: AssignHarvestedRecordToSourceData;
      res: {
        /**
         * Harvester records transfered to new source.
         */
        204:
          | 'CONTINUE'
          | 'SWITCHING_PROTOCOLS'
          | 'PROCESSING'
          | 'CHECKPOINT'
          | 'OK'
          | 'CREATED'
          | 'ACCEPTED'
          | 'NON_AUTHORITATIVE_INFORMATION'
          | 'NO_CONTENT'
          | 'RESET_CONTENT'
          | 'PARTIAL_CONTENT'
          | 'MULTI_STATUS'
          | 'ALREADY_REPORTED'
          | 'IM_USED'
          | 'MULTIPLE_CHOICES'
          | 'MOVED_PERMANENTLY'
          | 'FOUND'
          | 'MOVED_TEMPORARILY'
          | 'SEE_OTHER'
          | 'NOT_MODIFIED'
          | 'USE_PROXY'
          | 'TEMPORARY_REDIRECT'
          | 'PERMANENT_REDIRECT'
          | 'BAD_REQUEST'
          | 'UNAUTHORIZED'
          | 'PAYMENT_REQUIRED'
          | 'FORBIDDEN'
          | 'NOT_FOUND'
          | 'METHOD_NOT_ALLOWED'
          | 'NOT_ACCEPTABLE'
          | 'PROXY_AUTHENTICATION_REQUIRED'
          | 'REQUEST_TIMEOUT'
          | 'CONFLICT'
          | 'GONE'
          | 'LENGTH_REQUIRED'
          | 'PRECONDITION_FAILED'
          | 'PAYLOAD_TOO_LARGE'
          | 'REQUEST_ENTITY_TOO_LARGE'
          | 'URI_TOO_LONG'
          | 'REQUEST_URI_TOO_LONG'
          | 'UNSUPPORTED_MEDIA_TYPE'
          | 'REQUESTED_RANGE_NOT_SATISFIABLE'
          | 'EXPECTATION_FAILED'
          | 'I_AM_A_TEAPOT'
          | 'INSUFFICIENT_SPACE_ON_RESOURCE'
          | 'METHOD_FAILURE'
          | 'DESTINATION_LOCKED'
          | 'UNPROCESSABLE_ENTITY'
          | 'LOCKED'
          | 'FAILED_DEPENDENCY'
          | 'TOO_EARLY'
          | 'UPGRADE_REQUIRED'
          | 'PRECONDITION_REQUIRED'
          | 'TOO_MANY_REQUESTS'
          | 'REQUEST_HEADER_FIELDS_TOO_LARGE'
          | 'UNAVAILABLE_FOR_LEGAL_REASONS'
          | 'INTERNAL_SERVER_ERROR'
          | 'NOT_IMPLEMENTED'
          | 'BAD_GATEWAY'
          | 'SERVICE_UNAVAILABLE'
          | 'GATEWAY_TIMEOUT'
          | 'HTTP_VERSION_NOT_SUPPORTED'
          | 'VARIANT_ALSO_NEGOTIATES'
          | 'INSUFFICIENT_STORAGE'
          | 'LOOP_DETECTED'
          | 'BANDWIDTH_LIMIT_EXCEEDED'
          | 'NOT_EXTENDED'
          | 'NETWORK_AUTHENTICATION_REQUIRED';
        /**
         * Operation not allowed. Only UserAdmins can access it.
         */
        403:
          | 'CONTINUE'
          | 'SWITCHING_PROTOCOLS'
          | 'PROCESSING'
          | 'CHECKPOINT'
          | 'OK'
          | 'CREATED'
          | 'ACCEPTED'
          | 'NON_AUTHORITATIVE_INFORMATION'
          | 'NO_CONTENT'
          | 'RESET_CONTENT'
          | 'PARTIAL_CONTENT'
          | 'MULTI_STATUS'
          | 'ALREADY_REPORTED'
          | 'IM_USED'
          | 'MULTIPLE_CHOICES'
          | 'MOVED_PERMANENTLY'
          | 'FOUND'
          | 'MOVED_TEMPORARILY'
          | 'SEE_OTHER'
          | 'NOT_MODIFIED'
          | 'USE_PROXY'
          | 'TEMPORARY_REDIRECT'
          | 'PERMANENT_REDIRECT'
          | 'BAD_REQUEST'
          | 'UNAUTHORIZED'
          | 'PAYMENT_REQUIRED'
          | 'FORBIDDEN'
          | 'NOT_FOUND'
          | 'METHOD_NOT_ALLOWED'
          | 'NOT_ACCEPTABLE'
          | 'PROXY_AUTHENTICATION_REQUIRED'
          | 'REQUEST_TIMEOUT'
          | 'CONFLICT'
          | 'GONE'
          | 'LENGTH_REQUIRED'
          | 'PRECONDITION_FAILED'
          | 'PAYLOAD_TOO_LARGE'
          | 'REQUEST_ENTITY_TOO_LARGE'
          | 'URI_TOO_LONG'
          | 'REQUEST_URI_TOO_LONG'
          | 'UNSUPPORTED_MEDIA_TYPE'
          | 'REQUESTED_RANGE_NOT_SATISFIABLE'
          | 'EXPECTATION_FAILED'
          | 'I_AM_A_TEAPOT'
          | 'INSUFFICIENT_SPACE_ON_RESOURCE'
          | 'METHOD_FAILURE'
          | 'DESTINATION_LOCKED'
          | 'UNPROCESSABLE_ENTITY'
          | 'LOCKED'
          | 'FAILED_DEPENDENCY'
          | 'TOO_EARLY'
          | 'UPGRADE_REQUIRED'
          | 'PRECONDITION_REQUIRED'
          | 'TOO_MANY_REQUESTS'
          | 'REQUEST_HEADER_FIELDS_TOO_LARGE'
          | 'UNAVAILABLE_FOR_LEGAL_REASONS'
          | 'INTERNAL_SERVER_ERROR'
          | 'NOT_IMPLEMENTED'
          | 'BAD_GATEWAY'
          | 'SERVICE_UNAVAILABLE'
          | 'GATEWAY_TIMEOUT'
          | 'HTTP_VERSION_NOT_SUPPORTED'
          | 'VARIANT_ALSO_NEGOTIATES'
          | 'INSUFFICIENT_STORAGE'
          | 'LOOP_DETECTED'
          | 'BANDWIDTH_LIMIT_EXCEEDED'
          | 'NOT_EXTENDED'
          | 'NETWORK_AUTHENTICATION_REQUIRED';
        /**
         * Resource not found.
         */
        404:
          | 'CONTINUE'
          | 'SWITCHING_PROTOCOLS'
          | 'PROCESSING'
          | 'CHECKPOINT'
          | 'OK'
          | 'CREATED'
          | 'ACCEPTED'
          | 'NON_AUTHORITATIVE_INFORMATION'
          | 'NO_CONTENT'
          | 'RESET_CONTENT'
          | 'PARTIAL_CONTENT'
          | 'MULTI_STATUS'
          | 'ALREADY_REPORTED'
          | 'IM_USED'
          | 'MULTIPLE_CHOICES'
          | 'MOVED_PERMANENTLY'
          | 'FOUND'
          | 'MOVED_TEMPORARILY'
          | 'SEE_OTHER'
          | 'NOT_MODIFIED'
          | 'USE_PROXY'
          | 'TEMPORARY_REDIRECT'
          | 'PERMANENT_REDIRECT'
          | 'BAD_REQUEST'
          | 'UNAUTHORIZED'
          | 'PAYMENT_REQUIRED'
          | 'FORBIDDEN'
          | 'NOT_FOUND'
          | 'METHOD_NOT_ALLOWED'
          | 'NOT_ACCEPTABLE'
          | 'PROXY_AUTHENTICATION_REQUIRED'
          | 'REQUEST_TIMEOUT'
          | 'CONFLICT'
          | 'GONE'
          | 'LENGTH_REQUIRED'
          | 'PRECONDITION_FAILED'
          | 'PAYLOAD_TOO_LARGE'
          | 'REQUEST_ENTITY_TOO_LARGE'
          | 'URI_TOO_LONG'
          | 'REQUEST_URI_TOO_LONG'
          | 'UNSUPPORTED_MEDIA_TYPE'
          | 'REQUESTED_RANGE_NOT_SATISFIABLE'
          | 'EXPECTATION_FAILED'
          | 'I_AM_A_TEAPOT'
          | 'INSUFFICIENT_SPACE_ON_RESOURCE'
          | 'METHOD_FAILURE'
          | 'DESTINATION_LOCKED'
          | 'UNPROCESSABLE_ENTITY'
          | 'LOCKED'
          | 'FAILED_DEPENDENCY'
          | 'TOO_EARLY'
          | 'UPGRADE_REQUIRED'
          | 'PRECONDITION_REQUIRED'
          | 'TOO_MANY_REQUESTS'
          | 'REQUEST_HEADER_FIELDS_TOO_LARGE'
          | 'UNAVAILABLE_FOR_LEGAL_REASONS'
          | 'INTERNAL_SERVER_ERROR'
          | 'NOT_IMPLEMENTED'
          | 'BAD_GATEWAY'
          | 'SERVICE_UNAVAILABLE'
          | 'GATEWAY_TIMEOUT'
          | 'HTTP_VERSION_NOT_SUPPORTED'
          | 'VARIANT_ALSO_NEGOTIATES'
          | 'INSUFFICIENT_STORAGE'
          | 'LOOP_DETECTED'
          | 'BANDWIDTH_LIMIT_EXCEEDED'
          | 'NOT_EXTENDED'
          | 'NETWORK_AUTHENTICATION_REQUIRED';
      };
    };
  };
  '/i18n/cache': {
    delete: {
      res: {
        /**
         * OK
         */
        200: unknown;
      };
    };
  };
  '/i18n/db': {
    get: {
      req: GetTranslationsData;
      res: {
        /**
         * OK
         */
        200: {
          [key: string]: string;
        };
      };
    };
  };
  '/i18n/db/custom': {
    get: {
      req: GetCustomTranslationsData;
      res: {
        /**
         * OK
         */
        200: Array<Translations>;
      };
    };
  };
  '/i18n/db/translations': {
    delete: {
      res: {
        /**
         * Created
         */
        201: unknown;
      };
    };
    get: {
      res: {
        /**
         * OK
         */
        200: {
          [key: string]: string;
        };
      };
    };
    put: {
      req: AddTranslationsData;
      res: {
        /**
         * Created
         */
        201: string;
      };
    };
  };
  '/i18n/db/translations/{key}': {
    delete: {
      req: DeleteTranslationsData;
      res: {
        /**
         * OK
         */
        200: unknown;
      };
    };
    put: {
      req: AddTranslationsForData;
      res: {
        /**
         * Created
         */
        201: string;
      };
    };
  };
  '/i18n/packages': {
    get: {
      res: {
        /**
         * OK
         */
        200: {
          [key: string]: Array<string>;
        };
      };
    };
  };
  '/i18n/packages/{pack}': {
    get: {
      req: GetTranslationsPackageData;
      res: {
        /**
         * OK
         */
        200: {
          [key: string]: string;
        };
      };
    };
  };
  '/identifiers': {
    get: {
      req: GetIdentifiersData;
      res: {
        /**
         * List of identifier templates.
         */
        200: Array<MetadataIdentifierTemplate>;
        /**
         * Operation not allowed. Only Editor can access it.
         */
        403: Array<MetadataIdentifierTemplate>;
      };
    };
    put: {
      req: AddIdentifierData;
      res: {
        /**
         * Identifier template created.
         */
        201: number;
        /**
         * Operation not allowed. Only Editor can access it.
         */
        403: number;
      };
    };
  };
  '/identifiers/{identifier}': {
    delete: {
      req: DeleteIdentifierData;
      res: {
        /**
         * Template identifier removed.
         */
        204: void;
        /**
         * Operation not allowed. Only Editor can access it.
         */
        403: unknown;
        /**
         * Resource not found.
         */
        404: unknown;
      };
    };
    put: {
      req: UpdateIdentifierData;
      res: {
        /**
         * Identifier template updated.
         */
        204: void;
        /**
         * Operation not allowed. Only Editor can access it.
         */
        403: unknown;
        /**
         * Resource not found.
         */
        404: unknown;
      };
    };
  };
  '/isolanguages': {
    get: {
      res: {
        /**
         * OK
         */
        200: Array<IsoLanguage>;
      };
    };
  };
  '/languages': {
    get: {
      res: {
        /**
         * OK
         */
        200: Array<Language>;
      };
    };
  };
  '/languages/application': {
    get: {
      res: {
        /**
         * OK
         */
        200: Array<Language>;
      };
    };
  };
  '/languages/{langCode}': {
    delete: {
      req: DeleteLanguageData;
      res: {
        /**
         * Language translations removed.
         */
        204: void;
        /**
         * Operation not allowed. Only Administrator can access it.
         */
        403: unknown;
        /**
         * Resource not found.
         */
        404: unknown;
      };
    };
    put: {
      req: AddLanguagesData;
      res: {
        /**
         * Language translations added.
         */
        201: unknown;
        /**
         * Operation not allowed. Only Administrator can access it.
         */
        403: unknown;
        /**
         * Resource not found. eg. No SQL file available for that langugae.
         */
        404: unknown;
      };
    };
  };
  '/logos': {
    get: {
      res: {
        /**
         * OK
         */
        200: Array<string>;
      };
    };
    post: {
      req: AddLogoData;
      res: {
        /**
         * Logo added.
         */
        201: string;
        /**
         * Operation not allowed. Only UserAdmins can access it.
         */
        403: string;
      };
    };
  };
  '/logos/{file}': {
    delete: {
      req: DeleteLogoData;
      res: {
        /**
         * Logo removed.
         */
        204: void;
        /**
         * Operation not allowed. Only UserAdmins can access it.
         */
        403: unknown;
        /**
         * Resource not found.
         */
        404: unknown;
      };
    };
    get: {
      req: GetLogoData;
      res: {
        /**
         * Logo returned.
         */
        200: unknown;
        /**
         * Operation not allowed. Only UserAdmins can access it.
         */
        403: unknown;
        /**
         * Resource not found.
         */
        404: unknown;
      };
    };
  };
  '/mapservers': {
    get: {
      res: {
        /**
         * List of all mapservers.
         */
        200: Array<AnonymousMapserver>;
        /**
         * Operation not allowed. Only Editors can access it.
         */
        403: Array<AnonymousMapserver>;
      };
    };
    put: {
      req: AddMapserverData;
      res: {
        /**
         * Mapserver created.
         */
        201: number;
        /**
         * Bad parameters.
         */
        400: number;
        /**
         * Operation not allowed. Only Reviewvers can access it.
         */
        403: number;
      };
    };
  };
  '/mapservers/{mapserverId}': {
    delete: {
      req: DeleteMapserverData;
      res: {
        /**
         * Mapserver removed.
         */
        204: void;
        /**
         * Operation not allowed. Only Reviewvers can access it.
         */
        403: unknown;
        /**
         * Resource not found.
         */
        404: unknown;
      };
    };
    get: {
      req: GetMapserverData;
      res: {
        /**
         * Operation not allowed. Only Editors can access it.
         */
        403: AnonymousMapserver;
        /**
         * Resource not found.
         */
        404: AnonymousMapserver;
      };
    };
    put: {
      req: UpdateMapserverData;
      res: {
        /**
         * Mapserver updated.
         */
        204: void;
        /**
         * Operation not allowed. Only Reviewvers can access it.
         */
        403: unknown;
        /**
         * Resource not found.
         */
        404: unknown;
      };
    };
  };
  '/mapservers/{mapserverId}/auth': {
    post: {
      req: UpdateMapserverAuthData;
      res: {
        /**
         * Mapserver updated.
         */
        204: void;
        /**
         * Operation not allowed. Only Reviewvers can access it.
         */
        403: unknown;
        /**
         * Resource not found.
         */
        404: unknown;
      };
    };
  };
  '/mapservers/{mapserverId}/records/{metadataUuid}': {
    delete: {
      req: DeleteMapserverResourceData;
      res: {
        /**
         * Operation not allowed. Only Editors can access it.
         */
        403: string;
      };
    };
    get: {
      req: GetMapserverResourceData;
      res: {
        /**
         * Operation not allowed. Only Editors can access it.
         */
        403: string;
      };
    };
    put: {
      req: PublishMapserverResourceData;
      res: {
        /**
         * Operation not allowed. Only Editors can access it.
         */
        403: string;
      };
    };
  };
  '/mapservices': {
    get: {
      res: {
        /**
         * OK
         */
        200: Array<MapService>;
      };
    };
  };
  '/me': {
    get: {
      res: {
        /**
         * Authenticated. Return user details.
         */
        200: MeResponse;
      };
    };
  };
  '/operations': {
    get: {
      res: {
        /**
         * OK
         */
        200: Array<Operation>;
      };
    };
  };
  '/pages': {
    get: {
      req: ListPagesData;
      res: {
        /**
         * Operation not allowed. User needs to be able to view the resource.
         */
        403: Array<PageProperties>;
      };
    };
    post: {
      req: AddPageUploadingFileData;
      res: {
        /**
         * Page saved
         */
        201: string;
        /**
         * Wrong parameters are provided
         */
        400: string;
        /**
         * Operation not allowed. User needs to be able to edit the resource.
         */
        403: string;
        /**
         * Page already in the system: use PUT
         */
        409: string;
        /**
         * File not valid
         */
        500: string;
      };
    };
    put: {
      req: AddPageWithoutUploadingFileData;
      res: {
        /**
         * Page saved
         */
        201: string;
        /**
         * Wrong parameters are provided
         */
        400: string;
        /**
         * Operation not allowed. User needs to be able to edit the resource.
         */
        403: string;
        /**
         * Page already in the system: use PUT
         */
        409: string;
        /**
         * File not valid
         */
        500: string;
      };
    };
  };
  '/pages/config/formats': {
    get: {
      res: {
        /**
         * Page found
         */
        200: Array<'LINK' | 'HTML' | 'HTMLPAGE' | 'TEXT'>;
      };
    };
  };
  '/pages/config/sections': {
    get: {
      res: {
        /**
         * Page found
         */
        200: Array<
          | 'TOP'
          | 'FOOTER'
          | 'MENU'
          | 'SUBMENU'
          | 'CUSTOM_MENU1'
          | 'CUSTOM_MENU2'
          | 'CUSTOM_MENU3'
        >;
      };
    };
  };
  '/pages/config/status': {
    get: {
      res: {
        /**
         * Page found
         */
        200: Array<'PUBLIC' | 'PUBLIC_ONLY' | 'PRIVATE' | 'HIDDEN'>;
      };
    };
  };
  '/pages/{language}/{pageId}': {
    delete: {
      req: DeletePageData;
      res: {
        /**
         * Page removed
         */
        200: unknown;
        /**
         * Operation not allowed. User needs to be able to edit the resource.
         */
        403: unknown;
        /**
         * Page not found
         */
        404: unknown;
      };
    };
    get: {
      req: GetPageData;
      res: {
        /**
         * Page found
         */
        200: PageProperties;
        /**
         * Operation not allowed. User needs to be able to view the resource.
         */
        403: PageProperties;
        /**
         * Page not found
         */
        404: PageProperties;
      };
    };
    put: {
      req: UpdatePageData;
      res: {
        /**
         * Page changes saved
         */
        200: unknown;
        /**
         * Operation not allowed. User needs to be able to edit the resource.
         */
        403: unknown;
      };
    };
  };
  '/pages/{language}/{pageId}/content': {
    get: {
      req: GetPageContentData;
      res: {
        /**
         * Page found
         */
        200: string;
        /**
         * Operation not allowed. User needs to be able to view the resource.
         */
        403: string;
        /**
         * Page not found
         */
        404: string;
      };
    };
  };
  '/processes/db/search-and-replace': {
    get: {
      req: PreviewProcessSearchAndReplaceData;
      res: {
        /**
         * Processed records.
         */
        200: {
          [key: string]: unknown;
        };
        /**
         * Operation not allowed. Only Editors can access it.
         */
        403: {
          [key: string]: unknown;
        };
        /**
         * If one record processed is invalid.
         */
        500: {
          [key: string]: unknown;
        };
      };
    };
    post: {
      req: ProcessSearchAndReplaceData;
      res: {
        /**
         * Report about processed records.
         */
        201: XsltMetadataProcessingReport;
        /**
         * Operation not allowed. Only Editors can access it.
         */
        403: XsltMetadataProcessingReport;
      };
    };
  };
  '/processes/reports': {
    delete: {
      res: {
        /**
         * Report registry cleared.
         */
        204: void;
        /**
         * Operation not allowed. Only authenticated user can access it.
         */
        403: unknown;
      };
    };
    get: {
      res: {
        /**
         * List of reports returned.
         */
        200: Array<ProcessingReport>;
        /**
         * Operation not allowed. Only authenticated user can access it.
         */
        403: Array<ProcessingReport>;
      };
    };
  };
  '/processes/search-and-replace': {
    post: {
      req: SearchAndReplaceData;
      res: {
        /**
         * Replacements applied.
         */
        200: MetadataReplacementProcessingReport;
        /**
         * Operation not allowed. Only Editors can access it.
         */
        403: MetadataReplacementProcessingReport;
      };
    };
  };
  '/processes/{process}': {
    get: {
      req: PreviewProcessRecordsData;
      res: {
        /**
         * Processed records.
         */
        200: {
          [key: string]: unknown;
        };
        /**
         * Operation not allowed. Only Editors can access it.
         */
        403: {
          [key: string]: unknown;
        };
      };
    };
    post: {
      req: ProcessRecordsData;
      res: {
        /**
         * Report about processed records.
         */
        201: XsltMetadataProcessingReport;
        /**
         * Operation not allowed. Only Editors can access it.
         */
        403: XsltMetadataProcessingReport;
      };
    };
  };
  '/records': {
    delete: {
      req: DeleteRecordsData;
      res: {
        /**
         * Report about deleted records.
         */
        200: SimpleMetadataProcessingReport;
        /**
         * Operation not allowed. Only Editors can access it.
         */
        403: SimpleMetadataProcessingReport;
      };
    };
    get: {
      req: GetAsRdfData;
      res: {
        /**
         * Return the catalog content as RDF.
         */
        200: unknown;
        /**
         * Redirect the client to the first in-sequence page resource. This happens when the paging parameters (from, hitsPerPage) are not included in the request.
         */
        303: unknown;
      };
    };
    post: {
      req: InsertFileData;
      res: {
        /**
         * Report about imported records.
         */
        201: SimpleMetadataProcessingReport;
        /**
         * Operation not allowed. Only Editors can access it.
         */
        403: SimpleMetadataProcessingReport;
      };
    };
    put: {
      req: InsertData;
      res: {
        /**
         * Report about imported records.
         */
        201: SimpleMetadataProcessingReport;
        /**
         * Operation not allowed. Only Editors can access it.
         */
        403: SimpleMetadataProcessingReport;
      };
    };
  };
  '/records/approve': {
    put: {
      req: ApproveData;
      res: {
        /**
         * Metadata approved .
         */
        200: MetadataProcessingReport;
        /**
         * Metadata workflow not enabled.
         */
        400: MetadataProcessingReport;
      };
    };
  };
  '/records/backups': {
    put: {
      res: {
        /**
         * Return succeed message.
         */
        200: string;
      };
    };
  };
  '/records/backups/latest': {
    get: {
      res: {
        /**
         * Resource not found.
         */
        404: Blob | File;
      };
    };
  };
  '/records/batchediting': {
    put: {
      req: BatchEditData;
      res: {
        /**
         * Return a report of what has been done.
         */
        201: IProcessingReport;
        /**
         * Operation not allowed. User needs to be able to edit the resource.
         */
        403: IProcessingReport;
      };
    };
  };
  '/records/batchediting/preview': {
    post: {
      req: PreviewBatchEditData;
      res: {
        /**
         * Processed records.
         */
        200: {
          [key: string]: unknown;
        };
        /**
         * Operation not allowed. User needs to be able to edit the resource.
         */
        403: {
          [key: string]: unknown;
        };
      };
    };
  };
  '/records/csv': {
    get: {
      req: ExportAsCsvData;
      res: {
        /**
         * Return requested records as CSV.
         */
        200: unknown;
        /**
         * Operation not allowed. User needs to be able to view the resource.
         */
        403: unknown;
      };
    };
  };
  '/records/duplicate': {
    put: {
      req: CreateData;
      res: {
        /**
         * Return the internal id of the newly created record.
         */
        201: string;
        /**
         * Operation not allowed. Only Editors can access it.
         */
        403: string;
      };
    };
  };
  '/records/importfrommap': {
    post: {
      req: InsertOgcMapContextFileData;
      res: {
        /**
         * Report about imported records.
         */
        201: SimpleMetadataProcessingReport;
        /**
         * Operation not allowed. Only Editors can access it.
         */
        403: SimpleMetadataProcessingReport;
      };
    };
  };
  '/records/index': {
    get: {
      req: IndexData;
      res: {
        /**
         * Record indexed.
         */
        200: IndexResponse;
        /**
         * Operation not allowed. Only Administrators can access it.
         */
        403: IndexResponse;
      };
    };
  };
  '/records/links': {
    delete: {
      res: {
        /**
         * OK
         */
        200: unknown;
      };
    };
    get: {
      req: GetRecordLinksData;
      res: {
        /**
         * OK
         */
        200: PageLink;
      };
    };
    post: {
      req: GetRecordLinksPostData;
      res: {
        /**
         * OK
         */
        200: PageLink;
      };
    };
  };
  '/records/links/analyze': {
    post: {
      req: AnalyzeRecordLinksData;
      res: {
        /**
         * Created
         */
        201: SimpleMetadataProcessingReport;
      };
    };
  };
  '/records/links/analyzeurl': {
    post: {
      req: AnalyzeLinksData;
      res: {
        /**
         * Created
         */
        201: unknown;
      };
    };
  };
  '/records/links/csv': {
    get: {
      req: GetRecordLinksAsCsvData;
      res: {
        /**
         * OK
         */
        200: unknown;
      };
    };
  };
  '/records/ownership': {
    put: {
      req: SetGroupAndOwnerData;
      res: {
        /**
         * Records group and owner updated
         */
        201: MetadataProcessingReport;
        /**
         * Operation not allowed. User needs to be able to edit the resource.
         */
        403: MetadataProcessingReport;
      };
    };
  };
  '/records/pdf': {
    get: {
      req: ExportAsPdfData;
      res: {
        /**
         * Return requested records as PDF.
         */
        200: unknown;
        /**
         * Operation not allowed. User needs to be able to view the resource.
         */
        403: unknown;
      };
    };
  };
  '/records/publish': {
    put: {
      req: PublishMultipleRecordsData;
      res: {
        /**
         * Report about updated privileges.
         */
        201: MetadataProcessingReport;
        /**
         * Operation not allowed. Only Editors can access it.
         */
        403: MetadataProcessingReport;
      };
    };
  };
  '/records/samples': {
    put: {
      req: AddSamplesData;
      res: {
        /**
         * Return a report of what has been done.
         */
        201: SimpleMetadataProcessingReport;
        /**
         * Operation not allowed. Only Administrators can access it.
         */
        403: SimpleMetadataProcessingReport;
      };
    };
  };
  '/records/sharing': {
    get: {
      res: {
        /**
         * Return a default array of group and operations that can be used to set record sharing properties.
         */
        200: SharingResponse;
        /**
         * Operation not allowed. User needs to be able to edit the resource.
         */
        403: SharingResponse;
      };
    };
    put: {
      req: ShareMultipleRecordsData;
      res: {
        /**
         * Report about updated privileges.
         */
        201: MetadataProcessingReport;
        /**
         * Operation not allowed. Only Editors can access it.
         */
        403: MetadataProcessingReport;
      };
    };
  };
  '/records/sharing/options': {
    get: {
      res: {
        /**
         * OK
         */
        200: Array<PublicationOption>;
      };
    };
  };
  '/records/status/search': {
    get: {
      req: GetWorkflowStatusByTypeData;
      res: {
        /**
         * OK
         */
        200: Array<MetadataStatusResponse>;
      };
    };
  };
  '/records/submit': {
    put: {
      req: SubmitData;
      res: {
        /**
         * Metadata submitted .
         */
        200: MetadataProcessingReport;
        /**
         * Metadata workflow not enabled.
         */
        400: MetadataProcessingReport;
      };
    };
  };
  '/records/tags': {
    delete: {
      req: DeleteTagForRecordsData;
      res: {
        /**
         * Report about removed records.
         */
        200: MetadataProcessingReport;
        /**
         * Operation not allowed. Only Editors can access it.
         */
        403: MetadataProcessingReport;
      };
    };
    put: {
      req: TagRecordsData;
      res: {
        /**
         * Report about updated records.
         */
        201: MetadataProcessingReport;
        /**
         * Operation not allowed. Only Editors can access it.
         */
        403: MetadataProcessingReport;
      };
    };
  };
  '/records/templates': {
    put: {
      req: AddTemplatesData;
      res: {
        /**
         * Return a report of what has been done.
         */
        201: SimpleMetadataProcessingReport;
        /**
         * Operation not allowed. Only Administrators can access it.
         */
        403: SimpleMetadataProcessingReport;
      };
    };
  };
  '/records/unpublish': {
    put: {
      req: UnpublishMultipleRecordsData;
      res: {
        /**
         * Report about updated privileges.
         */
        201: MetadataProcessingReport;
        /**
         * Operation not allowed. Only Editors can access it.
         */
        403: MetadataProcessingReport;
      };
    };
  };
  '/records/validate': {
    delete: {
      req: CleanValidationStatusData;
      res: {
        /**
         * Records validation status cleared.
         */
        201: SimpleMetadataProcessingReport;
        /**
         * Operation not allowed. Only Editors can access it.
         */
        403: SimpleMetadataProcessingReport;
      };
    };
    put: {
      req: ValidateRecordsData;
      res: {
        /**
         * Records validated.
         */
        201: SimpleMetadataProcessingReport;
        /**
         * Operation not allowed. Only Editors can access it.
         */
        403: SimpleMetadataProcessingReport;
      };
    };
  };
  '/records/validate/inspire': {
    put: {
      req: ValidateRecordsInspireData;
      res: {
        /**
         * Records validated.
         */
        201: string;
        /**
         * Operation not allowed. Only Editors can access it.
         */
        403: string;
      };
    };
  };
  '/records/versions': {
    put: {
      req: EnableVersionControlForRecordsData;
      res: {
        /**
         * OK
         */
        200: MetadataProcessingReport;
      };
    };
  };
  '/records/zip': {
    get: {
      req: ExportAsMefData;
      res: {
        /**
         * Return requested records as ZIP.
         */
        200: unknown;
        /**
         * Operation not allowed. User needs to be able to view the resource.
         */
        403: unknown;
      };
    };
  };
  '/records/{metadataUuid}': {
    delete: {
      req: DeleteRecordData;
      res: {
        /**
         * Record deleted.
         */
        204: void;
        /**
         * This template is referenced
         */
        401: unknown;
        /**
         * Operation not allowed. User needs to be able to edit the resource.
         */
        403: unknown;
      };
    };
    get: {
      req: GetRecordData;
      res: {
        /**
         * Return the record.
         */
        200: Blob | File;
        /**
         * Operation not allowed. User needs to be able to view the resource.
         */
        403: string;
        /**
         * Resource not found.
         */
        404: string;
      };
    };
  };
  '/records/{metadataUuid}/alert': {
    post: {
      req: SendEmailToContactData;
      res: {
        /**
         * Created
         */
        201: string;
      };
    };
  };
  '/records/{metadataUuid}/associated': {
    get: {
      req: GetAssociatedResourcesData;
      res: {
        /**
         * Return the associated resources.
         */
        200: {
          [key: string]: Array<AssociatedRecord>;
        };
        /**
         * Operation not allowed. User needs to be able to view the resource.
         */
        403: {
          [key: string]: Array<AssociatedRecord>;
        };
      };
    };
  };
  '/records/{metadataUuid}/attachments': {
    delete: {
      req: DelResourcesData;
      res: {
        /**
         * Attachment added.
         */
        204: void;
        /**
         * Operation not allowed. User needs to be able to edit the resource.
         */
        403: unknown;
      };
    };
    get: {
      req: GetAllResourcesData;
      res: {
        /**
         * Return the record attachments.
         */
        200: Array<MetadataResource>;
        /**
         * Operation not allowed. User needs to be able to view the resource.
         */
        403: Array<MetadataResource>;
      };
    };
    post: {
      req: PutResourceData;
      res: {
        /**
         * Attachment uploaded.
         */
        201: MetadataResource;
        /**
         * Operation not allowed. User needs to be able to edit the resource.
         */
        403: MetadataResource;
      };
    };
    put: {
      req: PutResourceFromUrlData;
      res: {
        /**
         * Attachment added.
         */
        201: MetadataResource;
        /**
         * Operation not allowed. User needs to be able to edit the resource.
         */
        403: MetadataResource;
      };
    };
  };
  '/records/{metadataUuid}/attachments/print-thumbnail': {
    put: {
      req: SaveThumbnailData;
      res: {
        /**
         * Thumbnail created.
         */
        201: MetadataResource;
        /**
         * Operation not allowed. User needs to be able to edit the resource.
         */
        403: MetadataResource;
      };
    };
  };
  '/records/{metadataUuid}/attachments/{resourceId}': {
    delete: {
      req: DelResourceData;
      res: {
        /**
         * Attachment visibility removed.
         */
        204: void;
        /**
         * Operation not allowed. User needs to be able to edit the resource.
         */
        403: unknown;
      };
    };
    get: {
      req: GetResourceData;
      res: {
        /**
         * Record attachment.
         */
        200: Blob | File;
        /**
         * Operation not allowed. User needs to be able to download the resource.
         */
        403: unknown;
      };
    };
    patch: {
      req: PatchResourceData;
      res: {
        /**
         * Attachment visibility updated.
         */
        201: MetadataResource;
        /**
         * Operation not allowed. User needs to be able to edit the resource.
         */
        403: MetadataResource;
      };
    };
  };
  '/records/{metadataUuid}/doi': {
    delete: {
      req: UnregisterDoiData;
      res: {
        /**
         * DOI unregistered.
         */
        204: string;
        /**
         * Operation not allowed. Only Administrators can access it.
         */
        403: string;
        /**
         * Metadata or DOI not found.
         */
        404: string;
        /**
         * Service unavailable.
         */
        500: string;
      };
    };
    put: {
      req: CreateDoiData;
      res: {
        /**
         * Check status of the report.
         */
        201: {
          [key: string]: string;
        };
        /**
         * Operation not allowed. User needs to be able to edit the resource.
         */
        403: {
          [key: string]: string;
        };
        /**
         * Metadata not found.
         */
        404: {
          [key: string]: string;
        };
        /**
         * Service unavailable.
         */
        500: {
          [key: string]: string;
        };
      };
    };
  };
  '/records/{metadataUuid}/doi/checkDoiUrl': {
    get: {
      req: CheckDoiUrlData;
      res: {
        /**
         * DOI URL created.
         */
        200: string;
        /**
         * Operation not allowed. User needs to be able to edit the resource.
         */
        403: string;
        /**
         * Metadata not found.
         */
        404: string;
        /**
         * Service unavailable.
         */
        500: string;
      };
    };
  };
  '/records/{metadataUuid}/doi/checkPreConditions': {
    get: {
      req: CheckDoiStatusData;
      res: {
        /**
         * Record can be proposed to DataCite.
         */
        200: {
          [key: string]: boolean;
        };
        /**
         * Record does not meet preconditions. Check error message.
         */
        400: {
          [key: string]: boolean;
        };
        /**
         * Operation not allowed. User needs to be able to edit the resource.
         */
        403: {
          [key: string]: boolean;
        };
        /**
         * Metadata not found.
         */
        404: {
          [key: string]: boolean;
        };
        /**
         * Service unavailable.
         */
        500: {
          [key: string]: boolean;
        };
      };
    };
  };
  '/records/{metadataUuid}/editor': {
    delete: {
      req: CancelEditsData;
      res: {
        /**
         * Editing session cancelled.
         */
        204: void;
        /**
         * Operation not allowed. User needs to be able to edit the resource.
         */
        403: unknown;
      };
    };
    get: {
      req: StartEditingData;
      res: {
        /**
         * The editor form.
         */
        200: unknown;
        /**
         * Operation not allowed. User needs to be able to edit the resource.
         */
        403: unknown;
      };
    };
    post: {
      req: SaveEditsData;
      res: {
        /**
         * The editor form.
         */
        200: unknown;
        /**
         * Operation not allowed. User needs to be able to edit the resource.
         */
        403: unknown;
      };
    };
  };
  '/records/{metadataUuid}/editor/attributes': {
    delete: {
      req: DeleteAttributeData;
      res: {
        /**
         * Attribute removed.
         */
        204: void;
        /**
         * Operation not allowed. User needs to be able to edit the resource.
         */
        403: unknown;
      };
    };
  };
  '/records/{metadataUuid}/editor/elements': {
    delete: {
      req: DeleteElementData;
      res: {
        /**
         * Element removed.
         */
        204: void;
        /**
         * Operation not allowed. User needs to be able to edit the resource.
         */
        403: unknown;
      };
    };
    put: {
      req: AddElementData;
      res: {
        /**
         * Element added.
         */
        200: unknown;
        /**
         * Operation not allowed. User needs to be able to edit the resource.
         */
        403: unknown;
      };
    };
  };
  '/records/{metadataUuid}/editor/elements/{direction}': {
    put: {
      req: ReorderElementData;
      res: {
        /**
         * Element reordered.
         */
        201: unknown;
        /**
         * Operation not allowed. User needs to be able to edit the resource.
         */
        403: unknown;
      };
    };
  };
  '/records/{metadataUuid}/extents.json': {
    get: {
      req: GetAllRecordExtentAsJsonData;
      res: {
        /**
         * OK
         */
        200: Array<ExtentDto>;
      };
    };
  };
  '/records/{metadataUuid}/extents.png': {
    get: {
      req: GetAllRecordExtentAsImageData;
      res: {
        /**
         * OK
         */
        200: Array<string>;
      };
    };
  };
  '/records/{metadataUuid}/extents/{geometryIndex}.png': {
    get: {
      req: GetOneRecordExtentAsImageData;
      res: {
        /**
         * OK
         */
        200: Array<string>;
      };
    };
  };
  '/records/{metadataUuid}/featureCatalog': {
    get: {
      req: GetFeatureCatalogData;
      res: {
        /**
         * Return the associated resources.
         */
        200: FeatureResponse;
        /**
         * Operation not allowed. User needs to be able to view the resource.
         */
        403: FeatureResponse;
      };
    };
  };
  '/records/{metadataUuid}/formatters/json': {
    get: {
      req: GetRecordAsJsonData;
      res: {
        /**
         * Return the record.
         */
        200: Blob | File;
        /**
         * Operation not allowed. User needs to be able to view the resource.
         */
        403: {
          [key: string]: unknown;
        };
      };
    };
  };
  '/records/{metadataUuid}/formatters/xml': {
    get: {
      req: GetRecordAsXmlData;
      res: {
        /**
         * Return the record.
         */
        200: Blob | File;
        /**
         * Operation not allowed. User needs to be able to view the resource.
         */
        403: {
          [key: string]: unknown;
        };
      };
    };
  };
  '/records/{metadataUuid}/formatters/zip': {
    get: {
      req: GetRecordAsZipData;
      res: {
        /**
         * Return the record.
         */
        200: unknown;
        /**
         * Operation not allowed. User needs to be able to view the resource.
         */
        403: unknown;
      };
    };
  };
  '/records/{metadataUuid}/formatters/{formatterId}': {
    get: {
      req: GetRecordFormattedByData;
      res: {
        /**
         * OK
         */
        200: unknown;
      };
    };
  };
  '/records/{metadataUuid}/group': {
    put: {
      req: SetRecordGroupData;
      res: {
        /**
         * Record group updated.
         */
        204: void;
        /**
         * Operation not allowed. User needs to be able to edit the resource.
         */
        403: unknown;
      };
    };
  };
  '/records/{metadataUuid}/ownership': {
    put: {
      req: SetRecordOwnershipData;
      res: {
        /**
         * Record group and owner updated
         */
        201: MetadataProcessingReport;
        /**
         * Operation not allowed. User needs to be able to edit the resource.
         */
        403: MetadataProcessingReport;
      };
    };
  };
  '/records/{metadataUuid}/permalink': {
    get: {
      req: GetRecordPermalinkData;
      res: {
        /**
         * Return the permalink URL.
         */
        200: string;
        /**
         * Operation not allowed. User needs to be able to view the resource.
         */
        403: string;
        /**
         * Resource not found.
         */
        404: string;
      };
    };
  };
  '/records/{metadataUuid}/popularity': {
    get: {
      req: GetRecordPopularityData;
      res: {
        /**
         * Popularity.
         */
        200: string;
        /**
         * Operation not allowed. User needs to be able to view the resource.
         */
        403: string;
        /**
         * Resource not found.
         */
        404: string;
      };
    };
    post: {
      req: IncreaseRecordPopularityData;
      res: {
        /**
         * Popularity updated.
         */
        201: string;
        /**
         * Operation not allowed. User needs to be able to view the resource.
         */
        403: string;
        /**
         * Resource not found.
         */
        404: string;
      };
    };
  };
  '/records/{metadataUuid}/processes': {
    get: {
      req: GetSuggestionsData;
      res: {
        /**
         * Record suggestions.
         */
        200: Array<SuggestionType>;
        /**
         * Operation not allowed. User needs to be able to edit the resource.
         */
        403: Array<SuggestionType>;
      };
    };
  };
  '/records/{metadataUuid}/processes/{process}': {
    get: {
      req: ProcessRecordPreviewData;
      res: {
        /**
         * A preview of the processed record.
         */
        200: unknown;
        /**
         * Operation not allowed. User needs to be able to edit the resource.
         */
        403: unknown;
      };
    };
    post: {
      req: ProcessRecordData;
      res: {
        /**
         * Record processed and saved.
         */
        200: string;
        /**
         * Operation not allowed. User needs to be able to edit the resource.
         */
        403: string;
      };
    };
  };
  '/records/{metadataUuid}/publish': {
    put: {
      req: PublishData;
      res: {
        /**
         * Settings updated.
         */
        204: void;
        /**
         * Operation not allowed. User needs to be able to edit the resource.
         */
        403: unknown;
      };
    };
  };
  '/records/{metadataUuid}/query': {
    get: {
      req: GetSavedQueriesData;
      res: {
        /**
         * Saved query available.
         */
        200: Array<SavedQuery>;
        /**
         * Operation not allowed. User needs to be able to view the resource.
         */
        403: Array<SavedQuery>;
      };
    };
  };
  '/records/{metadataUuid}/query/{savedQuery}': {
    post: {
      req: ApplyQueryData;
      res: {
        /**
         * List of matching elements. If element are nodes, then they are returned as string.
         */
        200: {
          [key: string]: string;
        };
        /**
         * Operation not allowed. User needs to be able to view the resource.
         */
        403: {
          [key: string]: string;
        };
      };
    };
  };
  '/records/{metadataUuid}/rate': {
    put: {
      req: RateRecordData;
      res: {
        /**
         * New rating value.
         */
        201: number;
        /**
         * Operation not allowed. User needs to be able to view the resource.
         */
        403: number;
      };
    };
  };
  '/records/{metadataUuid}/related': {
    get: {
      req: GetRelatedResourcesData;
      res: {
        /**
         * Return the associated resources.
         */
        200: RelatedResponse;
        /**
         * Operation not allowed. User needs to be able to view the resource.
         */
        403: RelatedResponse;
      };
    };
  };
  '/records/{metadataUuid}/sharing': {
    get: {
      req: GetRecordSharingSettingsData;
      res: {
        /**
         * The record sharing settings.
         */
        200: SharingResponse;
        /**
         * Operation not allowed. User needs to be able to view the resource.
         */
        403: SharingResponse;
      };
    };
    put: {
      req: ShareData;
      res: {
        /**
         * Settings updated.
         */
        204: void;
        /**
         * Operation not allowed. User needs to be able to edit the resource.
         */
        403: unknown;
      };
    };
  };
  '/records/{metadataUuid}/status': {
    delete: {
      req: DeleteAllRecordStatusData;
      res: {
        /**
         * Status removed.
         */
        204: void;
        /**
         * Operation not allowed. Only Administrators can access it.
         */
        403: unknown;
        /**
         * Status not found.
         */
        404: unknown;
      };
    };
    get: {
      req: GetRecordStatusHistoryData;
      res: {
        /**
         * OK
         */
        200: Array<MetadataStatusResponse>;
      };
    };
    put: {
      req: SetStatusData;
      res: {
        /**
         * Status updated.
         */
        201: {
          [key: string]: 'UPDATED' | 'UNCHANGED' | 'DELETED';
        };
        /**
         * Metadata workflow not enabled.
         */
        400: {
          [key: string]: 'UPDATED' | 'UNCHANGED' | 'DELETED';
        };
        /**
         * Operation not allowed. User needs to be able to edit the resource.
         */
        403: {
          [key: string]: 'UPDATED' | 'UNCHANGED' | 'DELETED';
        };
      };
    };
  };
  '/records/{metadataUuid}/status/workflow/last': {
    get: {
      req: GetStatusData;
      res: {
        /**
         * Record status.
         */
        200: MetadataWorkflowStatusResponse;
        /**
         * Operation not allowed. User needs to be able to edit the resource.
         */
        403: MetadataWorkflowStatusResponse;
      };
    };
  };
  '/records/{metadataUuid}/status/{statusId}.{userId}.{changeDate}': {
    delete: {
      req: DeleteRecordStatusData;
      res: {
        /**
         * Status removed.
         */
        204: void;
        /**
         * Operation not allowed. Only Administrators can access it.
         */
        403: unknown;
        /**
         * Status not found.
         */
        404: unknown;
      };
    };
  };
  '/records/{metadataUuid}/status/{statusId}.{userId}.{changeDate}/after': {
    get: {
      req: ShowStatusAfterData;
      res: {
        /**
         * Version of the record after changes.
         */
        200: string;
        /**
         * Operation not allowed. User needs to be able to edit the resource.
         */
        403: string;
      };
    };
  };
  '/records/{metadataUuid}/status/{statusId}.{userId}.{changeDate}/before': {
    get: {
      req: ShowStatusBeforeData;
      res: {
        /**
         * Previous version of the record.
         */
        200: string;
        /**
         * Operation not allowed. User needs to be able to edit the resource.
         */
        403: string;
      };
    };
  };
  '/records/{metadataUuid}/status/{statusId}.{userId}.{changeDate}/close': {
    put: {
      req: CloseTaskData;
      res: {
        /**
         * Task closed.
         */
        204: void;
        /**
         * Operation not allowed. User needs to be able to edit the resource.
         */
        403: unknown;
        /**
         * Status not found.
         */
        404: unknown;
      };
    };
  };
  '/records/{metadataUuid}/status/{statusId}.{userId}.{changeDate}/restore': {
    post: {
      req: RestoreAtStatusSaveData;
      res: {
        /**
         * Record restored.
         */
        200: unknown;
        /**
         * Operation not allowed. User needs to be able to edit the resource.
         */
        403: unknown;
      };
    };
  };
  '/records/{metadataUuid}/status/{type}': {
    get: {
      req: GetRecordStatusHistoryByTypeData;
      res: {
        /**
         * OK
         */
        200: Array<MetadataStatusResponse>;
      };
    };
  };
  '/records/{metadataUuid}/tags': {
    delete: {
      req: DeleteTagsData;
      res: {
        /**
         * Record tags removed.
         */
        204: void;
        /**
         * Operation not allowed. User needs to be able to edit the resource.
         */
        403: unknown;
      };
    };
    get: {
      req: GetRecordTagsData;
      res: {
        /**
         * Record tags.
         */
        200: Array<MetadataCategory>;
        /**
         * Operation not allowed. User needs to be able to view the resource.
         */
        403: Array<MetadataCategory>;
      };
    };
    put: {
      req: TagRecordData;
      res: {
        /**
         * Record tags added.
         */
        201: unknown;
        /**
         * Operation not allowed. User needs to be able to edit the resource.
         */
        403: unknown;
      };
    };
  };
  '/records/{metadataUuid}/unpublish': {
    put: {
      req: UnpublishData;
      res: {
        /**
         * Settings updated.
         */
        204: void;
        /**
         * Operation not allowed. User needs to be able to edit the resource.
         */
        403: unknown;
      };
    };
  };
  '/records/{metadataUuid}/userfeedback': {
    get: {
      req: GetUserCommentsOnArecordData;
      res: {
        /**
         * OK
         */
        200: Array<UserFeedbackDTO>;
      };
    };
  };
  '/records/{metadataUuid}/userfeedbackrating': {
    get: {
      req: GetMetadataRatingData;
      res: {
        /**
         * OK
         */
        200: RatingAverage;
      };
    };
  };
  '/records/{metadataUuid}/validate/inspire': {
    put: {
      req: ValidateRecordForInspireData;
      res: {
        /**
         * Check status of the report.
         */
        201: string;
        /**
         * Operation not allowed. User needs to be able to edit the resource.
         */
        403: string;
        /**
         * Metadata not found.
         */
        404: string;
        /**
         * Service unavailable.
         */
        500: string;
      };
    };
  };
  '/records/{metadataUuid}/validate/inspire/testsuites': {
    get: {
      req: GetTestSuitesData;
      res: {
        /**
         * List of testsuites available.
         */
        200: {
          [key: string]: Array<string>;
        };
        /**
         * Operation not allowed. User needs to be able to edit the resource.
         */
        403: {
          [key: string]: Array<string>;
        };
      };
    };
  };
  '/records/{metadataUuid}/validate/internal': {
    put: {
      req: ValidateRecordData;
      res: {
        /**
         * Validation report.
         */
        201: Reports;
        /**
         * Operation not allowed. User needs to be able to edit the resource.
         */
        403: Reports;
      };
    };
  };
  '/records/{metadataUuid}/versions': {
    put: {
      req: EnableVersionControlData;
      res: {
        /**
         * OK
         */
        200: string;
      };
    };
  };
  '/records/{testId}/validate/inspire': {
    get: {
      req: CheckValidationData;
      res: {
        /**
         * Report ready.
         */
        200: {
          [key: string]: string;
        };
        /**
         * Operation not allowed. User needs to be able to edit the resource.
         */
        403: {
          [key: string]: string;
        };
        /**
         * Report id not found.
         */
        404: {
          [key: string]: string;
        };
      };
    };
  };
  '/regions': {
    get: {
      req: GetRegionsData;
      res: {
        /**
         * List of regions.
         */
        200: ListRegionsResponse;
      };
    };
  };
  '/regions/geom.png': {
    get: {
      req: GetGeomAsImageData;
      res: {
        /**
         * OK
         */
        200: Array<string>;
      };
    };
  };
  '/regions/types': {
    get: {
      res: {
        /**
         * List of region types.
         */
        200: Array<Category>;
      };
    };
  };
  '/registries/actions/entries/collect': {
    get: {
      req: PreviewExtractedEntriesData;
      res: {
        /**
         * OK
         */
        200: {
          [key: string]: unknown;
        };
      };
    };
    put: {
      req: ExtractEntriesData;
      res: {
        /**
         * OK
         */
        200: {
          [key: string]: unknown;
        };
      };
    };
  };
  '/registries/actions/entries/import/spatial': {
    post: {
      req: ImportSpatialEntriesData;
      res: {
        /**
         * Directory entries imported.
         */
        201: SimpleMetadataProcessingReport;
        /**
         * Operation not allowed. Only Reviewvers can access it.
         */
        403: SimpleMetadataProcessingReport;
      };
    };
  };
  '/registries/actions/entries/synchronize': {
    get: {
      req: PreviewUpdatedRecordEntriesData;
      res: {
        /**
         * OK
         */
        200: {
          [key: string]: unknown;
        };
      };
    };
    put: {
      req: UpdateRecordEntriesData;
      res: {
        /**
         * Created
         */
        201: {
          [key: string]: unknown;
        };
      };
    };
  };
  '/registries/crs': {
    get: {
      req: SearchCrsData;
      res: {
        /**
         * List of CRS.
         */
        200: Array<Crs>;
      };
    };
  };
  '/registries/crs/types': {
    get: {
      res: {
        /**
         * List of CRS types.
         */
        200: Array<
          | 'CoordinateReferenceSystem'
          | 'VerticalCRS'
          | 'GeographicCRS'
          | 'ProjectedCRS'
        >;
      };
    };
  };
  '/registries/crs/{id}': {
    get: {
      req: GetCrsData;
      res: {
        /**
         * CRS details.
         */
        200: Crs;
        /**
         * CRS not found.
         */
        404: Crs;
      };
    };
  };
  '/registries/entries/{uuid}': {
    get: {
      req: GetEntryData;
      res: {
        /**
         * Directory entry.
         */
        200: unknown;
        /**
         * Operation not allowed. User needs to be able to view the resource.
         */
        403: unknown;
      };
    };
  };
  '/registries/vocabularies': {
    post: {
      req: UploadThesaurusData;
      res: {
        /**
         * Thesaurus uploaded in SKOS format.
         */
        201: string;
        /**
         * Operation not allowed. Only Reviewvers can access it.
         */
        403: string;
      };
    };
    put: {
      req: UploadThesaurusFromUrlData;
      res: {
        /**
         * Thesaurus uploaded in SKOS format.
         */
        201: string;
        /**
         * Operation not allowed. Only Reviewvers can access it.
         */
        403: string;
      };
    };
  };
  '/registries/vocabularies/import/csv': {
    post: {
      req: ImportCsvAsThesaurusData;
      res: {
        /**
         * Thesaurus converted and returned in response in SKOS format.
         */
        200: unknown;
        /**
         * Operation not allowed. Only Reviewvers can access it.
         */
        403: unknown;
      };
    };
  };
  '/registries/vocabularies/keyword': {
    get: {
      req: GetKeywordByIdData;
      res: {
        /**
         * XML snippet with requested keywords.
         */
        200: {
          [key: string]: unknown;
        };
      };
    };
    post: {
      req: GetKeywordByIdsData;
      res: {
        /**
         * XML snippet with requested keywords.
         */
        200: {
          [key: string]: unknown;
        };
      };
    };
  };
  '/registries/vocabularies/search': {
    get: {
      req: SearchKeywordsData;
      res: {
        /**
         * OK
         */
        200: {
          [key: string]: unknown;
        };
      };
    };
  };
  '/registries/vocabularies/{thesaurus}': {
    delete: {
      req: DeleteThesaurusData;
      res: {
        /**
         * Thesaurus deleted.
         */
        200: unknown;
        /**
         * Operation not allowed. Only UserAdmins can access it.
         */
        403: unknown;
        /**
         * Resource not found.
         */
        404: unknown;
      };
    };
    get: {
      req: GetThesaurusData;
      res: {
        /**
         * Thesaurus in SKOS format.
         */
        200: Blob | File;
        /**
         * Resource not found.
         */
        404: unknown;
      };
    };
    put: {
      req: UpdateThesaurusData;
      res: {
        /**
         * OK
         */
        200: unknown;
        /**
         * Operation not allowed. Only Administrators can access it.
         */
        403: unknown;
      };
    };
  };
  '/related': {
    get: {
      req: GetAssociatedResourcesForRecordsData;
      res: {
        /**
         * Return the associated resources.
         */
        200: {
          [key: string]: RelatedResponse;
        };
        /**
         * Operation not allowed. User needs to be able to view the resource.
         */
        403: {
          [key: string]: RelatedResponse;
        };
      };
    };
  };
  '/reports/datadownloads': {
    get: {
      req: GetReportDataDownloadsData;
      res: {
        /**
         * List of metadata file downloads.
         */
        200: unknown;
      };
    };
  };
  '/reports/datauploads': {
    get: {
      req: GetReportDataUploadsData;
      res: {
        /**
         * OK
         */
        200: unknown;
      };
    };
  };
  '/reports/metadatainternal': {
    get: {
      req: GetReportInternalMetadataData;
      res: {
        /**
         * Metadata not published during a period.
         */
        200: unknown;
      };
    };
  };
  '/reports/metadataupdated': {
    get: {
      req: GetReportUpdatedMetadataData;
      res: {
        /**
         * Updated metadata during a period.
         */
        200: unknown;
      };
    };
  };
  '/reports/users': {
    get: {
      req: GetActiveUsersData;
      res: {
        /**
         * List of users "active" during a time period.
         */
        200: unknown;
      };
    };
  };
  '/robots.txt': {
    get: {
      res: {
        /**
         * robots.txt file for SEO.
         */
        200: unknown;
      };
    };
  };
  '/search/records/_msearch': {
    post: {
      req: MsearchData;
      res: {
        /**
         * Search results.
         */
        200: string;
      };
    };
  };
  '/search/records/_search': {
    post: {
      req: SearchData;
      res: {
        /**
         * Search results.
         */
        200: string;
      };
    };
  };
  '/selections': {
    get: {
      res: {
        /**
         * OK
         */
        200: {
          [key: string]: number;
        };
      };
    };
  };
  '/selections/{bucket}': {
    delete: {
      req: ClearData;
      res: {
        /**
         * OK
         */
        200: number;
      };
    };
    get: {
      req: GetData;
      res: {
        /**
         * OK
         */
        200: Array<string>;
      };
    };
    put: {
      req: AddData;
      res: {
        /**
         * OK
         */
        200: number;
      };
    };
  };
  '/site': {
    get: {
      res: {
        /**
         * Site description.
         */
        200: SettingsListResponse;
      };
    };
  };
  '/site/index': {
    put: {
      req: IndexSiteData;
      res: {
        /**
         * OK
         */
        200: string;
      };
    };
  };
  '/site/index/commit': {
    get: {
      res: {
        /**
         * OK
         */
        200: unknown;
      };
    };
    put: {
      res: {
        /**
         * Changes committed.
         */
        201: unknown;
      };
    };
  };
  '/site/index/status': {
    get: {
      res: {
        /**
         * OK
         */
        200: Status;
      };
    };
  };
  '/site/index/synchronized': {
    get: {
      res: {
        /**
         * OK
         */
        200: {
          [key: string]: {
            [key: string]: unknown;
          };
        };
      };
    };
  };
  '/site/indexing': {
    get: {
      res: {
        /**
         * OK
         */
        200: boolean;
      };
    };
  };
  '/site/info': {
    get: {
      res: {
        /**
         * Site information.
         */
        200: SiteInformation;
      };
    };
  };
  '/site/info/build': {
    get: {
      res: {
        /**
         * Build info.
         */
        200: SystemInfo;
      };
    };
  };
  '/site/info/isCasEnabled': {
    get: {
      res: {
        /**
         * OK
         */
        200: boolean;
      };
    };
  };
  '/site/info/notificationLevels': {
    get: {
      res: {
        /**
         * List of notification levels.
         */
        200: Array<
          | 'statusUserOwner'
          | 'catalogueAdministrator'
          | 'catalogueProfileAdministrator'
          | 'catalogueProfileUserAdmin'
          | 'catalogueProfileReviewer'
          | 'catalogueProfileEditor'
          | 'catalogueProfileRegisteredUser'
          | 'catalogueProfileGuest'
          | 'recordProfileReviewer'
          | 'recordUserAuthor'
          | 'recordGroupEmail'
        >;
      };
    };
  };
  '/site/info/proxy': {
    get: {
      res: {
        /**
         * Proxy configuration.
         */
        200: ProxyConfiguration;
      };
    };
  };
  '/site/info/readonly': {
    get: {
      res: {
        /**
         * OK
         */
        200: boolean;
      };
    };
  };
  '/site/info/staging/{profile}': {
    put: {
      req: UpdateStagingProfileData;
      res: {
        /**
         * Staging profile saved.
         */
        204: void;
        /**
         * Operation not allowed. Only Administrators can access it.
         */
        403: unknown;
      };
    };
  };
  '/site/info/transforms': {
    get: {
      res: {
        /**
         * XSLT available.
         */
        200: Array<string>;
      };
    };
  };
  '/site/logging': {
    get: {
      res: {
        /**
         * OK
         */
        200: Array<LogFileResponse>;
      };
    };
  };
  '/site/logging/activity': {
    get: {
      req: GetLastActivityData;
      res: {
        /**
         * OK
         */
        200: string;
      };
    };
  };
  '/site/logging/activity/zip': {
    get: {
      res: {
        /**
         * OK
         */
        200: unknown;
      };
    };
  };
  '/site/logo': {
    put: {
      req: SetLogoData;
      res: {
        /**
         * Logo set.
         */
        204: void;
        /**
         * Operation not allowed. Only UserAdmins can access it.
         */
        403: unknown;
      };
    };
  };
  '/site/settings': {
    get: {
      req: GetSettingsSetData;
      res: {
        /**
         * Settings.
         */
        200: SettingsListResponse;
      };
    };
    post: {
      req: SaveSettingsData;
      res: {
        /**
         * Settings saved.
         */
        204: void;
        /**
         * Operation not allowed. Only Administrators can access it.
         */
        403: unknown;
      };
    };
  };
  '/site/settings/details': {
    get: {
      req: GetSettingsDetailsData;
      res: {
        /**
         * Settings with details.
         */
        200: Array<Setting>;
      };
    };
  };
  '/sitemap': {
    get: {
      req: GetSitemapData;
      res: {
        /**
         * Site map.
         */
        200: unknown;
      };
    };
  };
  '/sources': {
    get: {
      req: GetSourcesData;
      res: {
        /**
         * List of source catalogues.
         */
        200: Array<Source>;
      };
    };
    put: {
      req: AddSourceData;
      res: {
        /**
         * Source created.
         */
        201: string;
        /**
         * Operation not allowed. Only Administrators can access it.
         */
        403: string;
      };
    };
  };
  '/sources/{sourceIdentifier}': {
    delete: {
      req: DeleteSourceData;
      res: {
        /**
         * Source deleted.
         */
        204: string;
        /**
         * Operation not allowed. Only Administrators can access it.
         */
        403: string;
      };
    };
    put: {
      req: UpdateSourceData;
      res: {
        /**
         * Source updated.
         */
        204: string;
        /**
         * Operation not allowed. Only UserAdmins can access it.
         */
        403: string;
        /**
         * Source not found.
         */
        404: string;
      };
    };
  };
  '/sources/{type}': {
    get: {
      req: GetSourcesByTypeData;
      res: {
        /**
         * OK
         */
        200: Array<Source>;
      };
    };
  };
  '/standards': {
    get: {
      res: {
        /**
         * List of standards.
         */
        200: unknown;
      };
    };
  };
  '/standards/batchconfiguration': {
    get: {
      req: GetConfigurationsData;
      res: {
        /**
         * Batch editor configuration.
         */
        200: {
          [key: string]: BatchEditing;
        };
      };
    };
  };
  '/standards/reload': {
    get: {
      res: {
        /**
         * Standards reloaded.
         */
        200: unknown;
      };
    };
  };
  '/standards/{schema}/batchconfiguration': {
    get: {
      req: GetConfigurationData;
      res: {
        /**
         * OK
         */
        200: {
          [key: string]: BatchEditing;
        };
      };
    };
  };
  '/standards/{schema}/codelists': {
    get: {
      req: GetCodelistsTranslationsData;
      res: {
        /**
         * OK
         */
        200: {
          [key: string]: string;
        };
      };
    };
  };
  '/standards/{schema}/codelists/{codelist}': {
    get: {
      req: GetSchemaTranslationsData;
      res: {
        /**
         * OK
         */
        200: {
          [key: string]: string;
        };
      };
    };
  };
  '/standards/{schema}/codelists/{codelist}/details': {
    get: {
      req: GetSchemaCodelistsWithDetailsData;
      res: {
        /**
         * OK
         */
        200: Codelist;
      };
    };
  };
  '/standards/{schema}/descriptors/{element}/details': {
    get: {
      req: GetElementDetailsData;
      res: {
        /**
         * OK
         */
        200: Element;
      };
    };
  };
  '/standards/{schema}/editor/associatedpanel/config/{name}.json': {
    get: {
      req: GetEditorAssociatedPanelConfigurationData;
      res: {
        /**
         * OK
         */
        200: string;
      };
    };
  };
  '/status': {
    delete: {
      res: {
        /**
         * Status removed.
         */
        204: void;
        /**
         * Operation not allowed. Only Administrators can access it.
         */
        403: unknown;
      };
    };
    get: {
      res: {
        /**
         * OK
         */
        200: Array<StatusValue>;
      };
    };
  };
  '/status/{type}': {
    get: {
      req: GetStatusByTypeData;
      res: {
        /**
         * OK
         */
        200: Array<StatusValue>;
      };
    };
  };
  '/tags': {
    get: {
      res: {
        /**
         * List of tags.
         */
        200: Array<MetadataCategory>;
      };
    };
    put: {
      req: PutTagData;
      res: {
        /**
         * Tag created. Return the new tag identifier.
         */
        201: number;
        /**
         * Operation not allowed. Only UserAdmins can access it.
         */
        403: number;
      };
    };
  };
  '/tags/{tagIdentifier}': {
    delete: {
      req: DeleteTagData;
      res: {
        /**
         * Tag removed.
         */
        204: string;
        /**
         * Operation not allowed. Only UserAdmins can access it.
         */
        403: string;
      };
    };
    get: {
      req: GetTagData;
      res: {
        /**
         * Tag details.
         */
        200: MetadataCategory;
      };
    };
    put: {
      req: UpdateTagData;
      res: {
        /**
         * Tag updated.
         */
        204: string;
        /**
         * Operation not allowed. Only UserAdmins can access it.
         */
        403: string;
      };
    };
  };
  '/tools/mail/test': {
    get: {
      res: {
        /**
         * Created
         */
        201: string;
      };
    };
  };
  '/tools/migration/steps/{stepName}': {
    put: {
      req: CallStepData;
      res: {
        /**
         * Created
         */
        201: string;
      };
    };
  };
  '/tools/ogc/filter': {
    post: {
      req: BuildFilterData;
      res: {
        /**
         * Created
         */
        201: string;
      };
    };
  };
  '/tools/ogc/sld': {
    delete: {
      res: {
        /**
         * OK
         */
        200: unknown;
      };
    };
    get: {
      res: {
        /**
         * OK
         */
        200: Array<string>;
      };
    };
    post: {
      req: BuildSldData;
      res: {
        /**
         * Created
         */
        201: string;
      };
    };
  };
  '/tools/ogc/sld/{id}.{extension}': {
    get: {
      req: DownloadSldData;
      res: {
        /**
         * OK
         */
        200: unknown;
      };
    };
  };
  '/translationproviders': {
    get: {
      res: {
        /**
         * List of translation provider names.
         */
        200: Array<string>;
      };
    };
  };
  '/ui': {
    get: {
      res: {
        /**
         * List of configuration.
         */
        200: Array<UiSetting>;
      };
    };
    put: {
      req: PutUiConfigurationData;
      res: {
        /**
         * UI configuration created. Return the new UI configuration identifier.
         */
        201: string;
        /**
         * Operation not allowed. Only UserAdmins can access it.
         */
        403: string;
      };
    };
  };
  '/ui/{uiIdentifier}': {
    delete: {
      req: DeleteUiConfigurationData;
      res: {
        /**
         * UI Configuration removed.
         */
        204: string;
        /**
         * Operation not allowed. Only UserAdmins can access it.
         */
        403: string;
        /**
         * UI Configuration not found.
         */
        404: string;
      };
    };
    get: {
      req: GetUiConfigurationData;
      res: {
        /**
         * UI configuration.
         */
        200: UiSetting;
      };
    };
    put: {
      req: UpdateUiConfigurationData;
      res: {
        /**
         * UI configuration updated.
         */
        204: string;
        /**
         * Operation not allowed. Only UserAdmins can access it.
         */
        403: string;
      };
    };
  };
  '/user/actions/forgot-password': {
    put: {
      req: SendPasswordByEmailData;
      res: {
        /**
         * Created
         */
        201: string;
      };
    };
  };
  '/user/actions/register': {
    put: {
      req: RegisterUserData;
      res: {
        /**
         * Created
         */
        201: string;
      };
    };
  };
  '/user/{username}': {
    patch: {
      req: UpdatePasswordData;
      res: {
        /**
         * Created
         */
        201: string;
      };
    };
  };
  '/userfeedback': {
    get: {
      req: GetUserCommentsData;
      res: {
        /**
         * OK
         */
        200: Array<UserFeedbackDTO>;
      };
    };
    post: {
      req: NewUserFeedbackData;
      res: {
        /**
         * Created
         */
        201: string;
      };
    };
  };
  '/userfeedback/ratingcriteria': {
    get: {
      res: {
        /**
         * OK
         */
        200: Array<RatingCriteria>;
      };
    };
  };
  '/userfeedback/{uuid}': {
    delete: {
      req: DeleteUserFeedbackData;
      res: {
        /**
         * User feedback removed.
         */
        204: string;
        /**
         * Operation not allowed. Only Reviewvers can access it.
         */
        403: string;
      };
    };
    get: {
      req: GetUserCommentData;
      res: {
        /**
         * OK
         */
        200: UserFeedbackDTO;
      };
    };
  };
  '/userfeedback/{uuid}/publish': {
    get: {
      req: PublishFeedbackData;
      res: {
        /**
         * User feedback published.
         */
        204: string;
        /**
         * Operation not allowed. Only Reviewvers can access it.
         */
        403: string;
        /**
         * Resource not found.
         */
        404: string;
      };
    };
  };
  '/users': {
    get: {
      res: {
        /**
         * OK
         */
        200: Array<User>;
      };
    };
    put: {
      req: CreateUserData;
      res: {
        /**
         * OK
         */
        200: string;
      };
    };
  };
  '/users/groups': {
    get: {
      res: {
        /**
         * OK
         */
        200: Array<UserGroupsResponse>;
      };
    };
  };
  '/users/owners': {
    get: {
      res: {
        /**
         * OK
         */
        200: Array<OwnerResponse>;
      };
    };
    put: {
      req: SaveOwnersData;
      res: {
        /**
         * OK
         */
        200: string;
      };
    };
  };
  '/users/properties/{property}': {
    get: {
      req: CheckUserPropertyExistData;
      res: {
        /**
         * Property does not exist.
         */
        200:
          | 'CONTINUE'
          | 'SWITCHING_PROTOCOLS'
          | 'PROCESSING'
          | 'CHECKPOINT'
          | 'OK'
          | 'CREATED'
          | 'ACCEPTED'
          | 'NON_AUTHORITATIVE_INFORMATION'
          | 'NO_CONTENT'
          | 'RESET_CONTENT'
          | 'PARTIAL_CONTENT'
          | 'MULTI_STATUS'
          | 'ALREADY_REPORTED'
          | 'IM_USED'
          | 'MULTIPLE_CHOICES'
          | 'MOVED_PERMANENTLY'
          | 'FOUND'
          | 'MOVED_TEMPORARILY'
          | 'SEE_OTHER'
          | 'NOT_MODIFIED'
          | 'USE_PROXY'
          | 'TEMPORARY_REDIRECT'
          | 'PERMANENT_REDIRECT'
          | 'BAD_REQUEST'
          | 'UNAUTHORIZED'
          | 'PAYMENT_REQUIRED'
          | 'FORBIDDEN'
          | 'NOT_FOUND'
          | 'METHOD_NOT_ALLOWED'
          | 'NOT_ACCEPTABLE'
          | 'PROXY_AUTHENTICATION_REQUIRED'
          | 'REQUEST_TIMEOUT'
          | 'CONFLICT'
          | 'GONE'
          | 'LENGTH_REQUIRED'
          | 'PRECONDITION_FAILED'
          | 'PAYLOAD_TOO_LARGE'
          | 'REQUEST_ENTITY_TOO_LARGE'
          | 'URI_TOO_LONG'
          | 'REQUEST_URI_TOO_LONG'
          | 'UNSUPPORTED_MEDIA_TYPE'
          | 'REQUESTED_RANGE_NOT_SATISFIABLE'
          | 'EXPECTATION_FAILED'
          | 'I_AM_A_TEAPOT'
          | 'INSUFFICIENT_SPACE_ON_RESOURCE'
          | 'METHOD_FAILURE'
          | 'DESTINATION_LOCKED'
          | 'UNPROCESSABLE_ENTITY'
          | 'LOCKED'
          | 'FAILED_DEPENDENCY'
          | 'TOO_EARLY'
          | 'UPGRADE_REQUIRED'
          | 'PRECONDITION_REQUIRED'
          | 'TOO_MANY_REQUESTS'
          | 'REQUEST_HEADER_FIELDS_TOO_LARGE'
          | 'UNAVAILABLE_FOR_LEGAL_REASONS'
          | 'INTERNAL_SERVER_ERROR'
          | 'NOT_IMPLEMENTED'
          | 'BAD_GATEWAY'
          | 'SERVICE_UNAVAILABLE'
          | 'GATEWAY_TIMEOUT'
          | 'HTTP_VERSION_NOT_SUPPORTED'
          | 'VARIANT_ALSO_NEGOTIATES'
          | 'INSUFFICIENT_STORAGE'
          | 'LOOP_DETECTED'
          | 'BANDWIDTH_LIMIT_EXCEEDED'
          | 'NOT_EXTENDED'
          | 'NETWORK_AUTHENTICATION_REQUIRED';
        /**
         * Operation not allowed. Only UserAdmins can access it.
         */
        403:
          | 'CONTINUE'
          | 'SWITCHING_PROTOCOLS'
          | 'PROCESSING'
          | 'CHECKPOINT'
          | 'OK'
          | 'CREATED'
          | 'ACCEPTED'
          | 'NON_AUTHORITATIVE_INFORMATION'
          | 'NO_CONTENT'
          | 'RESET_CONTENT'
          | 'PARTIAL_CONTENT'
          | 'MULTI_STATUS'
          | 'ALREADY_REPORTED'
          | 'IM_USED'
          | 'MULTIPLE_CHOICES'
          | 'MOVED_PERMANENTLY'
          | 'FOUND'
          | 'MOVED_TEMPORARILY'
          | 'SEE_OTHER'
          | 'NOT_MODIFIED'
          | 'USE_PROXY'
          | 'TEMPORARY_REDIRECT'
          | 'PERMANENT_REDIRECT'
          | 'BAD_REQUEST'
          | 'UNAUTHORIZED'
          | 'PAYMENT_REQUIRED'
          | 'FORBIDDEN'
          | 'NOT_FOUND'
          | 'METHOD_NOT_ALLOWED'
          | 'NOT_ACCEPTABLE'
          | 'PROXY_AUTHENTICATION_REQUIRED'
          | 'REQUEST_TIMEOUT'
          | 'CONFLICT'
          | 'GONE'
          | 'LENGTH_REQUIRED'
          | 'PRECONDITION_FAILED'
          | 'PAYLOAD_TOO_LARGE'
          | 'REQUEST_ENTITY_TOO_LARGE'
          | 'URI_TOO_LONG'
          | 'REQUEST_URI_TOO_LONG'
          | 'UNSUPPORTED_MEDIA_TYPE'
          | 'REQUESTED_RANGE_NOT_SATISFIABLE'
          | 'EXPECTATION_FAILED'
          | 'I_AM_A_TEAPOT'
          | 'INSUFFICIENT_SPACE_ON_RESOURCE'
          | 'METHOD_FAILURE'
          | 'DESTINATION_LOCKED'
          | 'UNPROCESSABLE_ENTITY'
          | 'LOCKED'
          | 'FAILED_DEPENDENCY'
          | 'TOO_EARLY'
          | 'UPGRADE_REQUIRED'
          | 'PRECONDITION_REQUIRED'
          | 'TOO_MANY_REQUESTS'
          | 'REQUEST_HEADER_FIELDS_TOO_LARGE'
          | 'UNAVAILABLE_FOR_LEGAL_REASONS'
          | 'INTERNAL_SERVER_ERROR'
          | 'NOT_IMPLEMENTED'
          | 'BAD_GATEWAY'
          | 'SERVICE_UNAVAILABLE'
          | 'GATEWAY_TIMEOUT'
          | 'HTTP_VERSION_NOT_SUPPORTED'
          | 'VARIANT_ALSO_NEGOTIATES'
          | 'INSUFFICIENT_STORAGE'
          | 'LOOP_DETECTED'
          | 'BANDWIDTH_LIMIT_EXCEEDED'
          | 'NOT_EXTENDED'
          | 'NETWORK_AUTHENTICATION_REQUIRED';
        /**
         * A property with that value already exist.
         */
        404:
          | 'CONTINUE'
          | 'SWITCHING_PROTOCOLS'
          | 'PROCESSING'
          | 'CHECKPOINT'
          | 'OK'
          | 'CREATED'
          | 'ACCEPTED'
          | 'NON_AUTHORITATIVE_INFORMATION'
          | 'NO_CONTENT'
          | 'RESET_CONTENT'
          | 'PARTIAL_CONTENT'
          | 'MULTI_STATUS'
          | 'ALREADY_REPORTED'
          | 'IM_USED'
          | 'MULTIPLE_CHOICES'
          | 'MOVED_PERMANENTLY'
          | 'FOUND'
          | 'MOVED_TEMPORARILY'
          | 'SEE_OTHER'
          | 'NOT_MODIFIED'
          | 'USE_PROXY'
          | 'TEMPORARY_REDIRECT'
          | 'PERMANENT_REDIRECT'
          | 'BAD_REQUEST'
          | 'UNAUTHORIZED'
          | 'PAYMENT_REQUIRED'
          | 'FORBIDDEN'
          | 'NOT_FOUND'
          | 'METHOD_NOT_ALLOWED'
          | 'NOT_ACCEPTABLE'
          | 'PROXY_AUTHENTICATION_REQUIRED'
          | 'REQUEST_TIMEOUT'
          | 'CONFLICT'
          | 'GONE'
          | 'LENGTH_REQUIRED'
          | 'PRECONDITION_FAILED'
          | 'PAYLOAD_TOO_LARGE'
          | 'REQUEST_ENTITY_TOO_LARGE'
          | 'URI_TOO_LONG'
          | 'REQUEST_URI_TOO_LONG'
          | 'UNSUPPORTED_MEDIA_TYPE'
          | 'REQUESTED_RANGE_NOT_SATISFIABLE'
          | 'EXPECTATION_FAILED'
          | 'I_AM_A_TEAPOT'
          | 'INSUFFICIENT_SPACE_ON_RESOURCE'
          | 'METHOD_FAILURE'
          | 'DESTINATION_LOCKED'
          | 'UNPROCESSABLE_ENTITY'
          | 'LOCKED'
          | 'FAILED_DEPENDENCY'
          | 'TOO_EARLY'
          | 'UPGRADE_REQUIRED'
          | 'PRECONDITION_REQUIRED'
          | 'TOO_MANY_REQUESTS'
          | 'REQUEST_HEADER_FIELDS_TOO_LARGE'
          | 'UNAVAILABLE_FOR_LEGAL_REASONS'
          | 'INTERNAL_SERVER_ERROR'
          | 'NOT_IMPLEMENTED'
          | 'BAD_GATEWAY'
          | 'SERVICE_UNAVAILABLE'
          | 'GATEWAY_TIMEOUT'
          | 'HTTP_VERSION_NOT_SUPPORTED'
          | 'VARIANT_ALSO_NEGOTIATES'
          | 'INSUFFICIENT_STORAGE'
          | 'LOOP_DETECTED'
          | 'BANDWIDTH_LIMIT_EXCEEDED'
          | 'NOT_EXTENDED'
          | 'NETWORK_AUTHENTICATION_REQUIRED';
      };
    };
  };
  '/users/{userIdentifier}': {
    delete: {
      req: DeleteUserData;
      res: {
        /**
         * OK
         */
        200: string;
      };
    };
    get: {
      req: GetUserData;
      res: {
        /**
         * OK
         */
        200: User;
      };
    };
    put: {
      req: UpdateUserData;
      res: {
        /**
         * OK
         */
        200: string;
      };
    };
  };
  '/users/{userIdentifier}.png': {
    get: {
      req: GetUserIdenticonData;
      res: {
        /**
         * OK
         */
        200: unknown;
      };
    };
  };
  '/users/{userIdentifier}/actions/forget-password': {
    post: {
      req: ResetUserPasswordData;
      res: {
        /**
         * OK
         */
        200: string;
      };
    };
  };
  '/users/{userIdentifier}/groups': {
    get: {
      req: RetrieveUserGroupsData;
      res: {
        /**
         * OK
         */
        200: Array<UserGroup>;
      };
    };
  };
  '/usersearches': {
    get: {
      res: {
        /**
         * OK
         */
        200: Array<UserSearchDto>;
      };
    };
    put: {
      req: CreateUserCustomSearchData;
      res: {
        /**
         * User search created.
         */
        201: number;
      };
    };
  };
  '/usersearches/all': {
    get: {
      req: GetAllUserCustomSearchesData;
      res: {
        /**
         * OK
         */
        200: Array<UserSearchDto>;
      };
    };
  };
  '/usersearches/allpaginated': {
    get: {
      req: GetAllUserCustomSearchesPageData;
      res: {
        /**
         * OK
         */
        200: PaginatedUserSearchResponse;
      };
    };
  };
  '/usersearches/featured': {
    get: {
      req: GetFeaturedUserCustomSearchesData;
      res: {
        /**
         * OK
         */
        200: Array<UserSearchDto>;
      };
    };
  };
  '/usersearches/{searchIdentifier}': {
    delete: {
      req: DeleteUserCustomSerachData;
      res: {
        /**
         * OK
         */
        200: string;
      };
    };
    get: {
      req: GetUserCustomSearchData;
      res: {
        /**
         * OK
         */
        200: UserSearchDto;
      };
    };
    put: {
      req: UpdateCustomUserSearchData;
      res: {
        /**
         * User search  updated.
         */
        204: void;
        /**
         * Resource not found.
         */
        404: unknown;
      };
    };
  };
  '/userselections': {
    get: {
      res: {
        /**
         * OK
         */
        200: Array<Selection>;
      };
    };
    put: {
      req: CreatePersistentSelectionTypeData;
      res: {
        /**
         * Selection created.
         */
        201: string;
        /**
         * A selection with that id or name already exist.
         */
        400: string;
        /**
         * Operation not allowed. Only UserAdmins can access it.
         */
        403: string;
      };
    };
  };
  '/userselections/{selectionIdentifier}': {
    delete: {
      req: DeleteUserSelectionData;
      res: {
        /**
         * Selection removed.
         */
        204: string;
        /**
         * Operation not allowed. Only UserAdmins can access it.
         */
        403: string;
        /**
         * Selection not found.
         */
        404: string;
      };
    };
    put: {
      req: UpdateUserSelectionData;
      res: {
        /**
         * Selection updated.
         */
        204: string;
        /**
         * Operation not allowed. Only UserAdmins can access it.
         */
        403: string;
        /**
         * Selection not found.
         */
        404: string;
      };
    };
  };
  '/userselections/{selectionIdentifier}/{userIdentifier}': {
    delete: {
      req: DeleteFromUserSelectionData;
      res: {
        /**
         * Items removed from a set.
         */
        204: string;
        /**
         * Operation not allowed. Only UserAdmins can access it.
         */
        403: string;
        /**
         * Selection or user not found.
         */
        404: string;
      };
    };
    get: {
      req: GetSelectionRecordsData;
      res: {
        /**
         * OK
         */
        200: Array<string>;
      };
    };
    put: {
      req: AddToUserSelectionData;
      res: {
        /**
         * Records added to selection set.
         */
        201: string;
        /**
         * Operation not allowed. Only UserAdmins can access it.
         */
        403: string;
        /**
         * Selection or user or at least one UUID not found.
         */
        404: string;
      };
    };
  };
};
