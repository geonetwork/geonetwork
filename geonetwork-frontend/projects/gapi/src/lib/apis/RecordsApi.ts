/* tslint:disable */
/* eslint-disable */
/**
 * GeoNetwork 4.4.7 OpenAPI Documentation
 * This is the description of the GeoNetwork OpenAPI. Use this API to manage your catalog.
 *
 * The version of the OpenAPI document: 4.4.7
 * Contact: geonetwork-users@lists.sourceforge.net
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as runtime from '../runtime';
import type {
  AssociatedRecord,
  BatchEditParameter,
  Direction,
  DuplicatedValueDto,
  ExtentDto,
  FeatureResponse,
  IProcessingReport,
  IndexResponse,
  MetadataBatchApproveParameter,
  MetadataBatchSubmitParameter,
  MetadataCategory,
  MetadataProcessingReport,
  MetadataResource,
  MetadataStatusParameter,
  MetadataStatusResponse,
  MetadataWorkflowStatusResponse,
  PublicationOption,
  RelatedItemType,
  RelatedResponse,
  Reports,
  SavedQuery,
  SharingParameter,
  SharingResponse,
  SimpleMetadataProcessingReport,
  SuggestionType,
} from '../models/index';
import {
  AssociatedRecordFromJSON,
  AssociatedRecordToJSON,
  BatchEditParameterFromJSON,
  BatchEditParameterToJSON,
  DirectionFromJSON,
  DirectionToJSON,
  DuplicatedValueDtoFromJSON,
  DuplicatedValueDtoToJSON,
  ExtentDtoFromJSON,
  ExtentDtoToJSON,
  FeatureResponseFromJSON,
  FeatureResponseToJSON,
  IProcessingReportFromJSON,
  IProcessingReportToJSON,
  IndexResponseFromJSON,
  IndexResponseToJSON,
  MetadataBatchApproveParameterFromJSON,
  MetadataBatchApproveParameterToJSON,
  MetadataBatchSubmitParameterFromJSON,
  MetadataBatchSubmitParameterToJSON,
  MetadataCategoryFromJSON,
  MetadataCategoryToJSON,
  MetadataProcessingReportFromJSON,
  MetadataProcessingReportToJSON,
  MetadataResourceFromJSON,
  MetadataResourceToJSON,
  MetadataStatusParameterFromJSON,
  MetadataStatusParameterToJSON,
  MetadataStatusResponseFromJSON,
  MetadataStatusResponseToJSON,
  MetadataWorkflowStatusResponseFromJSON,
  MetadataWorkflowStatusResponseToJSON,
  PublicationOptionFromJSON,
  PublicationOptionToJSON,
  RelatedItemTypeFromJSON,
  RelatedItemTypeToJSON,
  RelatedResponseFromJSON,
  RelatedResponseToJSON,
  ReportsFromJSON,
  ReportsToJSON,
  SavedQueryFromJSON,
  SavedQueryToJSON,
  SharingParameterFromJSON,
  SharingParameterToJSON,
  SharingResponseFromJSON,
  SharingResponseToJSON,
  SimpleMetadataProcessingReportFromJSON,
  SimpleMetadataProcessingReportToJSON,
  SuggestionTypeFromJSON,
  SuggestionTypeToJSON,
} from '../models/index';

export interface AddElementRequest {
  metadataUuid: string;
  ref: string;
  name: string;
  child?: string;
  displayAttributes?: boolean;
}

export interface AddSamplesRequest {
  schema: Array<string>;
}

export interface AddTemplatesRequest {
  schema: Array<string>;
}

export interface ApplyQueryRequest {
  metadataUuid: string;
  savedQuery: string;
  requestBody?: { [key: string]: string };
}

export interface ApproveRequest {
  metadataBatchApproveParameter: MetadataBatchApproveParameter;
}

export interface BatchEditRequest {
  batchEditParameter: Array<BatchEditParameter>;
  uuids?: Array<string>;
  bucket?: string;
  updateDateStamp?: boolean;
}

export interface CancelEditsRequest {
  metadataUuid: string;
}

export interface CheckDoiStatusRequest {
  metadataUuid: string;
  doiServerId: number;
}

export interface CheckDoiUrlRequest {
  metadataUuid: string;
  doiServerId: number;
}

export interface CheckDuplicatedFieldValueRequest {
  metadataUuid: string;
  duplicatedValueDto: DuplicatedValueDto;
}

export interface CheckValidationRequest {
  testId: string;
}

export interface CleanValidationStatusRequest {
  uuids?: Array<string>;
  bucket?: string;
}

export interface CloseTaskRequest {
  metadataUuid: string;
  statusId: number;
  userId: number;
  changeDate: string;
  closeDate: string;
}

export interface CreateRequest {
  sourceUuid: string;
  group: string;
  metadataType?: CreateMetadataTypeEnum;
  targetUuid?: string;
  allowEditGroupMembers?: boolean;
  category?: Array<string>;
  hasCategoryOfSource?: boolean;
  isChildOfSource?: boolean;
  hasAttachmentsOfSource?: boolean;
}

export interface CreateDoiRequest {
  metadataUuid: string;
  doiServerId: number;
}

export interface DelResourceRequest {
  metadataUuid: string;
  resourceId: string;
  approved?: boolean;
}

export interface DelResourcesRequest {
  metadataUuid: string;
  approved?: boolean;
}

export interface DeleteAllRecordStatusRequest {
  metadataUuid: string;
}

export interface DeleteAttributeRequest {
  metadataUuid: string;
  ref: string;
  displayAttributes?: boolean;
}

export interface DeleteElementRequest {
  metadataUuid: string;
  ref: Array<string>;
  parent: string;
  displayAttributes?: boolean;
}

export interface DeleteRecordRequest {
  metadataUuid: string;
  withBackup?: boolean;
}

export interface DeleteRecordStatusRequest {
  metadataUuid: string;
  statusId: number;
  userId: number;
  changeDate: string;
}

export interface DeleteRecordsRequest {
  uuids?: Array<string>;
  bucket?: string;
  withBackup?: boolean;
}

export interface DeleteTagForRecordsRequest {
  id: Array<number>;
  uuids?: Array<string>;
  bucket?: string;
}

export interface DeleteTagsRequest {
  metadataUuid: string;
  id?: Array<number>;
}

export interface EnableVersionControlRequest {
  metadataUuid: string;
}

export interface EnableVersionControlForRecordsRequest {
  uuids?: Array<string>;
  bucket?: string;
}

export interface ExportAsCsvRequest {
  uuids?: Array<string>;
  bucket?: string;
  language?: string;
  loopElementXpath?: string;
  propertiesXpath?: Array<string>;
  sep?: string;
  internalSep?: string;
}

export interface ExportAsMefRequest {
  uuids?: Array<string>;
  bucket?: string;
  format?: ExportAsMefFormatEnum;
  withRelated?: boolean;
  withXLinksResolved?: boolean;
  withXLinkAttribute?: boolean;
  addSchemaLocation?: boolean;
  approved?: boolean;
}

export interface ExportAsPdfRequest {
  uuids?: Array<string>;
  bucket?: string;
  language?: string;
}

export interface GetActiveUsersRequest {
  dateFrom: string;
  dateTo: string;
  groups?: Array<number>;
}

export interface GetAllRecordExtentAsImageRequest {
  metadataUuid: string;
  mapsrs?: string;
  width?: number;
  height?: number;
  background?: string;
  fillColor?: string;
  strokeColor?: string;
  approved?: boolean;
}

export interface GetAllRecordExtentAsJsonRequest {
  metadataUuid: string;
}

export interface GetAllResourcesRequest {
  metadataUuid: string;
  sort?: GetAllResourcesSortEnum;
  approved?: boolean;
  filter?: string;
}

export interface GetAsRdfRequest {
  from?: number;
  hitsPerPage?: number;
  any?: string;
  title?: string;
  facetQ?: string;
  sortBy?: string;
  sortOrder?: string;
  similarity?: number;
}

export interface GetAssociatedResourcesRequest {
  metadataUuid: string;
  type?: Array<RelatedItemType>;
  approved?: boolean;
  start?: number;
  rows?: number;
}

export interface GetFeatureCatalogRequest {
  metadataUuid: string;
  approved?: boolean;
}

export interface GetOneRecordExtentAsImageRequest {
  metadataUuid: string;
  geometryIndex: number;
  mapsrs?: string;
  width?: number;
  height?: number;
  background?: string;
  fillColor?: string;
  strokeColor?: string;
  approved?: boolean;
}

export interface GetRecordRequest {
  metadataUuid: string;
}

export interface GetRecordAsJsonRequest {
  metadataUuid: string;
  addSchemaLocation?: boolean;
  increasePopularity?: boolean;
  withInfo?: boolean;
  attachment?: boolean;
  approved?: boolean;
}

export interface GetRecordAsXmlRequest {
  metadataUuid: string;
  addSchemaLocation?: boolean;
  increasePopularity?: boolean;
  withInfo?: boolean;
  attachment?: boolean;
  approved?: boolean;
}

export interface GetRecordAsZipRequest {
  metadataUuid: string;
  format?: GetRecordAsZipFormatEnum;
  withRelated?: boolean;
  withXLinksResolved?: boolean;
  withXLinkAttribute?: boolean;
  addSchemaLocation?: boolean;
  approved?: boolean;
}

export interface GetRecordFormattedByRequest {
  formatterId: string;
  metadataUuid: string;
  width?: GetRecordFormattedByWidthEnum;
  mdpath?: string;
  language?: string;
  output?: GetRecordFormattedByOutputEnum;
  approved?: boolean;
}

export interface GetRecordPermalinkRequest {
  metadataUuid: string;
}

export interface GetRecordPopularityRequest {
  metadataUuid: string;
}

export interface GetRecordSharingSettingsRequest {
  metadataUuid: string;
}

export interface GetRecordStatusHistoryRequest {
  metadataUuid: string;
  details?: boolean;
  sortOrder?: GetRecordStatusHistorySortOrderEnum;
}

export interface GetRecordStatusHistoryByTypeRequest {
  metadataUuid: string;
  type: GetRecordStatusHistoryByTypeTypeEnum;
  details?: boolean;
  sortOrder?: GetRecordStatusHistoryByTypeSortOrderEnum;
}

export interface GetRecordTagsRequest {
  metadataUuid: string;
}

export interface GetRelatedResourcesRequest {
  metadataUuid: string;
  type?: Array<RelatedItemType>;
  approved?: boolean;
  start?: number;
  rows?: number;
}

export interface GetReportDataDownloadsRequest {
  dateFrom: string;
  dateTo: string;
  groups?: Array<number>;
}

export interface GetReportDataUploadsRequest {
  dateFrom: string;
  dateTo: string;
  groups?: Array<number>;
}

export interface GetReportInternalMetadataRequest {
  dateFrom: string;
  dateTo: string;
  groups?: Array<number>;
}

export interface GetReportUpdatedMetadataRequest {
  dateFrom: string;
  dateTo: string;
  groups?: Array<number>;
}

export interface GetResourceRequest {
  metadataUuid: string;
  resourceId: string;
  approved?: boolean;
  size?: number;
}

export interface GetSavedQueriesRequest {
  metadataUuid: string;
}

export interface GetStatusRequest {
  metadataUuid: string;
}

export interface GetSuggestionsRequest {
  metadataUuid: string;
}

export interface GetTestSuitesRequest {
  metadataUuid: string;
}

export interface GetWorkflowStatusByTypeRequest {
  type?: Array<GetWorkflowStatusByTypeTypeEnum>;
  details?: boolean;
  sortOrder?: GetWorkflowStatusByTypeSortOrderEnum;
  author?: Array<number>;
  owner?: Array<number>;
  id?: Array<number>;
  recordIdentifier?: Array<number>;
  uuid?: Array<string>;
  statusIds?: Array<string>;
  dateFrom?: string;
  dateTo?: string;
  from?: number;
  size?: number;
}

export interface IncreaseRecordPopularityRequest {
  metadataUuid: string;
}

export interface IndexRequest {
  uuids?: Array<string>;
  bucket?: string;
}

export interface InsertRequest {
  metadataType?: InsertMetadataTypeEnum;
  url?: Array<string>;
  serverFolder?: string;
  recursiveSearch?: boolean;
  publishToAll?: boolean;
  assignToCatalog?: boolean;
  uuidProcessing?: InsertUuidProcessingEnum;
  group?: string;
  category?: Array<string>;
  rejectIfInvalid?: boolean;
  transformWith?: string;
  schema?: string;
  allowEditGroupMembers?: boolean;
  extra?: string;
  body?: string;
}

export interface InsertFileRequest {
  metadataType?: InsertFileMetadataTypeEnum;
  file?: Array<Blob>;
  uuidProcessing?: InsertFileUuidProcessingEnum;
  group?: string;
  category?: Array<string>;
  rejectIfInvalid?: boolean;
  publishToAll?: boolean;
  assignToCatalog?: boolean;
  transformWith?: string;
  schema?: string;
  extra?: string;
  allowEditGroupMembers?: boolean;
}

export interface InsertOgcMapContextFileRequest {
  title: string;
  recordAbstract?: string;
  xml?: string;
  filename?: string;
  url?: string;
  viewerUrl?: string;
  overview?: string;
  overviewFilename?: string;
  topic?: string;
  publishToAll?: boolean;
  uuidProcessing?: InsertOgcMapContextFileUuidProcessingEnum;
  group?: string;
  schema?: string;
}

export interface PatchResourceRequest {
  metadataUuid: string;
  resourceId: string;
  visibility: PatchResourceVisibilityEnum;
  approved?: boolean;
}

export interface PreviewBatchEditRequest {
  batchEditParameter: Array<BatchEditParameter>;
  uuids?: Array<string>;
  bucket?: string;
  diffType?: PreviewBatchEditDiffTypeEnum;
}

export interface ProcessRecordRequest {
  metadataUuid: string;
  process: string;
  processParams?: { [key: string]: any };
}

export interface ProcessRecordPreviewRequest {
  metadataUuid: string;
  process: string;
}

export interface PublishRequest {
  metadataUuid: string;
  publicationType: string;
}

export interface PublishMultipleRecordsRequest {
  publicationType: string;
  uuids?: Array<string>;
  bucket?: string;
}

export interface PutResourceRequest {
  metadataUuid: string;
  file: Blob;
  visibility?: PutResourceVisibilityEnum;
  approved?: boolean;
}

export interface PutResourceFromURLRequest {
  metadataUuid: string;
  url: string;
  visibility?: PutResourceFromURLVisibilityEnum;
  approved?: boolean;
}

export interface RateRecordRequest {
  metadataUuid: string;
  body: number;
}

export interface ReorderElementRequest {
  metadataUuid: string;
  ref: string;
  direction: Direction;
  displayAttributes?: boolean;
}

export interface RestoreAtStatusSaveRequest {
  metadataUuid: string;
  statusId: number;
  userId: number;
  changeDate: string;
}

export interface SaveEditsRequest {
  metadataUuid: string;
  tab?: string;
  withAttributes?: boolean;
  withValidationErrors?: boolean;
  minor?: boolean;
  status?: string;
  commit?: boolean;
  terminate?: boolean;
  data?: string;
}

export interface SaveThumbnailRequest {
  metadataUuid: string;
  jsonConfig: string;
  rotationAngle?: number;
}

export interface SetGroupAndOwnerRequest {
  groupIdentifier: number;
  userIdentifier: number;
  uuids?: Array<string>;
  bucket?: string;
  approved?: boolean;
}

export interface SetRecordGroupRequest {
  metadataUuid: string;
  body: number;
}

export interface SetRecordOwnershipRequest {
  metadataUuid: string;
  groupIdentifier: number;
  userIdentifier: number;
  approved?: boolean;
}

export interface SetStatusRequest {
  metadataUuid: string;
  metadataStatusParameter: MetadataStatusParameter;
}

export interface ShareRequest {
  metadataUuid: string;
  sharingParameter: SharingParameter;
}

export interface ShareMultipleRecordsRequest {
  sharingParameter: SharingParameter;
  uuids?: Array<string>;
  bucket?: string;
}

export interface ShowStatusAfterRequest {
  metadataUuid: string;
  statusId: number;
  userId: number;
  changeDate: string;
}

export interface ShowStatusBeforeRequest {
  metadataUuid: string;
  statusId: number;
  userId: number;
  changeDate: string;
}

export interface StartEditingRequest {
  metadataUuid: string;
  currTab?: string;
  withAttributes?: boolean;
}

export interface SubmitRequest {
  metadataBatchSubmitParameter: MetadataBatchSubmitParameter;
}

export interface TagRecordRequest {
  metadataUuid: string;
  id: Array<number>;
  clear?: boolean;
}

export interface TagRecordsRequest {
  uuids?: Array<string>;
  bucket?: string;
  id?: Array<number>;
  removeId?: Array<number>;
  clear?: boolean;
}

export interface UnpublishRequest {
  metadataUuid: string;
  publicationType: string;
}

export interface UnpublishMultipleRecordsRequest {
  publicationType: string;
  uuids?: Array<string>;
  bucket?: string;
}

export interface UnregisterDoiRequest {
  metadataUuid: string;
  doiServerId: number;
}

export interface ValidateRecordRequest {
  metadataUuid: string;
  isvalid?: boolean;
}

export interface ValidateRecordForInspireRequest {
  metadataUuid: string;
  testsuite: string;
  mode?: string;
}

export interface ValidateRecordsRequest {
  uuids?: Array<string>;
  approved?: boolean;
  bucket?: string;
}

export interface ValidateRecordsInspireRequest {
  uuids?: Array<string>;
  bucket?: string;
  mode?: string;
}

/**
 *
 */
export class RecordsApi extends runtime.BaseAPI {
  /**
   * Add element
   */
  async addElementRaw(
    requestParameters: AddElementRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters['metadataUuid'] == null) {
      throw new runtime.RequiredError(
        'metadataUuid',
        'Required parameter "metadataUuid" was null or undefined when calling addElement().'
      );
    }

    if (requestParameters['ref'] == null) {
      throw new runtime.RequiredError(
        'ref',
        'Required parameter "ref" was null or undefined when calling addElement().'
      );
    }

    if (requestParameters['name'] == null) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter "name" was null or undefined when calling addElement().'
      );
    }

    const queryParameters: any = {};

    if (requestParameters['ref'] != null) {
      queryParameters['ref'] = requestParameters['ref'];
    }

    if (requestParameters['name'] != null) {
      queryParameters['name'] = requestParameters['name'];
    }

    if (requestParameters['child'] != null) {
      queryParameters['child'] = requestParameters['child'];
    }

    if (requestParameters['displayAttributes'] != null) {
      queryParameters['displayAttributes'] =
        requestParameters['displayAttributes'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/records/{metadataUuid}/editor/elements`.replace(
          `{${'metadataUuid'}}`,
          encodeURIComponent(String(requestParameters['metadataUuid']))
        ),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Add element
   */
  async addElement(
    requestParameters: AddElementRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<void> {
    await this.addElementRaw(requestParameters, initOverrides);
  }

  /**
   * Add sample records for one or more schemas. Samples are defined for each standard in the samples folder as MEF files.
   * Add samples
   */
  async addSamplesRaw(
    requestParameters: AddSamplesRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<SimpleMetadataProcessingReport>> {
    if (requestParameters['schema'] == null) {
      throw new runtime.RequiredError(
        'schema',
        'Required parameter "schema" was null or undefined when calling addSamples().'
      );
    }

    const queryParameters: any = {};

    if (requestParameters['schema'] != null) {
      queryParameters['schema'] = requestParameters['schema'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/records/samples`,
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, jsonValue =>
      SimpleMetadataProcessingReportFromJSON(jsonValue)
    );
  }

  /**
   * Add sample records for one or more schemas. Samples are defined for each standard in the samples folder as MEF files.
   * Add samples
   */
  async addSamples(
    requestParameters: AddSamplesRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<SimpleMetadataProcessingReport> {
    const response = await this.addSamplesRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Add template records for one or more schemas. Templates are defined for each standard in the template folder as XML files. Template may also contains subtemplates.
   * Add templates
   */
  async addTemplatesRaw(
    requestParameters: AddTemplatesRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<SimpleMetadataProcessingReport>> {
    if (requestParameters['schema'] == null) {
      throw new runtime.RequiredError(
        'schema',
        'Required parameter "schema" was null or undefined when calling addTemplates().'
      );
    }

    const queryParameters: any = {};

    if (requestParameters['schema'] != null) {
      queryParameters['schema'] = requestParameters['schema'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/records/templates`,
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, jsonValue =>
      SimpleMetadataProcessingReportFromJSON(jsonValue)
    );
  }

  /**
   * Add template records for one or more schemas. Templates are defined for each standard in the template folder as XML files. Template may also contains subtemplates.
   * Add templates
   */
  async addTemplates(
    requestParameters: AddTemplatesRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<SimpleMetadataProcessingReport> {
    const response = await this.addTemplatesRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * All parameters will be substituted to the XPath query. eg. {{protocol}} in the XPath expression will be replaced by the protocol parameter provided in the request body.
   * Apply a saved query for this metadata
   */
  async applyQueryRaw(
    requestParameters: ApplyQueryRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<{ [key: string]: string }>> {
    if (requestParameters['metadataUuid'] == null) {
      throw new runtime.RequiredError(
        'metadataUuid',
        'Required parameter "metadataUuid" was null or undefined when calling applyQuery().'
      );
    }

    if (requestParameters['savedQuery'] == null) {
      throw new runtime.RequiredError(
        'savedQuery',
        'Required parameter "savedQuery" was null or undefined when calling applyQuery().'
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/records/{metadataUuid}/query/{savedQuery}`
          .replace(
            `{${'metadataUuid'}}`,
            encodeURIComponent(String(requestParameters['metadataUuid']))
          )
          .replace(
            `{${'savedQuery'}}`,
            encodeURIComponent(String(requestParameters['savedQuery']))
          ),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: requestParameters['requestBody'],
      },
      initOverrides
    );

    return new runtime.JSONApiResponse<any>(response);
  }

  /**
   * All parameters will be substituted to the XPath query. eg. {{protocol}} in the XPath expression will be replaced by the protocol parameter provided in the request body.
   * Apply a saved query for this metadata
   */
  async applyQuery(
    requestParameters: ApplyQueryRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<{ [key: string]: string }> {
    const response = await this.applyQueryRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Set the records status to approved
   */
  async approveRaw(
    requestParameters: ApproveRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<MetadataProcessingReport>> {
    if (requestParameters['metadataBatchApproveParameter'] == null) {
      throw new runtime.RequiredError(
        'metadataBatchApproveParameter',
        'Required parameter "metadataBatchApproveParameter" was null or undefined when calling approve().'
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/records/approve`,
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: MetadataBatchApproveParameterToJSON(
          requestParameters['metadataBatchApproveParameter']
        ),
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, jsonValue =>
      MetadataProcessingReportFromJSON(jsonValue)
    );
  }

  /**
   * Set the records status to approved
   */
  async approve(
    requestParameters: ApproveRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<MetadataProcessingReport> {
    const response = await this.approveRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Edit a set of records by XPath expressions. This operations applies the update-fixed-info.xsl transformation for the metadata schema and updates the change date if the parameter updateDateStamp is set to true.
   */
  async batchEditRaw(
    requestParameters: BatchEditRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<IProcessingReport>> {
    if (requestParameters['batchEditParameter'] == null) {
      throw new runtime.RequiredError(
        'batchEditParameter',
        'Required parameter "batchEditParameter" was null or undefined when calling batchEdit().'
      );
    }

    const queryParameters: any = {};

    if (requestParameters['uuids'] != null) {
      queryParameters['uuids'] = requestParameters['uuids'];
    }

    if (requestParameters['bucket'] != null) {
      queryParameters['bucket'] = requestParameters['bucket'];
    }

    if (requestParameters['updateDateStamp'] != null) {
      queryParameters['updateDateStamp'] = requestParameters['updateDateStamp'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/records/batchediting`,
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: requestParameters['batchEditParameter']!.map(
          BatchEditParameterToJSON
        ),
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, jsonValue =>
      IProcessingReportFromJSON(jsonValue)
    );
  }

  /**
   * Edit a set of records by XPath expressions. This operations applies the update-fixed-info.xsl transformation for the metadata schema and updates the change date if the parameter updateDateStamp is set to true.
   */
  async batchEdit(
    requestParameters: BatchEditRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<IProcessingReport> {
    const response = await this.batchEditRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Cancel current editing session.
   * Cancel edits
   */
  async cancelEditsRaw(
    requestParameters: CancelEditsRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters['metadataUuid'] == null) {
      throw new runtime.RequiredError(
        'metadataUuid',
        'Required parameter "metadataUuid" was null or undefined when calling cancelEdits().'
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/records/{metadataUuid}/editor`.replace(
          `{${'metadataUuid'}}`,
          encodeURIComponent(String(requestParameters['metadataUuid']))
        ),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Cancel current editing session.
   * Cancel edits
   */
  async cancelEdits(
    requestParameters: CancelEditsRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<void> {
    await this.cancelEditsRaw(requestParameters, initOverrides);
  }

  /**
   * Check that a record can be submitted to DataCite for DOI creation. DataCite requires some fields to be populated.
   */
  async checkDoiStatusRaw(
    requestParameters: CheckDoiStatusRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<{ [key: string]: boolean }>> {
    if (requestParameters['metadataUuid'] == null) {
      throw new runtime.RequiredError(
        'metadataUuid',
        'Required parameter "metadataUuid" was null or undefined when calling checkDoiStatus().'
      );
    }

    if (requestParameters['doiServerId'] == null) {
      throw new runtime.RequiredError(
        'doiServerId',
        'Required parameter "doiServerId" was null or undefined when calling checkDoiStatus().'
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/records/{metadataUuid}/doi/{doiServerId}/checkPreConditions`
          .replace(
            `{${'metadataUuid'}}`,
            encodeURIComponent(String(requestParameters['metadataUuid']))
          )
          .replace(
            `{${'doiServerId'}}`,
            encodeURIComponent(String(requestParameters['doiServerId']))
          ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse<any>(response);
  }

  /**
   * Check that a record can be submitted to DataCite for DOI creation. DataCite requires some fields to be populated.
   */
  async checkDoiStatus(
    requestParameters: CheckDoiStatusRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<{ [key: string]: boolean }> {
    const response = await this.checkDoiStatusRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Check the DOI URL created based on current configuration and pattern.
   */
  async checkDoiUrlRaw(
    requestParameters: CheckDoiUrlRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters['metadataUuid'] == null) {
      throw new runtime.RequiredError(
        'metadataUuid',
        'Required parameter "metadataUuid" was null or undefined when calling checkDoiUrl().'
      );
    }

    if (requestParameters['doiServerId'] == null) {
      throw new runtime.RequiredError(
        'doiServerId',
        'Required parameter "doiServerId" was null or undefined when calling checkDoiUrl().'
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/records/{metadataUuid}/doi/{doiServerId}/checkDoiUrl`
          .replace(
            `{${'metadataUuid'}}`,
            encodeURIComponent(String(requestParameters['metadataUuid']))
          )
          .replace(
            `{${'doiServerId'}}`,
            encodeURIComponent(String(requestParameters['doiServerId']))
          ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    if (this.isJsonMime(response.headers.get('content-type'))) {
      return new runtime.JSONApiResponse<string>(response);
    } else {
      return new runtime.TextApiResponse(response) as any;
    }
  }

  /**
   * Check the DOI URL created based on current configuration and pattern.
   */
  async checkDoiUrl(
    requestParameters: CheckDoiUrlRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<string> {
    const response = await this.checkDoiUrlRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Verifies if a metadata field value is in use. Fields supported: title (title), alternate title (altTitle) or resource identifier (identifier)
   * Check if metadata field value is duplicated in another metadata
   */
  async checkDuplicatedFieldValueRaw(
    requestParameters: CheckDuplicatedFieldValueRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<boolean>> {
    if (requestParameters['metadataUuid'] == null) {
      throw new runtime.RequiredError(
        'metadataUuid',
        'Required parameter "metadataUuid" was null or undefined when calling checkDuplicatedFieldValue().'
      );
    }

    if (requestParameters['duplicatedValueDto'] == null) {
      throw new runtime.RequiredError(
        'duplicatedValueDto',
        'Required parameter "duplicatedValueDto" was null or undefined when calling checkDuplicatedFieldValue().'
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/records/{metadataUuid}/checkDuplicatedFieldValue`.replace(
          `{${'metadataUuid'}}`,
          encodeURIComponent(String(requestParameters['metadataUuid']))
        ),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: DuplicatedValueDtoToJSON(requestParameters['duplicatedValueDto']),
      },
      initOverrides
    );

    if (this.isJsonMime(response.headers.get('content-type'))) {
      return new runtime.JSONApiResponse<boolean>(response);
    } else {
      return new runtime.TextApiResponse(response) as any;
    }
  }

  /**
   * Verifies if a metadata field value is in use. Fields supported: title (title), alternate title (altTitle) or resource identifier (identifier)
   * Check if metadata field value is duplicated in another metadata
   */
  async checkDuplicatedFieldValue(
    requestParameters: CheckDuplicatedFieldValueRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<boolean> {
    const response = await this.checkDuplicatedFieldValueRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * User MUST be able to edit the record to validate it. An INSPIRE endpoint must be configured in Settings. If the process is complete an object with status is returned.
   * Check the status of validation with the INSPIRE service.
   */
  async checkValidationRaw(
    requestParameters: CheckValidationRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<{ [key: string]: string }>> {
    if (requestParameters['testId'] == null) {
      throw new runtime.RequiredError(
        'testId',
        'Required parameter "testId" was null or undefined when calling checkValidation().'
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/records/{testId}/validate/inspire`.replace(
          `{${'testId'}}`,
          encodeURIComponent(String(requestParameters['testId']))
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse<any>(response);
  }

  /**
   * User MUST be able to edit the record to validate it. An INSPIRE endpoint must be configured in Settings. If the process is complete an object with status is returned.
   * Check the status of validation with the INSPIRE service.
   */
  async checkValidation(
    requestParameters: CheckValidationRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<{ [key: string]: string }> {
    const response = await this.checkValidationRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Clear validation status of one or more records
   */
  async cleanValidationStatusRaw(
    requestParameters: CleanValidationStatusRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<SimpleMetadataProcessingReport>> {
    const queryParameters: any = {};

    if (requestParameters['uuids'] != null) {
      queryParameters['uuids'] = requestParameters['uuids'];
    }

    if (requestParameters['bucket'] != null) {
      queryParameters['bucket'] = requestParameters['bucket'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/records/validate`,
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, jsonValue =>
      SimpleMetadataProcessingReportFromJSON(jsonValue)
    );
  }

  /**
   * Clear validation status of one or more records
   */
  async cleanValidationStatus(
    requestParameters: CleanValidationStatusRequest = {},
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<SimpleMetadataProcessingReport> {
    const response = await this.cleanValidationStatusRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Close a record task
   */
  async closeTaskRaw(
    requestParameters: CloseTaskRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters['metadataUuid'] == null) {
      throw new runtime.RequiredError(
        'metadataUuid',
        'Required parameter "metadataUuid" was null or undefined when calling closeTask().'
      );
    }

    if (requestParameters['statusId'] == null) {
      throw new runtime.RequiredError(
        'statusId',
        'Required parameter "statusId" was null or undefined when calling closeTask().'
      );
    }

    if (requestParameters['userId'] == null) {
      throw new runtime.RequiredError(
        'userId',
        'Required parameter "userId" was null or undefined when calling closeTask().'
      );
    }

    if (requestParameters['changeDate'] == null) {
      throw new runtime.RequiredError(
        'changeDate',
        'Required parameter "changeDate" was null or undefined when calling closeTask().'
      );
    }

    if (requestParameters['closeDate'] == null) {
      throw new runtime.RequiredError(
        'closeDate',
        'Required parameter "closeDate" was null or undefined when calling closeTask().'
      );
    }

    const queryParameters: any = {};

    if (requestParameters['closeDate'] != null) {
      queryParameters['closeDate'] = requestParameters['closeDate'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/records/{metadataUuid}/status/{statusId}.{userId}.{changeDate}/close`
          .replace(
            `{${'metadataUuid'}}`,
            encodeURIComponent(String(requestParameters['metadataUuid']))
          )
          .replace(
            `{${'statusId'}}`,
            encodeURIComponent(String(requestParameters['statusId']))
          )
          .replace(
            `{${'userId'}}`,
            encodeURIComponent(String(requestParameters['userId']))
          )
          .replace(
            `{${'changeDate'}}`,
            encodeURIComponent(String(requestParameters['changeDate']))
          ),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Close a record task
   */
  async closeTask(
    requestParameters: CloseTaskRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<void> {
    await this.closeTaskRaw(requestParameters, initOverrides);
  }

  /**
   * Create a record from a template or by copying an existing record.Return the UUID of the newly created record. Existing links in the source record are preserved, this means that the new record may contains link to the source attachments. They need to be manually updated after creation.
   * Create a new record
   */
  async createRaw(
    requestParameters: CreateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters['sourceUuid'] == null) {
      throw new runtime.RequiredError(
        'sourceUuid',
        'Required parameter "sourceUuid" was null or undefined when calling create().'
      );
    }

    if (requestParameters['group'] == null) {
      throw new runtime.RequiredError(
        'group',
        'Required parameter "group" was null or undefined when calling create().'
      );
    }

    const queryParameters: any = {};

    if (requestParameters['metadataType'] != null) {
      queryParameters['metadataType'] = requestParameters['metadataType'];
    }

    if (requestParameters['sourceUuid'] != null) {
      queryParameters['sourceUuid'] = requestParameters['sourceUuid'];
    }

    if (requestParameters['targetUuid'] != null) {
      queryParameters['targetUuid'] = requestParameters['targetUuid'];
    }

    if (requestParameters['group'] != null) {
      queryParameters['group'] = requestParameters['group'];
    }

    if (requestParameters['allowEditGroupMembers'] != null) {
      queryParameters['allowEditGroupMembers'] =
        requestParameters['allowEditGroupMembers'];
    }

    if (requestParameters['category'] != null) {
      queryParameters['category'] = requestParameters['category'];
    }

    if (requestParameters['hasCategoryOfSource'] != null) {
      queryParameters['hasCategoryOfSource'] =
        requestParameters['hasCategoryOfSource'];
    }

    if (requestParameters['isChildOfSource'] != null) {
      queryParameters['isChildOfSource'] = requestParameters['isChildOfSource'];
    }

    if (requestParameters['hasAttachmentsOfSource'] != null) {
      queryParameters['hasAttachmentsOfSource'] =
        requestParameters['hasAttachmentsOfSource'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/records/duplicate`,
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    if (this.isJsonMime(response.headers.get('content-type'))) {
      return new runtime.JSONApiResponse<string>(response);
    } else {
      return new runtime.TextApiResponse(response) as any;
    }
  }

  /**
   * Create a record from a template or by copying an existing record.Return the UUID of the newly created record. Existing links in the source record are preserved, this means that the new record may contains link to the source attachments. They need to be manually updated after creation.
   * Create a new record
   */
  async create(
    requestParameters: CreateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<string> {
    const response = await this.createRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Submit a record to the Datacite metadata store in order to create a DOI.
   */
  async createDoiRaw(
    requestParameters: CreateDoiRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<{ [key: string]: string }>> {
    if (requestParameters['metadataUuid'] == null) {
      throw new runtime.RequiredError(
        'metadataUuid',
        'Required parameter "metadataUuid" was null or undefined when calling createDoi().'
      );
    }

    if (requestParameters['doiServerId'] == null) {
      throw new runtime.RequiredError(
        'doiServerId',
        'Required parameter "doiServerId" was null or undefined when calling createDoi().'
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/records/{metadataUuid}/doi/{doiServerId}`
          .replace(
            `{${'metadataUuid'}}`,
            encodeURIComponent(String(requestParameters['metadataUuid']))
          )
          .replace(
            `{${'doiServerId'}}`,
            encodeURIComponent(String(requestParameters['doiServerId']))
          ),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse<any>(response);
  }

  /**
   * Submit a record to the Datacite metadata store in order to create a DOI.
   */
  async createDoi(
    requestParameters: CreateDoiRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<{ [key: string]: string }> {
    const response = await this.createDoiRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Delete a metadata resource
   */
  async delResourceRaw(
    requestParameters: DelResourceRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters['metadataUuid'] == null) {
      throw new runtime.RequiredError(
        'metadataUuid',
        'Required parameter "metadataUuid" was null or undefined when calling delResource().'
      );
    }

    if (requestParameters['resourceId'] == null) {
      throw new runtime.RequiredError(
        'resourceId',
        'Required parameter "resourceId" was null or undefined when calling delResource().'
      );
    }

    const queryParameters: any = {};

    if (requestParameters['approved'] != null) {
      queryParameters['approved'] = requestParameters['approved'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/records/{metadataUuid}/attachments/{resourceId}`
          .replace(
            `{${'metadataUuid'}}`,
            encodeURIComponent(String(requestParameters['metadataUuid']))
          )
          .replace(
            `{${'resourceId'}}`,
            encodeURIComponent(String(requestParameters['resourceId']))
          ),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Delete a metadata resource
   */
  async delResource(
    requestParameters: DelResourceRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<void> {
    await this.delResourceRaw(requestParameters, initOverrides);
  }

  /**
   * Delete all uploaded metadata resources
   */
  async delResourcesRaw(
    requestParameters: DelResourcesRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters['metadataUuid'] == null) {
      throw new runtime.RequiredError(
        'metadataUuid',
        'Required parameter "metadataUuid" was null or undefined when calling delResources().'
      );
    }

    const queryParameters: any = {};

    if (requestParameters['approved'] != null) {
      queryParameters['approved'] = requestParameters['approved'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/records/{metadataUuid}/attachments`.replace(
          `{${'metadataUuid'}}`,
          encodeURIComponent(String(requestParameters['metadataUuid']))
        ),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Delete all uploaded metadata resources
   */
  async delResources(
    requestParameters: DelResourcesRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<void> {
    await this.delResourcesRaw(requestParameters, initOverrides);
  }

  /**
   * Delete all record status
   */
  async deleteAllRecordStatusRaw(
    requestParameters: DeleteAllRecordStatusRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters['metadataUuid'] == null) {
      throw new runtime.RequiredError(
        'metadataUuid',
        'Required parameter "metadataUuid" was null or undefined when calling deleteAllRecordStatus().'
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/records/{metadataUuid}/status`.replace(
          `{${'metadataUuid'}}`,
          encodeURIComponent(String(requestParameters['metadataUuid']))
        ),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Delete all record status
   */
  async deleteAllRecordStatus(
    requestParameters: DeleteAllRecordStatusRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<void> {
    await this.deleteAllRecordStatusRaw(requestParameters, initOverrides);
  }

  /**
   * Delete attribute
   */
  async deleteAttributeRaw(
    requestParameters: DeleteAttributeRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters['metadataUuid'] == null) {
      throw new runtime.RequiredError(
        'metadataUuid',
        'Required parameter "metadataUuid" was null or undefined when calling deleteAttribute().'
      );
    }

    if (requestParameters['ref'] == null) {
      throw new runtime.RequiredError(
        'ref',
        'Required parameter "ref" was null or undefined when calling deleteAttribute().'
      );
    }

    const queryParameters: any = {};

    if (requestParameters['ref'] != null) {
      queryParameters['ref'] = requestParameters['ref'];
    }

    if (requestParameters['displayAttributes'] != null) {
      queryParameters['displayAttributes'] =
        requestParameters['displayAttributes'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/records/{metadataUuid}/editor/attributes`.replace(
          `{${'metadataUuid'}}`,
          encodeURIComponent(String(requestParameters['metadataUuid']))
        ),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Delete attribute
   */
  async deleteAttribute(
    requestParameters: DeleteAttributeRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<void> {
    await this.deleteAttributeRaw(requestParameters, initOverrides);
  }

  /**
   * Delete element
   */
  async deleteElementRaw(
    requestParameters: DeleteElementRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters['metadataUuid'] == null) {
      throw new runtime.RequiredError(
        'metadataUuid',
        'Required parameter "metadataUuid" was null or undefined when calling deleteElement().'
      );
    }

    if (requestParameters['ref'] == null) {
      throw new runtime.RequiredError(
        'ref',
        'Required parameter "ref" was null or undefined when calling deleteElement().'
      );
    }

    if (requestParameters['parent'] == null) {
      throw new runtime.RequiredError(
        'parent',
        'Required parameter "parent" was null or undefined when calling deleteElement().'
      );
    }

    const queryParameters: any = {};

    if (requestParameters['ref'] != null) {
      queryParameters['ref'] = requestParameters['ref'];
    }

    if (requestParameters['parent'] != null) {
      queryParameters['parent'] = requestParameters['parent'];
    }

    if (requestParameters['displayAttributes'] != null) {
      queryParameters['displayAttributes'] =
        requestParameters['displayAttributes'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/records/{metadataUuid}/editor/elements`.replace(
          `{${'metadataUuid'}}`,
          encodeURIComponent(String(requestParameters['metadataUuid']))
        ),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Delete element
   */
  async deleteElement(
    requestParameters: DeleteElementRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<void> {
    await this.deleteElementRaw(requestParameters, initOverrides);
  }

  /**
   * User MUST be able to edit the record to delete it. By default, a backup is made in ZIP format. After that, the record attachments are removed, the document removed from the index and then from the database.
   * Delete a record
   */
  async deleteRecordRaw(
    requestParameters: DeleteRecordRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters['metadataUuid'] == null) {
      throw new runtime.RequiredError(
        'metadataUuid',
        'Required parameter "metadataUuid" was null or undefined when calling deleteRecord().'
      );
    }

    const queryParameters: any = {};

    if (requestParameters['withBackup'] != null) {
      queryParameters['withBackup'] = requestParameters['withBackup'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/records/{metadataUuid}`.replace(
          `{${'metadataUuid'}}`,
          encodeURIComponent(String(requestParameters['metadataUuid']))
        ),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User MUST be able to edit the record to delete it. By default, a backup is made in ZIP format. After that, the record attachments are removed, the document removed from the index and then from the database.
   * Delete a record
   */
  async deleteRecord(
    requestParameters: DeleteRecordRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<void> {
    await this.deleteRecordRaw(requestParameters, initOverrides);
  }

  /**
   * Delete a record status
   */
  async deleteRecordStatusRaw(
    requestParameters: DeleteRecordStatusRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters['metadataUuid'] == null) {
      throw new runtime.RequiredError(
        'metadataUuid',
        'Required parameter "metadataUuid" was null or undefined when calling deleteRecordStatus().'
      );
    }

    if (requestParameters['statusId'] == null) {
      throw new runtime.RequiredError(
        'statusId',
        'Required parameter "statusId" was null or undefined when calling deleteRecordStatus().'
      );
    }

    if (requestParameters['userId'] == null) {
      throw new runtime.RequiredError(
        'userId',
        'Required parameter "userId" was null or undefined when calling deleteRecordStatus().'
      );
    }

    if (requestParameters['changeDate'] == null) {
      throw new runtime.RequiredError(
        'changeDate',
        'Required parameter "changeDate" was null or undefined when calling deleteRecordStatus().'
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/records/{metadataUuid}/status/{statusId}.{userId}.{changeDate}`
          .replace(
            `{${'metadataUuid'}}`,
            encodeURIComponent(String(requestParameters['metadataUuid']))
          )
          .replace(
            `{${'statusId'}}`,
            encodeURIComponent(String(requestParameters['statusId']))
          )
          .replace(
            `{${'userId'}}`,
            encodeURIComponent(String(requestParameters['userId']))
          )
          .replace(
            `{${'changeDate'}}`,
            encodeURIComponent(String(requestParameters['changeDate']))
          ),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Delete a record status
   */
  async deleteRecordStatus(
    requestParameters: DeleteRecordStatusRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<void> {
    await this.deleteRecordStatusRaw(requestParameters, initOverrides);
  }

  /**
   * User MUST be able to edit the record to delete it.
   * Delete one or more records
   */
  async deleteRecordsRaw(
    requestParameters: DeleteRecordsRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<SimpleMetadataProcessingReport>> {
    const queryParameters: any = {};

    if (requestParameters['uuids'] != null) {
      queryParameters['uuids'] = requestParameters['uuids'];
    }

    if (requestParameters['bucket'] != null) {
      queryParameters['bucket'] = requestParameters['bucket'];
    }

    if (requestParameters['withBackup'] != null) {
      queryParameters['withBackup'] = requestParameters['withBackup'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/records`,
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, jsonValue =>
      SimpleMetadataProcessingReportFromJSON(jsonValue)
    );
  }

  /**
   * User MUST be able to edit the record to delete it.
   * Delete one or more records
   */
  async deleteRecords(
    requestParameters: DeleteRecordsRequest = {},
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<SimpleMetadataProcessingReport> {
    const response = await this.deleteRecordsRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Delete tags to one or more records
   */
  async deleteTagForRecordsRaw(
    requestParameters: DeleteTagForRecordsRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<MetadataProcessingReport>> {
    if (requestParameters['id'] == null) {
      throw new runtime.RequiredError(
        'id',
        'Required parameter "id" was null or undefined when calling deleteTagForRecords().'
      );
    }

    const queryParameters: any = {};

    if (requestParameters['uuids'] != null) {
      queryParameters['uuids'] = requestParameters['uuids'];
    }

    if (requestParameters['bucket'] != null) {
      queryParameters['bucket'] = requestParameters['bucket'];
    }

    if (requestParameters['id'] != null) {
      queryParameters['id'] = requestParameters['id'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/records/tags`,
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, jsonValue =>
      MetadataProcessingReportFromJSON(jsonValue)
    );
  }

  /**
   * Delete tags to one or more records
   */
  async deleteTagForRecords(
    requestParameters: DeleteTagForRecordsRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<MetadataProcessingReport> {
    const response = await this.deleteTagForRecordsRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Delete tags of a record
   */
  async deleteTagsRaw(
    requestParameters: DeleteTagsRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters['metadataUuid'] == null) {
      throw new runtime.RequiredError(
        'metadataUuid',
        'Required parameter "metadataUuid" was null or undefined when calling deleteTags().'
      );
    }

    const queryParameters: any = {};

    if (requestParameters['id'] != null) {
      queryParameters['id'] = requestParameters['id'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/records/{metadataUuid}/tags`.replace(
          `{${'metadataUuid'}}`,
          encodeURIComponent(String(requestParameters['metadataUuid']))
        ),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Delete tags of a record
   */
  async deleteTags(
    requestParameters: DeleteTagsRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<void> {
    await this.deleteTagsRaw(requestParameters, initOverrides);
  }

  /**
   * The backup contains all metadata not harvested including templates.
   * Download MEF backup archive
   */
  async downloadBackupRaw(
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<void>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/records/backups/latest`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * The backup contains all metadata not harvested including templates.
   * Download MEF backup archive
   */
  async downloadBackup(
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<void> {
    await this.downloadBackupRaw(initOverrides);
  }

  /**
   * (Experimental) Enable version control
   */
  async enableVersionControlRaw(
    requestParameters: EnableVersionControlRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters['metadataUuid'] == null) {
      throw new runtime.RequiredError(
        'metadataUuid',
        'Required parameter "metadataUuid" was null or undefined when calling enableVersionControl().'
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/records/{metadataUuid}/versions`.replace(
          `{${'metadataUuid'}}`,
          encodeURIComponent(String(requestParameters['metadataUuid']))
        ),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    if (this.isJsonMime(response.headers.get('content-type'))) {
      return new runtime.JSONApiResponse<string>(response);
    } else {
      return new runtime.TextApiResponse(response) as any;
    }
  }

  /**
   * (Experimental) Enable version control
   */
  async enableVersionControl(
    requestParameters: EnableVersionControlRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<string> {
    const response = await this.enableVersionControlRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * (Experimental) Enable version control for one or more records
   */
  async enableVersionControlForRecordsRaw(
    requestParameters: EnableVersionControlForRecordsRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<MetadataProcessingReport>> {
    const queryParameters: any = {};

    if (requestParameters['uuids'] != null) {
      queryParameters['uuids'] = requestParameters['uuids'];
    }

    if (requestParameters['bucket'] != null) {
      queryParameters['bucket'] = requestParameters['bucket'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/records/versions`,
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, jsonValue =>
      MetadataProcessingReportFromJSON(jsonValue)
    );
  }

  /**
   * (Experimental) Enable version control for one or more records
   */
  async enableVersionControlForRecords(
    requestParameters: EnableVersionControlForRecordsRequest = {},
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<MetadataProcessingReport> {
    const response = await this.enableVersionControlForRecordsRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * The CSV is a short summary of each records.
   * Get a set of metadata records as CSV
   */
  async exportAsCsvRaw(
    requestParameters: ExportAsCsvRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<void>> {
    const queryParameters: any = {};

    if (requestParameters['uuids'] != null) {
      queryParameters['uuids'] = requestParameters['uuids'];
    }

    if (requestParameters['bucket'] != null) {
      queryParameters['bucket'] = requestParameters['bucket'];
    }

    if (requestParameters['language'] != null) {
      queryParameters['language'] = requestParameters['language'];
    }

    if (requestParameters['loopElementXpath'] != null) {
      queryParameters['loopElementXpath'] =
        requestParameters['loopElementXpath'];
    }

    if (requestParameters['propertiesXpath'] != null) {
      queryParameters['propertiesXpath'] = requestParameters['propertiesXpath'];
    }

    if (requestParameters['sep'] != null) {
      queryParameters['sep'] = requestParameters['sep'];
    }

    if (requestParameters['internalSep'] != null) {
      queryParameters['internalSep'] = requestParameters['internalSep'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/records/csv`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * The CSV is a short summary of each records.
   * Get a set of metadata records as CSV
   */
  async exportAsCsv(
    requestParameters: ExportAsCsvRequest = {},
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<void> {
    await this.exportAsCsvRaw(requestParameters, initOverrides);
  }

  /**
   * Metadata Exchange Format (MEF) is returned. MEF is a ZIP file containing the metadata as XML and some others files depending on the version requested. See https://docs.geonetwork-opensource.org/latest/annexes/mef-format/.
   * Get a set of metadata records as ZIP
   */
  async exportAsMefRaw(
    requestParameters: ExportAsMefRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<void>> {
    const queryParameters: any = {};

    if (requestParameters['uuids'] != null) {
      queryParameters['uuids'] = requestParameters['uuids'];
    }

    if (requestParameters['bucket'] != null) {
      queryParameters['bucket'] = requestParameters['bucket'];
    }

    if (requestParameters['format'] != null) {
      queryParameters['format'] = requestParameters['format'];
    }

    if (requestParameters['withRelated'] != null) {
      queryParameters['withRelated'] = requestParameters['withRelated'];
    }

    if (requestParameters['withXLinksResolved'] != null) {
      queryParameters['withXLinksResolved'] =
        requestParameters['withXLinksResolved'];
    }

    if (requestParameters['withXLinkAttribute'] != null) {
      queryParameters['withXLinkAttribute'] =
        requestParameters['withXLinkAttribute'];
    }

    if (requestParameters['addSchemaLocation'] != null) {
      queryParameters['addSchemaLocation'] =
        requestParameters['addSchemaLocation'];
    }

    if (requestParameters['approved'] != null) {
      queryParameters['approved'] = requestParameters['approved'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/records/zip`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Metadata Exchange Format (MEF) is returned. MEF is a ZIP file containing the metadata as XML and some others files depending on the version requested. See https://docs.geonetwork-opensource.org/latest/annexes/mef-format/.
   * Get a set of metadata records as ZIP
   */
  async exportAsMef(
    requestParameters: ExportAsMefRequest = {},
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<void> {
    await this.exportAsMefRaw(requestParameters, initOverrides);
  }

  /**
   * The PDF is a short summary of each records with links to the complete metadata record in different format (ie. landing page on the portal, XML)
   * Get a set of metadata records as PDF
   */
  async exportAsPdfRaw(
    requestParameters: ExportAsPdfRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<void>> {
    const queryParameters: any = {};

    if (requestParameters['uuids'] != null) {
      queryParameters['uuids'] = requestParameters['uuids'];
    }

    if (requestParameters['bucket'] != null) {
      queryParameters['bucket'] = requestParameters['bucket'];
    }

    if (requestParameters['language'] != null) {
      queryParameters['language'] = requestParameters['language'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/records/pdf`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * The PDF is a short summary of each records with links to the complete metadata record in different format (ie. landing page on the portal, XML)
   * Get a set of metadata records as PDF
   */
  async exportAsPdf(
    requestParameters: ExportAsPdfRequest = {},
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<void> {
    await this.exportAsPdfRaw(requestParameters, initOverrides);
  }

  /**
   * Get the list of users \"active\" during a time period.
   */
  async getActiveUsersRaw(
    requestParameters: GetActiveUsersRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters['dateFrom'] == null) {
      throw new runtime.RequiredError(
        'dateFrom',
        'Required parameter "dateFrom" was null or undefined when calling getActiveUsers().'
      );
    }

    if (requestParameters['dateTo'] == null) {
      throw new runtime.RequiredError(
        'dateTo',
        'Required parameter "dateTo" was null or undefined when calling getActiveUsers().'
      );
    }

    const queryParameters: any = {};

    if (requestParameters['dateFrom'] != null) {
      queryParameters['dateFrom'] = requestParameters['dateFrom'];
    }

    if (requestParameters['dateTo'] != null) {
      queryParameters['dateTo'] = requestParameters['dateTo'];
    }

    if (requestParameters['groups'] != null) {
      queryParameters['groups'] = requestParameters['groups'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/reports/users`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Get the list of users \"active\" during a time period.
   */
  async getActiveUsers(
    requestParameters: GetActiveUsersRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<void> {
    await this.getActiveUsersRaw(requestParameters, initOverrides);
  }

  /**
   * A rendering of the geometry as a png. If no background is specified the image will be transparent. In getMap the envelope of the geometry is calculated then it is expanded by a factor.  That factor is the size of the map.  This allows the map to be slightly bigger than the geometry allowing some context to be shown. This parameter allows different factors to be chosen per scale level. Proportion is the proportion of the world that the geometry covers (bounds of WGS84)/(bounds of geometry in WGS84)  Named backgrounds allow the background parameter to be a simple key and the complete URL will be looked up from this list of named backgrounds
   * Get record extents as image
   */
  async getAllRecordExtentAsImageRaw(
    requestParameters: GetAllRecordExtentAsImageRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<Array<string>>> {
    if (requestParameters['metadataUuid'] == null) {
      throw new runtime.RequiredError(
        'metadataUuid',
        'Required parameter "metadataUuid" was null or undefined when calling getAllRecordExtentAsImage().'
      );
    }

    const queryParameters: any = {};

    if (requestParameters['mapsrs'] != null) {
      queryParameters['mapsrs'] = requestParameters['mapsrs'];
    }

    if (requestParameters['width'] != null) {
      queryParameters['width'] = requestParameters['width'];
    }

    if (requestParameters['height'] != null) {
      queryParameters['height'] = requestParameters['height'];
    }

    if (requestParameters['background'] != null) {
      queryParameters['background'] = requestParameters['background'];
    }

    if (requestParameters['fillColor'] != null) {
      queryParameters['fillColor'] = requestParameters['fillColor'];
    }

    if (requestParameters['strokeColor'] != null) {
      queryParameters['strokeColor'] = requestParameters['strokeColor'];
    }

    if (requestParameters['approved'] != null) {
      queryParameters['approved'] = requestParameters['approved'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/records/{metadataUuid}/extents.png`.replace(
          `{${'metadataUuid'}}`,
          encodeURIComponent(String(requestParameters['metadataUuid']))
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse<any>(response);
  }

  /**
   * A rendering of the geometry as a png. If no background is specified the image will be transparent. In getMap the envelope of the geometry is calculated then it is expanded by a factor.  That factor is the size of the map.  This allows the map to be slightly bigger than the geometry allowing some context to be shown. This parameter allows different factors to be chosen per scale level. Proportion is the proportion of the world that the geometry covers (bounds of WGS84)/(bounds of geometry in WGS84)  Named backgrounds allow the background parameter to be a simple key and the complete URL will be looked up from this list of named backgrounds
   * Get record extents as image
   */
  async getAllRecordExtentAsImage(
    requestParameters: GetAllRecordExtentAsImageRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<Array<string>> {
    const response = await this.getAllRecordExtentAsImageRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * A rendering of the geometry as a png. If no background is specified the image will be transparent. In getMap the envelope of the geometry is calculated then it is expanded by a factor.  That factor is the size of the map.  This allows the map to be slightly bigger than the geometry allowing some context to be shown. This parameter allows different factors to be chosen per scale level. Proportion is the proportion of the world that the geometry covers (bounds of WGS84)/(bounds of geometry in WGS84)  Named backgrounds allow the background parameter to be a simple key and the complete URL will be looked up from this list of named backgrounds
   * Get list of record extents
   */
  async getAllRecordExtentAsJsonRaw(
    requestParameters: GetAllRecordExtentAsJsonRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<Array<ExtentDto>>> {
    if (requestParameters['metadataUuid'] == null) {
      throw new runtime.RequiredError(
        'metadataUuid',
        'Required parameter "metadataUuid" was null or undefined when calling getAllRecordExtentAsJson().'
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/records/{metadataUuid}/extents.json`.replace(
          `{${'metadataUuid'}}`,
          encodeURIComponent(String(requestParameters['metadataUuid']))
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, jsonValue =>
      jsonValue.map(ExtentDtoFromJSON)
    );
  }

  /**
   * A rendering of the geometry as a png. If no background is specified the image will be transparent. In getMap the envelope of the geometry is calculated then it is expanded by a factor.  That factor is the size of the map.  This allows the map to be slightly bigger than the geometry allowing some context to be shown. This parameter allows different factors to be chosen per scale level. Proportion is the proportion of the world that the geometry covers (bounds of WGS84)/(bounds of geometry in WGS84)  Named backgrounds allow the background parameter to be a simple key and the complete URL will be looked up from this list of named backgrounds
   * Get list of record extents
   */
  async getAllRecordExtentAsJson(
    requestParameters: GetAllRecordExtentAsJsonRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<Array<ExtentDto>> {
    const response = await this.getAllRecordExtentAsJsonRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * <a href=\'https://docs.geonetwork-opensource.org/latest/user-guide/associating-resources/using-filestore/\'>More info</a>
   * List all metadata attachments
   */
  async getAllResourcesRaw(
    requestParameters: GetAllResourcesRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<Array<MetadataResource>>> {
    if (requestParameters['metadataUuid'] == null) {
      throw new runtime.RequiredError(
        'metadataUuid',
        'Required parameter "metadataUuid" was null or undefined when calling getAllResources().'
      );
    }

    const queryParameters: any = {};

    if (requestParameters['sort'] != null) {
      queryParameters['sort'] = requestParameters['sort'];
    }

    if (requestParameters['approved'] != null) {
      queryParameters['approved'] = requestParameters['approved'];
    }

    if (requestParameters['filter'] != null) {
      queryParameters['filter'] = requestParameters['filter'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/records/{metadataUuid}/attachments`.replace(
          `{${'metadataUuid'}}`,
          encodeURIComponent(String(requestParameters['metadataUuid']))
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, jsonValue =>
      jsonValue.map(MetadataResourceFromJSON)
    );
  }

  /**
   * <a href=\'https://docs.geonetwork-opensource.org/latest/user-guide/associating-resources/using-filestore/\'>More info</a>
   * List all metadata attachments
   */
  async getAllResources(
    requestParameters: GetAllResourcesRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<Array<MetadataResource>> {
    const response = await this.getAllResourcesRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * .
   * Get catalog content as RDF. This endpoint supports the same Lucene query parameters as for the GUI search.
   */
  async getAsRdfRaw(
    requestParameters: GetAsRdfRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<void>> {
    const queryParameters: any = {};

    if (requestParameters['from'] != null) {
      queryParameters['from'] = requestParameters['from'];
    }

    if (requestParameters['hitsPerPage'] != null) {
      queryParameters['hitsPerPage'] = requestParameters['hitsPerPage'];
    }

    if (requestParameters['any'] != null) {
      queryParameters['any'] = requestParameters['any'];
    }

    if (requestParameters['title'] != null) {
      queryParameters['title'] = requestParameters['title'];
    }

    if (requestParameters['facetQ'] != null) {
      queryParameters['facet.q'] = requestParameters['facetQ'];
    }

    if (requestParameters['sortBy'] != null) {
      queryParameters['sortBy'] = requestParameters['sortBy'];
    }

    if (requestParameters['sortOrder'] != null) {
      queryParameters['sortOrder'] = requestParameters['sortOrder'];
    }

    if (requestParameters['similarity'] != null) {
      queryParameters['similarity'] = requestParameters['similarity'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/records`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * .
   * Get catalog content as RDF. This endpoint supports the same Lucene query parameters as for the GUI search.
   */
  async getAsRdf(
    requestParameters: GetAsRdfRequest = {},
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<void> {
    await this.getAsRdfRaw(requestParameters, initOverrides);
  }

  /**
   * Retrieve related services, datasets, sources, ... to this records.<br/><a href=\'https://docs.geonetwork-opensource.org/latest/user-guide/associating-resources/\'>More info</a>
   * Get record associated resources
   */
  async getAssociatedResourcesRaw(
    requestParameters: GetAssociatedResourcesRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<{ [key: string]: Array<AssociatedRecord> }>> {
    if (requestParameters['metadataUuid'] == null) {
      throw new runtime.RequiredError(
        'metadataUuid',
        'Required parameter "metadataUuid" was null or undefined when calling getAssociatedResources().'
      );
    }

    const queryParameters: any = {};

    if (requestParameters['type'] != null) {
      queryParameters['type'] = requestParameters['type'];
    }

    if (requestParameters['approved'] != null) {
      queryParameters['approved'] = requestParameters['approved'];
    }

    if (requestParameters['start'] != null) {
      queryParameters['start'] = requestParameters['start'];
    }

    if (requestParameters['rows'] != null) {
      queryParameters['rows'] = requestParameters['rows'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/records/{metadataUuid}/associated`.replace(
          `{${'metadataUuid'}}`,
          encodeURIComponent(String(requestParameters['metadataUuid']))
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse<any>(response);
  }

  /**
   * Retrieve related services, datasets, sources, ... to this records.<br/><a href=\'https://docs.geonetwork-opensource.org/latest/user-guide/associating-resources/\'>More info</a>
   * Get record associated resources
   */
  async getAssociatedResources(
    requestParameters: GetAssociatedResourcesRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<{ [key: string]: Array<AssociatedRecord> }> {
    const response = await this.getAssociatedResourcesRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Returns a map to decode attributes in a dataset (from the associated feature catalog)
   */
  async getFeatureCatalogRaw(
    requestParameters: GetFeatureCatalogRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<FeatureResponse>> {
    if (requestParameters['metadataUuid'] == null) {
      throw new runtime.RequiredError(
        'metadataUuid',
        'Required parameter "metadataUuid" was null or undefined when calling getFeatureCatalog().'
      );
    }

    const queryParameters: any = {};

    if (requestParameters['approved'] != null) {
      queryParameters['approved'] = requestParameters['approved'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/records/{metadataUuid}/featureCatalog`.replace(
          `{${'metadataUuid'}}`,
          encodeURIComponent(String(requestParameters['metadataUuid']))
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, jsonValue =>
      FeatureResponseFromJSON(jsonValue)
    );
  }

  /**
   * Returns a map to decode attributes in a dataset (from the associated feature catalog)
   */
  async getFeatureCatalog(
    requestParameters: GetFeatureCatalogRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<FeatureResponse> {
    const response = await this.getFeatureCatalogRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * A rendering of the geometry as a png. If no background is specified the image will be transparent. In getMap the envelope of the geometry is calculated then it is expanded by a factor.  That factor is the size of the map.  This allows the map to be slightly bigger than the geometry allowing some context to be shown. This parameter allows different factors to be chosen per scale level. Proportion is the proportion of the world that the geometry covers (bounds of WGS84)/(bounds of geometry in WGS84)  Named backgrounds allow the background parameter to be a simple key and the complete URL will be looked up from this list of named backgrounds
   * Get one record extent as image
   */
  async getOneRecordExtentAsImageRaw(
    requestParameters: GetOneRecordExtentAsImageRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<Array<string>>> {
    if (requestParameters['metadataUuid'] == null) {
      throw new runtime.RequiredError(
        'metadataUuid',
        'Required parameter "metadataUuid" was null or undefined when calling getOneRecordExtentAsImage().'
      );
    }

    if (requestParameters['geometryIndex'] == null) {
      throw new runtime.RequiredError(
        'geometryIndex',
        'Required parameter "geometryIndex" was null or undefined when calling getOneRecordExtentAsImage().'
      );
    }

    const queryParameters: any = {};

    if (requestParameters['mapsrs'] != null) {
      queryParameters['mapsrs'] = requestParameters['mapsrs'];
    }

    if (requestParameters['width'] != null) {
      queryParameters['width'] = requestParameters['width'];
    }

    if (requestParameters['height'] != null) {
      queryParameters['height'] = requestParameters['height'];
    }

    if (requestParameters['background'] != null) {
      queryParameters['background'] = requestParameters['background'];
    }

    if (requestParameters['fillColor'] != null) {
      queryParameters['fillColor'] = requestParameters['fillColor'];
    }

    if (requestParameters['strokeColor'] != null) {
      queryParameters['strokeColor'] = requestParameters['strokeColor'];
    }

    if (requestParameters['approved'] != null) {
      queryParameters['approved'] = requestParameters['approved'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/records/{metadataUuid}/extents/{geometryIndex}.png`
          .replace(
            `{${'metadataUuid'}}`,
            encodeURIComponent(String(requestParameters['metadataUuid']))
          )
          .replace(
            `{${'geometryIndex'}}`,
            encodeURIComponent(String(requestParameters['geometryIndex']))
          ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse<any>(response);
  }

  /**
   * A rendering of the geometry as a png. If no background is specified the image will be transparent. In getMap the envelope of the geometry is calculated then it is expanded by a factor.  That factor is the size of the map.  This allows the map to be slightly bigger than the geometry allowing some context to be shown. This parameter allows different factors to be chosen per scale level. Proportion is the proportion of the world that the geometry covers (bounds of WGS84)/(bounds of geometry in WGS84)  Named backgrounds allow the background parameter to be a simple key and the complete URL will be looked up from this list of named backgrounds
   * Get one record extent as image
   */
  async getOneRecordExtentAsImage(
    requestParameters: GetOneRecordExtentAsImageRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<Array<string>> {
    const response = await this.getOneRecordExtentAsImageRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Get publication options.
   */
  async getPublicationOptionsRaw(
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<Array<PublicationOption>>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/records/sharing/options`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, jsonValue =>
      jsonValue.map(PublicationOptionFromJSON)
    );
  }

  /**
   * Get publication options.
   */
  async getPublicationOptions(
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<Array<PublicationOption>> {
    const response = await this.getPublicationOptionsRaw(initOverrides);
    return await response.value();
  }

  /**
   * Accept header should indicate which is the appropriate format to return. It could be text/html, application/xml, application/zip, ...If no appropriate Accept header found, the XML format is returned.Depending on the accept header the appropriate formatter is used. When requesting a ZIP, a MEF version 2 file is returned. When requesting HTML, the default formatter is used.
   * Get a metadata record
   */
  async getRecordRaw(
    requestParameters: GetRecordRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<Blob>> {
    if (requestParameters['metadataUuid'] == null) {
      throw new runtime.RequiredError(
        'metadataUuid',
        'Required parameter "metadataUuid" was null or undefined when calling getRecord().'
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/records/{metadataUuid}`.replace(
          `{${'metadataUuid'}}`,
          encodeURIComponent(String(requestParameters['metadataUuid']))
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.BlobApiResponse(response);
  }

  /**
   * Accept header should indicate which is the appropriate format to return. It could be text/html, application/xml, application/zip, ...If no appropriate Accept header found, the XML format is returned.Depending on the accept header the appropriate formatter is used. When requesting a ZIP, a MEF version 2 file is returned. When requesting HTML, the default formatter is used.
   * Get a metadata record
   */
  async getRecord(
    requestParameters: GetRecordRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<Blob> {
    const response = await this.getRecordRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Get a metadata record as JSON
   */
  async getRecordAsJsonRaw(
    requestParameters: GetRecordAsJsonRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<Blob>> {
    if (requestParameters['metadataUuid'] == null) {
      throw new runtime.RequiredError(
        'metadataUuid',
        'Required parameter "metadataUuid" was null or undefined when calling getRecordAsJson().'
      );
    }

    const queryParameters: any = {};

    if (requestParameters['addSchemaLocation'] != null) {
      queryParameters['addSchemaLocation'] =
        requestParameters['addSchemaLocation'];
    }

    if (requestParameters['increasePopularity'] != null) {
      queryParameters['increasePopularity'] =
        requestParameters['increasePopularity'];
    }

    if (requestParameters['withInfo'] != null) {
      queryParameters['withInfo'] = requestParameters['withInfo'];
    }

    if (requestParameters['attachment'] != null) {
      queryParameters['attachment'] = requestParameters['attachment'];
    }

    if (requestParameters['approved'] != null) {
      queryParameters['approved'] = requestParameters['approved'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/records/{metadataUuid}/formatters/json`.replace(
          `{${'metadataUuid'}}`,
          encodeURIComponent(String(requestParameters['metadataUuid']))
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.BlobApiResponse(response);
  }

  /**
   * Get a metadata record as JSON
   */
  async getRecordAsJson(
    requestParameters: GetRecordAsJsonRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<Blob> {
    const response = await this.getRecordAsJsonRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Get a metadata record as XML
   */
  async getRecordAsXmlRaw(
    requestParameters: GetRecordAsXmlRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<Blob>> {
    if (requestParameters['metadataUuid'] == null) {
      throw new runtime.RequiredError(
        'metadataUuid',
        'Required parameter "metadataUuid" was null or undefined when calling getRecordAsXml().'
      );
    }

    const queryParameters: any = {};

    if (requestParameters['addSchemaLocation'] != null) {
      queryParameters['addSchemaLocation'] =
        requestParameters['addSchemaLocation'];
    }

    if (requestParameters['increasePopularity'] != null) {
      queryParameters['increasePopularity'] =
        requestParameters['increasePopularity'];
    }

    if (requestParameters['withInfo'] != null) {
      queryParameters['withInfo'] = requestParameters['withInfo'];
    }

    if (requestParameters['attachment'] != null) {
      queryParameters['attachment'] = requestParameters['attachment'];
    }

    if (requestParameters['approved'] != null) {
      queryParameters['approved'] = requestParameters['approved'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/records/{metadataUuid}/formatters/xml`.replace(
          `{${'metadataUuid'}}`,
          encodeURIComponent(String(requestParameters['metadataUuid']))
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.BlobApiResponse(response);
  }

  /**
   * Get a metadata record as XML
   */
  async getRecordAsXml(
    requestParameters: GetRecordAsXmlRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<Blob> {
    const response = await this.getRecordAsXmlRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Metadata Exchange Format (MEF) is returned. MEF is a ZIP file containing the metadata as XML and some others files depending on the version requested. See https://docs.geonetwork-opensource.org/latest/annexes/mef-format/.
   * Get a metadata record as ZIP
   */
  async getRecordAsZipRaw(
    requestParameters: GetRecordAsZipRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters['metadataUuid'] == null) {
      throw new runtime.RequiredError(
        'metadataUuid',
        'Required parameter "metadataUuid" was null or undefined when calling getRecordAsZip().'
      );
    }

    const queryParameters: any = {};

    if (requestParameters['format'] != null) {
      queryParameters['format'] = requestParameters['format'];
    }

    if (requestParameters['withRelated'] != null) {
      queryParameters['withRelated'] = requestParameters['withRelated'];
    }

    if (requestParameters['withXLinksResolved'] != null) {
      queryParameters['withXLinksResolved'] =
        requestParameters['withXLinksResolved'];
    }

    if (requestParameters['withXLinkAttribute'] != null) {
      queryParameters['withXLinkAttribute'] =
        requestParameters['withXLinkAttribute'];
    }

    if (requestParameters['addSchemaLocation'] != null) {
      queryParameters['addSchemaLocation'] =
        requestParameters['addSchemaLocation'];
    }

    if (requestParameters['approved'] != null) {
      queryParameters['approved'] = requestParameters['approved'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/records/{metadataUuid}/formatters/zip`.replace(
          `{${'metadataUuid'}}`,
          encodeURIComponent(String(requestParameters['metadataUuid']))
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Metadata Exchange Format (MEF) is returned. MEF is a ZIP file containing the metadata as XML and some others files depending on the version requested. See https://docs.geonetwork-opensource.org/latest/annexes/mef-format/.
   * Get a metadata record as ZIP
   */
  async getRecordAsZip(
    requestParameters: GetRecordAsZipRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<void> {
    await this.getRecordAsZipRaw(requestParameters, initOverrides);
  }

  /**
   * Get a formatted metadata record
   */
  async getRecordFormattedByRaw(
    requestParameters: GetRecordFormattedByRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters['formatterId'] == null) {
      throw new runtime.RequiredError(
        'formatterId',
        'Required parameter "formatterId" was null or undefined when calling getRecordFormattedBy().'
      );
    }

    if (requestParameters['metadataUuid'] == null) {
      throw new runtime.RequiredError(
        'metadataUuid',
        'Required parameter "metadataUuid" was null or undefined when calling getRecordFormattedBy().'
      );
    }

    const queryParameters: any = {};

    if (requestParameters['width'] != null) {
      queryParameters['width'] = requestParameters['width'];
    }

    if (requestParameters['mdpath'] != null) {
      queryParameters['mdpath'] = requestParameters['mdpath'];
    }

    if (requestParameters['language'] != null) {
      queryParameters['language'] = requestParameters['language'];
    }

    if (requestParameters['output'] != null) {
      queryParameters['output'] = requestParameters['output'];
    }

    if (requestParameters['approved'] != null) {
      queryParameters['approved'] = requestParameters['approved'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/records/{metadataUuid}/formatters/{formatterId}`
          .replace(
            `{${'formatterId'}}`,
            encodeURIComponent(String(requestParameters['formatterId']))
          )
          .replace(
            `{${'metadataUuid'}}`,
            encodeURIComponent(String(requestParameters['metadataUuid']))
          ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Get a formatted metadata record
   */
  async getRecordFormattedBy(
    requestParameters: GetRecordFormattedByRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<void> {
    await this.getRecordFormattedByRaw(requestParameters, initOverrides);
  }

  /**
   * Permalink is by default the landing page formatter but can be configured in the admin console > settings. If the record as a DOI and if enabled in the settings, then it takes priority.
   * Get metadata record permalink
   */
  async getRecordPermalinkRaw(
    requestParameters: GetRecordPermalinkRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters['metadataUuid'] == null) {
      throw new runtime.RequiredError(
        'metadataUuid',
        'Required parameter "metadataUuid" was null or undefined when calling getRecordPermalink().'
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/records/{metadataUuid}/permalink`.replace(
          `{${'metadataUuid'}}`,
          encodeURIComponent(String(requestParameters['metadataUuid']))
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    if (this.isJsonMime(response.headers.get('content-type'))) {
      return new runtime.JSONApiResponse<string>(response);
    } else {
      return new runtime.TextApiResponse(response) as any;
    }
  }

  /**
   * Permalink is by default the landing page formatter but can be configured in the admin console > settings. If the record as a DOI and if enabled in the settings, then it takes priority.
   * Get metadata record permalink
   */
  async getRecordPermalink(
    requestParameters: GetRecordPermalinkRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<string> {
    const response = await this.getRecordPermalinkRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Get record popularity
   */
  async getRecordPopularityRaw(
    requestParameters: GetRecordPopularityRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters['metadataUuid'] == null) {
      throw new runtime.RequiredError(
        'metadataUuid',
        'Required parameter "metadataUuid" was null or undefined when calling getRecordPopularity().'
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/records/{metadataUuid}/popularity`.replace(
          `{${'metadataUuid'}}`,
          encodeURIComponent(String(requestParameters['metadataUuid']))
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    if (this.isJsonMime(response.headers.get('content-type'))) {
      return new runtime.JSONApiResponse<string>(response);
    } else {
      return new runtime.TextApiResponse(response) as any;
    }
  }

  /**
   * Get record popularity
   */
  async getRecordPopularity(
    requestParameters: GetRecordPopularityRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<string> {
    const response = await this.getRecordPopularityRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Return current sharing options for a record.
   * Get record sharing settings
   */
  async getRecordSharingSettingsRaw(
    requestParameters: GetRecordSharingSettingsRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<SharingResponse>> {
    if (requestParameters['metadataUuid'] == null) {
      throw new runtime.RequiredError(
        'metadataUuid',
        'Required parameter "metadataUuid" was null or undefined when calling getRecordSharingSettings().'
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/records/{metadataUuid}/sharing`.replace(
          `{${'metadataUuid'}}`,
          encodeURIComponent(String(requestParameters['metadataUuid']))
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, jsonValue =>
      SharingResponseFromJSON(jsonValue)
    );
  }

  /**
   * Return current sharing options for a record.
   * Get record sharing settings
   */
  async getRecordSharingSettings(
    requestParameters: GetRecordSharingSettingsRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<SharingResponse> {
    const response = await this.getRecordSharingSettingsRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Get record status history
   */
  async getRecordStatusHistoryRaw(
    requestParameters: GetRecordStatusHistoryRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<Array<MetadataStatusResponse>>> {
    if (requestParameters['metadataUuid'] == null) {
      throw new runtime.RequiredError(
        'metadataUuid',
        'Required parameter "metadataUuid" was null or undefined when calling getRecordStatusHistory().'
      );
    }

    const queryParameters: any = {};

    if (requestParameters['details'] != null) {
      queryParameters['details'] = requestParameters['details'];
    }

    if (requestParameters['sortOrder'] != null) {
      queryParameters['sortOrder'] = requestParameters['sortOrder'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/records/{metadataUuid}/status`.replace(
          `{${'metadataUuid'}}`,
          encodeURIComponent(String(requestParameters['metadataUuid']))
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, jsonValue =>
      jsonValue.map(MetadataStatusResponseFromJSON)
    );
  }

  /**
   * Get record status history
   */
  async getRecordStatusHistory(
    requestParameters: GetRecordStatusHistoryRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<Array<MetadataStatusResponse>> {
    const response = await this.getRecordStatusHistoryRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Get record status history by type
   */
  async getRecordStatusHistoryByTypeRaw(
    requestParameters: GetRecordStatusHistoryByTypeRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<Array<MetadataStatusResponse>>> {
    if (requestParameters['metadataUuid'] == null) {
      throw new runtime.RequiredError(
        'metadataUuid',
        'Required parameter "metadataUuid" was null or undefined when calling getRecordStatusHistoryByType().'
      );
    }

    if (requestParameters['type'] == null) {
      throw new runtime.RequiredError(
        'type',
        'Required parameter "type" was null or undefined when calling getRecordStatusHistoryByType().'
      );
    }

    const queryParameters: any = {};

    if (requestParameters['details'] != null) {
      queryParameters['details'] = requestParameters['details'];
    }

    if (requestParameters['sortOrder'] != null) {
      queryParameters['sortOrder'] = requestParameters['sortOrder'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/records/{metadataUuid}/status/{type}`
          .replace(
            `{${'metadataUuid'}}`,
            encodeURIComponent(String(requestParameters['metadataUuid']))
          )
          .replace(
            `{${'type'}}`,
            encodeURIComponent(String(requestParameters['type']))
          ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, jsonValue =>
      jsonValue.map(MetadataStatusResponseFromJSON)
    );
  }

  /**
   * Get record status history by type
   */
  async getRecordStatusHistoryByType(
    requestParameters: GetRecordStatusHistoryByTypeRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<Array<MetadataStatusResponse>> {
    const response = await this.getRecordStatusHistoryByTypeRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Tags are used to classify information.<br/><a href=\'https://docs.geonetwork-opensource.org/latest/user-guide/tag-information/tagging-with-categories/\'>More info</a>
   * Get record tags
   */
  async getRecordTagsRaw(
    requestParameters: GetRecordTagsRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<Set<MetadataCategory>>> {
    if (requestParameters['metadataUuid'] == null) {
      throw new runtime.RequiredError(
        'metadataUuid',
        'Required parameter "metadataUuid" was null or undefined when calling getRecordTags().'
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/records/{metadataUuid}/tags`.replace(
          `{${'metadataUuid'}}`,
          encodeURIComponent(String(requestParameters['metadataUuid']))
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(
      response,
      jsonValue => new Set(jsonValue.map(MetadataCategoryFromJSON))
    );
  }

  /**
   * Tags are used to classify information.<br/><a href=\'https://docs.geonetwork-opensource.org/latest/user-guide/tag-information/tagging-with-categories/\'>More info</a>
   * Get record tags
   */
  async getRecordTags(
    requestParameters: GetRecordTagsRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<Set<MetadataCategory>> {
    const response = await this.getRecordTagsRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Retrieve related services, datasets, onlines, thumbnails, sources, ... to this records.<br/><a href=\'https://geonetwork-opensource.org/manuals/trunk/eng/users/user-guide/associating-resources/index.html\'>More info</a>
   * Get record related resources
   */
  async getRelatedResourcesRaw(
    requestParameters: GetRelatedResourcesRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<RelatedResponse>> {
    if (requestParameters['metadataUuid'] == null) {
      throw new runtime.RequiredError(
        'metadataUuid',
        'Required parameter "metadataUuid" was null or undefined when calling getRelatedResources().'
      );
    }

    const queryParameters: any = {};

    if (requestParameters['type'] != null) {
      queryParameters['type'] = requestParameters['type'];
    }

    if (requestParameters['approved'] != null) {
      queryParameters['approved'] = requestParameters['approved'];
    }

    if (requestParameters['start'] != null) {
      queryParameters['start'] = requestParameters['start'];
    }

    if (requestParameters['rows'] != null) {
      queryParameters['rows'] = requestParameters['rows'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/records/{metadataUuid}/related`.replace(
          `{${'metadataUuid'}}`,
          encodeURIComponent(String(requestParameters['metadataUuid']))
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, jsonValue =>
      RelatedResponseFromJSON(jsonValue)
    );
  }

  /**
   * Retrieve related services, datasets, onlines, thumbnails, sources, ... to this records.<br/><a href=\'https://geonetwork-opensource.org/manuals/trunk/eng/users/user-guide/associating-resources/index.html\'>More info</a>
   * Get record related resources
   */
  async getRelatedResources(
    requestParameters: GetRelatedResourcesRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<RelatedResponse> {
    const response = await this.getRelatedResourcesRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Get list of metadata file downloads
   */
  async getReportDataDownloadsRaw(
    requestParameters: GetReportDataDownloadsRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters['dateFrom'] == null) {
      throw new runtime.RequiredError(
        'dateFrom',
        'Required parameter "dateFrom" was null or undefined when calling getReportDataDownloads().'
      );
    }

    if (requestParameters['dateTo'] == null) {
      throw new runtime.RequiredError(
        'dateTo',
        'Required parameter "dateTo" was null or undefined when calling getReportDataDownloads().'
      );
    }

    const queryParameters: any = {};

    if (requestParameters['dateFrom'] != null) {
      queryParameters['dateFrom'] = requestParameters['dateFrom'];
    }

    if (requestParameters['dateTo'] != null) {
      queryParameters['dateTo'] = requestParameters['dateTo'];
    }

    if (requestParameters['groups'] != null) {
      queryParameters['groups'] = requestParameters['groups'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/reports/datadownloads`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Get list of metadata file downloads
   */
  async getReportDataDownloads(
    requestParameters: GetReportDataDownloadsRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<void> {
    await this.getReportDataDownloadsRaw(requestParameters, initOverrides);
  }

  /**
   * Get uploaded files to metadata records during a period.
   */
  async getReportDataUploadsRaw(
    requestParameters: GetReportDataUploadsRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters['dateFrom'] == null) {
      throw new runtime.RequiredError(
        'dateFrom',
        'Required parameter "dateFrom" was null or undefined when calling getReportDataUploads().'
      );
    }

    if (requestParameters['dateTo'] == null) {
      throw new runtime.RequiredError(
        'dateTo',
        'Required parameter "dateTo" was null or undefined when calling getReportDataUploads().'
      );
    }

    const queryParameters: any = {};

    if (requestParameters['dateFrom'] != null) {
      queryParameters['dateFrom'] = requestParameters['dateFrom'];
    }

    if (requestParameters['dateTo'] != null) {
      queryParameters['dateTo'] = requestParameters['dateTo'];
    }

    if (requestParameters['groups'] != null) {
      queryParameters['groups'] = requestParameters['groups'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/reports/datauploads`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Get uploaded files to metadata records during a period.
   */
  async getReportDataUploads(
    requestParameters: GetReportDataUploadsRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<void> {
    await this.getReportDataUploadsRaw(requestParameters, initOverrides);
  }

  /**
   * Get the metadata not published during a period.
   */
  async getReportInternalMetadataRaw(
    requestParameters: GetReportInternalMetadataRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters['dateFrom'] == null) {
      throw new runtime.RequiredError(
        'dateFrom',
        'Required parameter "dateFrom" was null or undefined when calling getReportInternalMetadata().'
      );
    }

    if (requestParameters['dateTo'] == null) {
      throw new runtime.RequiredError(
        'dateTo',
        'Required parameter "dateTo" was null or undefined when calling getReportInternalMetadata().'
      );
    }

    const queryParameters: any = {};

    if (requestParameters['dateFrom'] != null) {
      queryParameters['dateFrom'] = requestParameters['dateFrom'];
    }

    if (requestParameters['dateTo'] != null) {
      queryParameters['dateTo'] = requestParameters['dateTo'];
    }

    if (requestParameters['groups'] != null) {
      queryParameters['groups'] = requestParameters['groups'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/reports/metadatainternal`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Get the metadata not published during a period.
   */
  async getReportInternalMetadata(
    requestParameters: GetReportInternalMetadataRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<void> {
    await this.getReportInternalMetadataRaw(requestParameters, initOverrides);
  }

  /**
   * Get the updated metadata during a period.
   */
  async getReportUpdatedMetadataRaw(
    requestParameters: GetReportUpdatedMetadataRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters['dateFrom'] == null) {
      throw new runtime.RequiredError(
        'dateFrom',
        'Required parameter "dateFrom" was null or undefined when calling getReportUpdatedMetadata().'
      );
    }

    if (requestParameters['dateTo'] == null) {
      throw new runtime.RequiredError(
        'dateTo',
        'Required parameter "dateTo" was null or undefined when calling getReportUpdatedMetadata().'
      );
    }

    const queryParameters: any = {};

    if (requestParameters['dateFrom'] != null) {
      queryParameters['dateFrom'] = requestParameters['dateFrom'];
    }

    if (requestParameters['dateTo'] != null) {
      queryParameters['dateTo'] = requestParameters['dateTo'];
    }

    if (requestParameters['groups'] != null) {
      queryParameters['groups'] = requestParameters['groups'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/reports/metadataupdated`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Get the updated metadata during a period.
   */
  async getReportUpdatedMetadata(
    requestParameters: GetReportUpdatedMetadataRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<void> {
    await this.getReportUpdatedMetadataRaw(requestParameters, initOverrides);
  }

  /**
   * Get a metadata resource
   */
  async getResourceRaw(
    requestParameters: GetResourceRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<Blob>> {
    if (requestParameters['metadataUuid'] == null) {
      throw new runtime.RequiredError(
        'metadataUuid',
        'Required parameter "metadataUuid" was null or undefined when calling getResource().'
      );
    }

    if (requestParameters['resourceId'] == null) {
      throw new runtime.RequiredError(
        'resourceId',
        'Required parameter "resourceId" was null or undefined when calling getResource().'
      );
    }

    const queryParameters: any = {};

    if (requestParameters['approved'] != null) {
      queryParameters['approved'] = requestParameters['approved'];
    }

    if (requestParameters['size'] != null) {
      queryParameters['size'] = requestParameters['size'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/records/{metadataUuid}/attachments/{resourceId}`
          .replace(
            `{${'metadataUuid'}}`,
            encodeURIComponent(String(requestParameters['metadataUuid']))
          )
          .replace(
            `{${'resourceId'}}`,
            encodeURIComponent(String(requestParameters['resourceId']))
          ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.BlobApiResponse(response);
  }

  /**
   * Get a metadata resource
   */
  async getResource(
    requestParameters: GetResourceRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<Blob> {
    const response = await this.getResourceRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * List saved queries for this metadata
   */
  async getSavedQueriesRaw(
    requestParameters: GetSavedQueriesRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<Array<SavedQuery>>> {
    if (requestParameters['metadataUuid'] == null) {
      throw new runtime.RequiredError(
        'metadataUuid',
        'Required parameter "metadataUuid" was null or undefined when calling getSavedQueries().'
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/records/{metadataUuid}/query`.replace(
          `{${'metadataUuid'}}`,
          encodeURIComponent(String(requestParameters['metadataUuid']))
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, jsonValue =>
      jsonValue.map(SavedQueryFromJSON)
    );
  }

  /**
   * List saved queries for this metadata
   */
  async getSavedQueries(
    requestParameters: GetSavedQueriesRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<Array<SavedQuery>> {
    const response = await this.getSavedQueriesRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Get record sharing settings
   */
  async getSharingSettingsRaw(
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<SharingResponse>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/records/sharing`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, jsonValue =>
      SharingResponseFromJSON(jsonValue)
    );
  }

  /**
   * Get record sharing settings
   */
  async getSharingSettings(
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<SharingResponse> {
    const response = await this.getSharingSettingsRaw(initOverrides);
    return await response.value();
  }

  /**
   * Get last workflow status for a record
   */
  async getStatusRaw(
    requestParameters: GetStatusRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<MetadataWorkflowStatusResponse>> {
    if (requestParameters['metadataUuid'] == null) {
      throw new runtime.RequiredError(
        'metadataUuid',
        'Required parameter "metadataUuid" was null or undefined when calling getStatus().'
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/records/{metadataUuid}/status/workflow/last`.replace(
          `{${'metadataUuid'}}`,
          encodeURIComponent(String(requestParameters['metadataUuid']))
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, jsonValue =>
      MetadataWorkflowStatusResponseFromJSON(jsonValue)
    );
  }

  /**
   * Get last workflow status for a record
   */
  async getStatus(
    requestParameters: GetStatusRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<MetadataWorkflowStatusResponse> {
    const response = await this.getStatusRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Analyze the record an suggest processes to improve the quality of the record.<br/><a href=\'https://docs.geonetwork-opensource.org/latest/user-guide/workflow/batchupdate-xsl/\'>More info</a>
   * Get suggestions
   */
  async getSuggestionsRaw(
    requestParameters: GetSuggestionsRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<Array<SuggestionType>>> {
    if (requestParameters['metadataUuid'] == null) {
      throw new runtime.RequiredError(
        'metadataUuid',
        'Required parameter "metadataUuid" was null or undefined when calling getSuggestions().'
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/records/{metadataUuid}/processes`.replace(
          `{${'metadataUuid'}}`,
          encodeURIComponent(String(requestParameters['metadataUuid']))
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, jsonValue =>
      jsonValue.map(SuggestionTypeFromJSON)
    );
  }

  /**
   * Analyze the record an suggest processes to improve the quality of the record.<br/><a href=\'https://docs.geonetwork-opensource.org/latest/user-guide/workflow/batchupdate-xsl/\'>More info</a>
   * Get suggestions
   */
  async getSuggestions(
    requestParameters: GetSuggestionsRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<Array<SuggestionType>> {
    const response = await this.getSuggestionsRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * TG13, TG2, ...
   * Get test suites available.
   */
  async getTestSuitesRaw(
    requestParameters: GetTestSuitesRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<{ [key: string]: Array<string> }>> {
    if (requestParameters['metadataUuid'] == null) {
      throw new runtime.RequiredError(
        'metadataUuid',
        'Required parameter "metadataUuid" was null or undefined when calling getTestSuites().'
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/records/{metadataUuid}/validate/inspire/testsuites`.replace(
          `{${'metadataUuid'}}`,
          encodeURIComponent(String(requestParameters['metadataUuid']))
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse<any>(response);
  }

  /**
   * TG13, TG2, ...
   * Get test suites available.
   */
  async getTestSuites(
    requestParameters: GetTestSuitesRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<{ [key: string]: Array<string> }> {
    const response = await this.getTestSuitesRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Search status
   */
  async getWorkflowStatusByTypeRaw(
    requestParameters: GetWorkflowStatusByTypeRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<Array<MetadataStatusResponse>>> {
    const queryParameters: any = {};

    if (requestParameters['type'] != null) {
      queryParameters['type'] = requestParameters['type'];
    }

    if (requestParameters['details'] != null) {
      queryParameters['details'] = requestParameters['details'];
    }

    if (requestParameters['sortOrder'] != null) {
      queryParameters['sortOrder'] = requestParameters['sortOrder'];
    }

    if (requestParameters['author'] != null) {
      queryParameters['author'] = requestParameters['author'];
    }

    if (requestParameters['owner'] != null) {
      queryParameters['owner'] = requestParameters['owner'];
    }

    if (requestParameters['id'] != null) {
      queryParameters['id'] = requestParameters['id'];
    }

    if (requestParameters['recordIdentifier'] != null) {
      queryParameters['recordIdentifier'] =
        requestParameters['recordIdentifier'];
    }

    if (requestParameters['uuid'] != null) {
      queryParameters['uuid'] = requestParameters['uuid'];
    }

    if (requestParameters['statusIds'] != null) {
      queryParameters['statusIds'] = requestParameters['statusIds'];
    }

    if (requestParameters['dateFrom'] != null) {
      queryParameters['dateFrom'] = requestParameters['dateFrom'];
    }

    if (requestParameters['dateTo'] != null) {
      queryParameters['dateTo'] = requestParameters['dateTo'];
    }

    if (requestParameters['from'] != null) {
      queryParameters['from'] = requestParameters['from'];
    }

    if (requestParameters['size'] != null) {
      queryParameters['size'] = requestParameters['size'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/records/status/search`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, jsonValue =>
      jsonValue.map(MetadataStatusResponseFromJSON)
    );
  }

  /**
   * Search status
   */
  async getWorkflowStatusByType(
    requestParameters: GetWorkflowStatusByTypeRequest = {},
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<Array<MetadataStatusResponse>> {
    const response = await this.getWorkflowStatusByTypeRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Used when a view is based on the search results content and does not really access the record. Record is then added to the indexing queue and popularity will be updated soon.
   * Increase record popularity
   */
  async increaseRecordPopularityRaw(
    requestParameters: IncreaseRecordPopularityRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters['metadataUuid'] == null) {
      throw new runtime.RequiredError(
        'metadataUuid',
        'Required parameter "metadataUuid" was null or undefined when calling increaseRecordPopularity().'
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/records/{metadataUuid}/popularity`.replace(
          `{${'metadataUuid'}}`,
          encodeURIComponent(String(requestParameters['metadataUuid']))
        ),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    if (this.isJsonMime(response.headers.get('content-type'))) {
      return new runtime.JSONApiResponse<string>(response);
    } else {
      return new runtime.TextApiResponse(response) as any;
    }
  }

  /**
   * Used when a view is based on the search results content and does not really access the record. Record is then added to the indexing queue and popularity will be updated soon.
   * Increase record popularity
   */
  async increaseRecordPopularity(
    requestParameters: IncreaseRecordPopularityRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<string> {
    const response = await this.increaseRecordPopularityRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Index a set of records provided either by a bucket or a list of uuids
   * Index a set of records
   */
  async indexRaw(
    requestParameters: IndexRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<IndexResponse>> {
    const queryParameters: any = {};

    if (requestParameters['uuids'] != null) {
      queryParameters['uuids'] = requestParameters['uuids'];
    }

    if (requestParameters['bucket'] != null) {
      queryParameters['bucket'] = requestParameters['bucket'];
    }

    const headerParameters: runtime.HTTPHeaders = {};
    // FIXME: Check OpenAPI spec.
    headerParameters['Accept'] = 'application/json';

    const response = await this.request(
      {
        path: `/records/index`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, jsonValue =>
      IndexResponseFromJSON(jsonValue)
    );
  }

  /**
   * Index a set of records provided either by a bucket or a list of uuids
   * Index a set of records
   */
  async index(
    requestParameters: IndexRequest = {},
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<IndexResponse> {
    const response = await this.indexRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Add one or more record from an XML fragment, URL or file in a folder on the catalog server. When loadingfrom the catalog server folder, it might be faster to use a local filesystem harvester.
   * Add a record
   */
  async insertRaw(
    requestParameters: InsertRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<SimpleMetadataProcessingReport>> {
    const queryParameters: any = {};

    if (requestParameters['metadataType'] != null) {
      queryParameters['metadataType'] = requestParameters['metadataType'];
    }

    if (requestParameters['url'] != null) {
      queryParameters['url'] = requestParameters['url'];
    }

    if (requestParameters['serverFolder'] != null) {
      queryParameters['serverFolder'] = requestParameters['serverFolder'];
    }

    if (requestParameters['recursiveSearch'] != null) {
      queryParameters['recursiveSearch'] = requestParameters['recursiveSearch'];
    }

    if (requestParameters['publishToAll'] != null) {
      queryParameters['publishToAll'] = requestParameters['publishToAll'];
    }

    if (requestParameters['assignToCatalog'] != null) {
      queryParameters['assignToCatalog'] = requestParameters['assignToCatalog'];
    }

    if (requestParameters['uuidProcessing'] != null) {
      queryParameters['uuidProcessing'] = requestParameters['uuidProcessing'];
    }

    if (requestParameters['group'] != null) {
      queryParameters['group'] = requestParameters['group'];
    }

    if (requestParameters['category'] != null) {
      queryParameters['category'] = requestParameters['category'];
    }

    if (requestParameters['rejectIfInvalid'] != null) {
      queryParameters['rejectIfInvalid'] = requestParameters['rejectIfInvalid'];
    }

    if (requestParameters['transformWith'] != null) {
      queryParameters['transformWith'] = requestParameters['transformWith'];
    }

    if (requestParameters['schema'] != null) {
      queryParameters['schema'] = requestParameters['schema'];
    }

    if (requestParameters['allowEditGroupMembers'] != null) {
      queryParameters['allowEditGroupMembers'] =
        requestParameters['allowEditGroupMembers'];
    }

    if (requestParameters['extra'] != null) {
      queryParameters['extra'] = requestParameters['extra'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/xml';

    const response = await this.request(
      {
        path: `/records`,
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: requestParameters['body'] as any,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, jsonValue =>
      SimpleMetadataProcessingReportFromJSON(jsonValue)
    );
  }

  /**
   * Add one or more record from an XML fragment, URL or file in a folder on the catalog server. When loadingfrom the catalog server folder, it might be faster to use a local filesystem harvester.
   * Add a record
   */
  async insert(
    requestParameters: InsertRequest = {},
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<SimpleMetadataProcessingReport> {
    const response = await this.insertRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Add record in the catalog by uploading files.
   * Add a record from XML or MEF/ZIP file
   */
  async insertFileRaw(
    requestParameters: InsertFileRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<SimpleMetadataProcessingReport>> {
    const queryParameters: any = {};

    if (requestParameters['metadataType'] != null) {
      queryParameters['metadataType'] = requestParameters['metadataType'];
    }

    if (requestParameters['file'] != null) {
      queryParameters['file'] = requestParameters['file'];
    }

    if (requestParameters['uuidProcessing'] != null) {
      queryParameters['uuidProcessing'] = requestParameters['uuidProcessing'];
    }

    if (requestParameters['group'] != null) {
      queryParameters['group'] = requestParameters['group'];
    }

    if (requestParameters['category'] != null) {
      queryParameters['category'] = requestParameters['category'];
    }

    if (requestParameters['rejectIfInvalid'] != null) {
      queryParameters['rejectIfInvalid'] = requestParameters['rejectIfInvalid'];
    }

    if (requestParameters['publishToAll'] != null) {
      queryParameters['publishToAll'] = requestParameters['publishToAll'];
    }

    if (requestParameters['assignToCatalog'] != null) {
      queryParameters['assignToCatalog'] = requestParameters['assignToCatalog'];
    }

    if (requestParameters['transformWith'] != null) {
      queryParameters['transformWith'] = requestParameters['transformWith'];
    }

    if (requestParameters['schema'] != null) {
      queryParameters['schema'] = requestParameters['schema'];
    }

    if (requestParameters['extra'] != null) {
      queryParameters['extra'] = requestParameters['extra'];
    }

    if (requestParameters['allowEditGroupMembers'] != null) {
      queryParameters['allowEditGroupMembers'] =
        requestParameters['allowEditGroupMembers'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/records`,
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, jsonValue =>
      SimpleMetadataProcessingReportFromJSON(jsonValue)
    );
  }

  /**
   * Add record in the catalog by uploading files.
   * Add a record from XML or MEF/ZIP file
   */
  async insertFile(
    requestParameters: InsertFileRequest = {},
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<SimpleMetadataProcessingReport> {
    const response = await this.insertFileRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Add record in the catalog by uploading a map context.
   * Add a map metadata record from OGC OWS context
   */
  async insertOgcMapContextFileRaw(
    requestParameters: InsertOgcMapContextFileRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<SimpleMetadataProcessingReport>> {
    if (requestParameters['title'] == null) {
      throw new runtime.RequiredError(
        'title',
        'Required parameter "title" was null or undefined when calling insertOgcMapContextFile().'
      );
    }

    const queryParameters: any = {};

    if (requestParameters['title'] != null) {
      queryParameters['title'] = requestParameters['title'];
    }

    if (requestParameters['recordAbstract'] != null) {
      queryParameters['recordAbstract'] = requestParameters['recordAbstract'];
    }

    if (requestParameters['xml'] != null) {
      queryParameters['xml'] = requestParameters['xml'];
    }

    if (requestParameters['filename'] != null) {
      queryParameters['filename'] = requestParameters['filename'];
    }

    if (requestParameters['url'] != null) {
      queryParameters['url'] = requestParameters['url'];
    }

    if (requestParameters['viewerUrl'] != null) {
      queryParameters['viewerUrl'] = requestParameters['viewerUrl'];
    }

    if (requestParameters['overview'] != null) {
      queryParameters['overview'] = requestParameters['overview'];
    }

    if (requestParameters['overviewFilename'] != null) {
      queryParameters['overviewFilename'] =
        requestParameters['overviewFilename'];
    }

    if (requestParameters['topic'] != null) {
      queryParameters['topic'] = requestParameters['topic'];
    }

    if (requestParameters['publishToAll'] != null) {
      queryParameters['publishToAll'] = requestParameters['publishToAll'];
    }

    if (requestParameters['uuidProcessing'] != null) {
      queryParameters['uuidProcessing'] = requestParameters['uuidProcessing'];
    }

    if (requestParameters['group'] != null) {
      queryParameters['group'] = requestParameters['group'];
    }

    if (requestParameters['schema'] != null) {
      queryParameters['schema'] = requestParameters['schema'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/records/importfrommap`,
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, jsonValue =>
      SimpleMetadataProcessingReportFromJSON(jsonValue)
    );
  }

  /**
   * Add record in the catalog by uploading a map context.
   * Add a map metadata record from OGC OWS context
   */
  async insertOgcMapContextFile(
    requestParameters: InsertOgcMapContextFileRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<SimpleMetadataProcessingReport> {
    const response = await this.insertOgcMapContextFileRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Update the metadata resource visibility
   */
  async patchResourceRaw(
    requestParameters: PatchResourceRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<MetadataResource>> {
    if (requestParameters['metadataUuid'] == null) {
      throw new runtime.RequiredError(
        'metadataUuid',
        'Required parameter "metadataUuid" was null or undefined when calling patchResource().'
      );
    }

    if (requestParameters['resourceId'] == null) {
      throw new runtime.RequiredError(
        'resourceId',
        'Required parameter "resourceId" was null or undefined when calling patchResource().'
      );
    }

    if (requestParameters['visibility'] == null) {
      throw new runtime.RequiredError(
        'visibility',
        'Required parameter "visibility" was null or undefined when calling patchResource().'
      );
    }

    const queryParameters: any = {};

    if (requestParameters['visibility'] != null) {
      queryParameters['visibility'] = requestParameters['visibility'];
    }

    if (requestParameters['approved'] != null) {
      queryParameters['approved'] = requestParameters['approved'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/records/{metadataUuid}/attachments/{resourceId}`
          .replace(
            `{${'metadataUuid'}}`,
            encodeURIComponent(String(requestParameters['metadataUuid']))
          )
          .replace(
            `{${'resourceId'}}`,
            encodeURIComponent(String(requestParameters['resourceId']))
          ),
        method: 'PATCH',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, jsonValue =>
      MetadataResourceFromJSON(jsonValue)
    );
  }

  /**
   * Update the metadata resource visibility
   */
  async patchResource(
    requestParameters: PatchResourceRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<MetadataResource> {
    const response = await this.patchResourceRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Preview edits made by XPath expressions.
   */
  async previewBatchEditRaw(
    requestParameters: PreviewBatchEditRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<object>> {
    if (requestParameters['batchEditParameter'] == null) {
      throw new runtime.RequiredError(
        'batchEditParameter',
        'Required parameter "batchEditParameter" was null or undefined when calling previewBatchEdit().'
      );
    }

    const queryParameters: any = {};

    if (requestParameters['uuids'] != null) {
      queryParameters['uuids'] = requestParameters['uuids'];
    }

    if (requestParameters['bucket'] != null) {
      queryParameters['bucket'] = requestParameters['bucket'];
    }

    if (requestParameters['diffType'] != null) {
      queryParameters['diffType'] = requestParameters['diffType'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/records/batchediting/preview`,
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: requestParameters['batchEditParameter']!.map(
          BatchEditParameterToJSON
        ),
      },
      initOverrides
    );

    return new runtime.JSONApiResponse<any>(response);
  }

  /**
   * Preview edits made by XPath expressions.
   */
  async previewBatchEdit(
    requestParameters: PreviewBatchEditRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<object> {
    const response = await this.previewBatchEditRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Process a metadata with an XSL transformation declared in the metadata schema (See the process folder). Parameters sent to the service are forwarded to XSL process.
   * Apply a process
   */
  async processRecordRaw(
    requestParameters: ProcessRecordRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters['metadataUuid'] == null) {
      throw new runtime.RequiredError(
        'metadataUuid',
        'Required parameter "metadataUuid" was null or undefined when calling processRecord().'
      );
    }

    if (requestParameters['process'] == null) {
      throw new runtime.RequiredError(
        'process',
        'Required parameter "process" was null or undefined when calling processRecord().'
      );
    }

    // FIXME: Check if the issue is related to openapi gen or GN4 spec
    const queryParameters: any = requestParameters['processParams'] || {};

    // const queryParameters: any = {};
    // if (requestParameters['processParams'] != null) {
    //   queryParameters['processParams'] = requestParameters['processParams'];
    // }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/records/{metadataUuid}/processes/{process}`
          .replace(
            `{${'metadataUuid'}}`,
            encodeURIComponent(String(requestParameters['metadataUuid']))
          )
          .replace(
            `{${'process'}}`,
            encodeURIComponent(String(requestParameters['process']))
          ),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    if (this.isJsonMime(response.headers.get('content-type'))) {
      return new runtime.JSONApiResponse<string>(response);
    } else {
      return new runtime.TextApiResponse(response) as any;
    }
  }

  /**
   * Process a metadata with an XSL transformation declared in the metadata schema (See the process folder). Parameters sent to the service are forwarded to XSL process.
   * Apply a process
   */
  async processRecord(
    requestParameters: ProcessRecordRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<string> {
    const response = await this.processRecordRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Process a metadata with an XSL transformation declared in the metadata schema (See the process folder). Parameters sent to the service are forwarded to XSL process.
   * Preview process result
   */
  async processRecordPreviewRaw(
    requestParameters: ProcessRecordPreviewRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters['metadataUuid'] == null) {
      throw new runtime.RequiredError(
        'metadataUuid',
        'Required parameter "metadataUuid" was null or undefined when calling processRecordPreview().'
      );
    }

    if (requestParameters['process'] == null) {
      throw new runtime.RequiredError(
        'process',
        'Required parameter "process" was null or undefined when calling processRecordPreview().'
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/records/{metadataUuid}/processes/{process}`
          .replace(
            `{${'metadataUuid'}}`,
            encodeURIComponent(String(requestParameters['metadataUuid']))
          )
          .replace(
            `{${'process'}}`,
            encodeURIComponent(String(requestParameters['process']))
          ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Process a metadata with an XSL transformation declared in the metadata schema (See the process folder). Parameters sent to the service are forwarded to XSL process.
   * Preview process result
   */
  async processRecordPreview(
    requestParameters: ProcessRecordPreviewRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<void> {
    await this.processRecordPreviewRaw(requestParameters, initOverrides);
  }

  /**
   * Set privileges for ALL group to publish the metadata for all users.
   */
  async publishRaw(
    requestParameters: PublishRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters['metadataUuid'] == null) {
      throw new runtime.RequiredError(
        'metadataUuid',
        'Required parameter "metadataUuid" was null or undefined when calling publish().'
      );
    }

    if (requestParameters['publicationType'] == null) {
      throw new runtime.RequiredError(
        'publicationType',
        'Required parameter "publicationType" was null or undefined when calling publish().'
      );
    }

    const queryParameters: any = {};

    if (requestParameters['publicationType'] != null) {
      queryParameters['publicationType'] = requestParameters['publicationType'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/records/{metadataUuid}/publish`.replace(
          `{${'metadataUuid'}}`,
          encodeURIComponent(String(requestParameters['metadataUuid']))
        ),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Set privileges for ALL group to publish the metadata for all users.
   */
  async publish(
    requestParameters: PublishRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<void> {
    await this.publishRaw(requestParameters, initOverrides);
  }

  /**
   * See record sharing for more details.
   * Publish one or more records
   */
  async publishMultipleRecordsRaw(
    requestParameters: PublishMultipleRecordsRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<MetadataProcessingReport>> {
    if (requestParameters['publicationType'] == null) {
      throw new runtime.RequiredError(
        'publicationType',
        'Required parameter "publicationType" was null or undefined when calling publishMultipleRecords().'
      );
    }

    const queryParameters: any = {};

    if (requestParameters['uuids'] != null) {
      queryParameters['uuids'] = requestParameters['uuids'];
    }

    if (requestParameters['bucket'] != null) {
      queryParameters['bucket'] = requestParameters['bucket'];
    }

    if (requestParameters['publicationType'] != null) {
      queryParameters['publicationType'] = requestParameters['publicationType'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/records/publish`,
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, jsonValue =>
      MetadataProcessingReportFromJSON(jsonValue)
    );
  }

  /**
   * See record sharing for more details.
   * Publish one or more records
   */
  async publishMultipleRecords(
    requestParameters: PublishMultipleRecordsRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<MetadataProcessingReport> {
    const response = await this.publishMultipleRecordsRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Create a new resource for a given metadata
   */
  async putResourceRaw(
    requestParameters: PutResourceRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<MetadataResource>> {
    if (requestParameters['metadataUuid'] == null) {
      throw new runtime.RequiredError(
        'metadataUuid',
        'Required parameter "metadataUuid" was null or undefined when calling putResource().'
      );
    }

    if (requestParameters['file'] == null) {
      throw new runtime.RequiredError(
        'file',
        'Required parameter "file" was null or undefined when calling putResource().'
      );
    }

    const queryParameters: any = {};

    if (requestParameters['visibility'] != null) {
      queryParameters['visibility'] = requestParameters['visibility'];
    }

    if (requestParameters['approved'] != null) {
      queryParameters['approved'] = requestParameters['approved'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const consumes: runtime.Consume[] = [
      { contentType: 'multipart/form-data' },
    ];
    // @ts-ignore: canConsumeForm may be unused
    const canConsumeForm = runtime.canConsumeForm(consumes);

    let formParams: { append(param: string, value: any): any };
    let useForm = false;
    // use FormData to transmit files using content-type "multipart/form-data"
    useForm = canConsumeForm;
    if (useForm) {
      formParams = new FormData();
    } else {
      formParams = new URLSearchParams();
    }

    if (requestParameters['file'] != null) {
      formParams.append('file', requestParameters['file'] as any);
    }

    const response = await this.request(
      {
        path: `/records/{metadataUuid}/attachments`.replace(
          `{${'metadataUuid'}}`,
          encodeURIComponent(String(requestParameters['metadataUuid']))
        ),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: formParams,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, jsonValue =>
      MetadataResourceFromJSON(jsonValue)
    );
  }

  /**
   * Create a new resource for a given metadata
   */
  async putResource(
    requestParameters: PutResourceRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<MetadataResource> {
    const response = await this.putResourceRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Create a new resource from a URL for a given metadata
   */
  async putResourceFromURLRaw(
    requestParameters: PutResourceFromURLRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<MetadataResource>> {
    if (requestParameters['metadataUuid'] == null) {
      throw new runtime.RequiredError(
        'metadataUuid',
        'Required parameter "metadataUuid" was null or undefined when calling putResourceFromURL().'
      );
    }

    if (requestParameters['url'] == null) {
      throw new runtime.RequiredError(
        'url',
        'Required parameter "url" was null or undefined when calling putResourceFromURL().'
      );
    }

    const queryParameters: any = {};

    if (requestParameters['visibility'] != null) {
      queryParameters['visibility'] = requestParameters['visibility'];
    }

    if (requestParameters['url'] != null) {
      queryParameters['url'] = requestParameters['url'];
    }

    if (requestParameters['approved'] != null) {
      queryParameters['approved'] = requestParameters['approved'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/records/{metadataUuid}/attachments`.replace(
          `{${'metadataUuid'}}`,
          encodeURIComponent(String(requestParameters['metadataUuid']))
        ),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, jsonValue =>
      MetadataResourceFromJSON(jsonValue)
    );
  }

  /**
   * Create a new resource from a URL for a given metadata
   */
  async putResourceFromURL(
    requestParameters: PutResourceFromURLRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<MetadataResource> {
    const response = await this.putResourceFromURLRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * User rating of metadata. If the metadata was harvested using the \'GeoNetwork\' protocol and the system setting localrating/enable is false (the default), the user\'s rating is shared between GN nodes in this harvesting network. If the metadata was not harvested or if localrating/enable is true then \'local rating\' is applied, counting only rating from users of this node.<br/>When a remote rating is applied, the local rating is not updated. It will be updated on the next harvest run (FIXME ?).
   * Rate a record
   */
  async rateRecordRaw(
    requestParameters: RateRecordRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<number>> {
    if (requestParameters['metadataUuid'] == null) {
      throw new runtime.RequiredError(
        'metadataUuid',
        'Required parameter "metadataUuid" was null or undefined when calling rateRecord().'
      );
    }

    if (requestParameters['body'] == null) {
      throw new runtime.RequiredError(
        'body',
        'Required parameter "body" was null or undefined when calling rateRecord().'
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/records/{metadataUuid}/rate`.replace(
          `{${'metadataUuid'}}`,
          encodeURIComponent(String(requestParameters['metadataUuid']))
        ),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: requestParameters['body'] as any,
      },
      initOverrides
    );

    if (this.isJsonMime(response.headers.get('content-type'))) {
      return new runtime.JSONApiResponse<number>(response);
    } else {
      return new runtime.TextApiResponse(response) as any;
    }
  }

  /**
   * User rating of metadata. If the metadata was harvested using the \'GeoNetwork\' protocol and the system setting localrating/enable is false (the default), the user\'s rating is shared between GN nodes in this harvesting network. If the metadata was not harvested or if localrating/enable is true then \'local rating\' is applied, counting only rating from users of this node.<br/>When a remote rating is applied, the local rating is not updated. It will be updated on the next harvest run (FIXME ?).
   * Rate a record
   */
  async rateRecord(
    requestParameters: RateRecordRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<number> {
    const response = await this.rateRecordRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Reorder element
   */
  async reorderElementRaw(
    requestParameters: ReorderElementRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters['metadataUuid'] == null) {
      throw new runtime.RequiredError(
        'metadataUuid',
        'Required parameter "metadataUuid" was null or undefined when calling reorderElement().'
      );
    }

    if (requestParameters['ref'] == null) {
      throw new runtime.RequiredError(
        'ref',
        'Required parameter "ref" was null or undefined when calling reorderElement().'
      );
    }

    if (requestParameters['direction'] == null) {
      throw new runtime.RequiredError(
        'direction',
        'Required parameter "direction" was null or undefined when calling reorderElement().'
      );
    }

    const queryParameters: any = {};

    if (requestParameters['ref'] != null) {
      queryParameters['ref'] = requestParameters['ref'];
    }

    if (requestParameters['displayAttributes'] != null) {
      queryParameters['displayAttributes'] =
        requestParameters['displayAttributes'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/records/{metadataUuid}/editor/elements/{direction}`
          .replace(
            `{${'metadataUuid'}}`,
            encodeURIComponent(String(requestParameters['metadataUuid']))
          )
          .replace(
            `{${'direction'}}`,
            encodeURIComponent(String(requestParameters['direction']))
          ),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Reorder element
   */
  async reorderElement(
    requestParameters: ReorderElementRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<void> {
    await this.reorderElementRaw(requestParameters, initOverrides);
  }

  /**
   * Restore saved content from a status record
   */
  async restoreAtStatusSaveRaw(
    requestParameters: RestoreAtStatusSaveRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters['metadataUuid'] == null) {
      throw new runtime.RequiredError(
        'metadataUuid',
        'Required parameter "metadataUuid" was null or undefined when calling restoreAtStatusSave().'
      );
    }

    if (requestParameters['statusId'] == null) {
      throw new runtime.RequiredError(
        'statusId',
        'Required parameter "statusId" was null or undefined when calling restoreAtStatusSave().'
      );
    }

    if (requestParameters['userId'] == null) {
      throw new runtime.RequiredError(
        'userId',
        'Required parameter "userId" was null or undefined when calling restoreAtStatusSave().'
      );
    }

    if (requestParameters['changeDate'] == null) {
      throw new runtime.RequiredError(
        'changeDate',
        'Required parameter "changeDate" was null or undefined when calling restoreAtStatusSave().'
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/records/{metadataUuid}/status/{statusId}.{userId}.{changeDate}/restore`
          .replace(
            `{${'metadataUuid'}}`,
            encodeURIComponent(String(requestParameters['metadataUuid']))
          )
          .replace(
            `{${'statusId'}}`,
            encodeURIComponent(String(requestParameters['statusId']))
          )
          .replace(
            `{${'userId'}}`,
            encodeURIComponent(String(requestParameters['userId']))
          )
          .replace(
            `{${'changeDate'}}`,
            encodeURIComponent(String(requestParameters['changeDate']))
          ),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Restore saved content from a status record
   */
  async restoreAtStatusSave(
    requestParameters: RestoreAtStatusSaveRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<void> {
    await this.restoreAtStatusSaveRaw(requestParameters, initOverrides);
  }

  /**
   * Save the HTML form content.
   * Save edits
   */
  async saveEditsRaw(
    requestParameters: SaveEditsRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters['metadataUuid'] == null) {
      throw new runtime.RequiredError(
        'metadataUuid',
        'Required parameter "metadataUuid" was null or undefined when calling saveEdits().'
      );
    }

    const queryParameters: any = {};

    if (requestParameters['tab'] != null) {
      queryParameters['tab'] = requestParameters['tab'];
    }

    if (requestParameters['withAttributes'] != null) {
      queryParameters['withAttributes'] = requestParameters['withAttributes'];
    }

    if (requestParameters['withValidationErrors'] != null) {
      queryParameters['withValidationErrors'] =
        requestParameters['withValidationErrors'];
    }

    if (requestParameters['minor'] != null) {
      queryParameters['minor'] = requestParameters['minor'];
    }

    if (requestParameters['status'] != null) {
      queryParameters['status'] = requestParameters['status'];
    }

    if (requestParameters['commit'] != null) {
      queryParameters['commit'] = requestParameters['commit'];
    }

    if (requestParameters['terminate'] != null) {
      queryParameters['terminate'] = requestParameters['terminate'];
    }

    if (requestParameters['data'] != null) {
      queryParameters['data'] = requestParameters['data'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/records/{metadataUuid}/editor`.replace(
          `{${'metadataUuid'}}`,
          encodeURIComponent(String(requestParameters['metadataUuid']))
        ),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Save the HTML form content.
   * Save edits
   */
  async saveEdits(
    requestParameters: SaveEditsRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<void> {
    await this.saveEditsRaw(requestParameters, initOverrides);
  }

  /**
   * <a href=\'https://docs.geonetwork-opensource.org/latest/user-guide/associating-resources/linking-thumbnail/#linking-thumbnail-from-wms\'>More info</a>
   * Create an overview using the map print module
   */
  async saveThumbnailRaw(
    requestParameters: SaveThumbnailRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<MetadataResource>> {
    if (requestParameters['metadataUuid'] == null) {
      throw new runtime.RequiredError(
        'metadataUuid',
        'Required parameter "metadataUuid" was null or undefined when calling saveThumbnail().'
      );
    }

    if (requestParameters['jsonConfig'] == null) {
      throw new runtime.RequiredError(
        'jsonConfig',
        'Required parameter "jsonConfig" was null or undefined when calling saveThumbnail().'
      );
    }

    const queryParameters: any = {};

    if (requestParameters['jsonConfig'] != null) {
      queryParameters['jsonConfig'] = requestParameters['jsonConfig'];
    }

    if (requestParameters['rotationAngle'] != null) {
      queryParameters['rotationAngle'] = requestParameters['rotationAngle'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/records/{metadataUuid}/attachments/print-thumbnail`.replace(
          `{${'metadataUuid'}}`,
          encodeURIComponent(String(requestParameters['metadataUuid']))
        ),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, jsonValue =>
      MetadataResourceFromJSON(jsonValue)
    );
  }

  /**
   * <a href=\'https://docs.geonetwork-opensource.org/latest/user-guide/associating-resources/linking-thumbnail/#linking-thumbnail-from-wms\'>More info</a>
   * Create an overview using the map print module
   */
  async saveThumbnail(
    requestParameters: SaveThumbnailRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<MetadataResource> {
    const response = await this.saveThumbnailRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Set group and owner for one or more records
   */
  async setGroupAndOwnerRaw(
    requestParameters: SetGroupAndOwnerRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<MetadataProcessingReport>> {
    if (requestParameters['groupIdentifier'] == null) {
      throw new runtime.RequiredError(
        'groupIdentifier',
        'Required parameter "groupIdentifier" was null or undefined when calling setGroupAndOwner().'
      );
    }

    if (requestParameters['userIdentifier'] == null) {
      throw new runtime.RequiredError(
        'userIdentifier',
        'Required parameter "userIdentifier" was null or undefined when calling setGroupAndOwner().'
      );
    }

    const queryParameters: any = {};

    if (requestParameters['uuids'] != null) {
      queryParameters['uuids'] = requestParameters['uuids'];
    }

    if (requestParameters['groupIdentifier'] != null) {
      queryParameters['groupIdentifier'] = requestParameters['groupIdentifier'];
    }

    if (requestParameters['bucket'] != null) {
      queryParameters['bucket'] = requestParameters['bucket'];
    }

    if (requestParameters['userIdentifier'] != null) {
      queryParameters['userIdentifier'] = requestParameters['userIdentifier'];
    }

    if (requestParameters['approved'] != null) {
      queryParameters['approved'] = requestParameters['approved'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/records/ownership`,
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, jsonValue =>
      MetadataProcessingReportFromJSON(jsonValue)
    );
  }

  /**
   * Set group and owner for one or more records
   */
  async setGroupAndOwner(
    requestParameters: SetGroupAndOwnerRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<MetadataProcessingReport> {
    const response = await this.setGroupAndOwnerRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * A record is related to one group.
   * Set record group
   */
  async setRecordGroupRaw(
    requestParameters: SetRecordGroupRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters['metadataUuid'] == null) {
      throw new runtime.RequiredError(
        'metadataUuid',
        'Required parameter "metadataUuid" was null or undefined when calling setRecordGroup().'
      );
    }

    if (requestParameters['body'] == null) {
      throw new runtime.RequiredError(
        'body',
        'Required parameter "body" was null or undefined when calling setRecordGroup().'
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/records/{metadataUuid}/group`.replace(
          `{${'metadataUuid'}}`,
          encodeURIComponent(String(requestParameters['metadataUuid']))
        ),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: requestParameters['body'] as any,
      },
      initOverrides
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * A record is related to one group.
   * Set record group
   */
  async setRecordGroup(
    requestParameters: SetRecordGroupRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<void> {
    await this.setRecordGroupRaw(requestParameters, initOverrides);
  }

  /**
   * Set record group and owner
   */
  async setRecordOwnershipRaw(
    requestParameters: SetRecordOwnershipRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<MetadataProcessingReport>> {
    if (requestParameters['metadataUuid'] == null) {
      throw new runtime.RequiredError(
        'metadataUuid',
        'Required parameter "metadataUuid" was null or undefined when calling setRecordOwnership().'
      );
    }

    if (requestParameters['groupIdentifier'] == null) {
      throw new runtime.RequiredError(
        'groupIdentifier',
        'Required parameter "groupIdentifier" was null or undefined when calling setRecordOwnership().'
      );
    }

    if (requestParameters['userIdentifier'] == null) {
      throw new runtime.RequiredError(
        'userIdentifier',
        'Required parameter "userIdentifier" was null or undefined when calling setRecordOwnership().'
      );
    }

    const queryParameters: any = {};

    if (requestParameters['groupIdentifier'] != null) {
      queryParameters['groupIdentifier'] = requestParameters['groupIdentifier'];
    }

    if (requestParameters['userIdentifier'] != null) {
      queryParameters['userIdentifier'] = requestParameters['userIdentifier'];
    }

    if (requestParameters['approved'] != null) {
      queryParameters['approved'] = requestParameters['approved'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/records/{metadataUuid}/ownership`.replace(
          `{${'metadataUuid'}}`,
          encodeURIComponent(String(requestParameters['metadataUuid']))
        ),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, jsonValue =>
      MetadataProcessingReportFromJSON(jsonValue)
    );
  }

  /**
   * Set record group and owner
   */
  async setRecordOwnership(
    requestParameters: SetRecordOwnershipRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<MetadataProcessingReport> {
    const response = await this.setRecordOwnershipRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Set the record status
   */
  async setStatusRaw(
    requestParameters: SetStatusRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<{ [key: string]: string }>> {
    if (requestParameters['metadataUuid'] == null) {
      throw new runtime.RequiredError(
        'metadataUuid',
        'Required parameter "metadataUuid" was null or undefined when calling setStatus().'
      );
    }

    if (requestParameters['metadataStatusParameter'] == null) {
      throw new runtime.RequiredError(
        'metadataStatusParameter',
        'Required parameter "metadataStatusParameter" was null or undefined when calling setStatus().'
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/records/{metadataUuid}/status`.replace(
          `{${'metadataUuid'}}`,
          encodeURIComponent(String(requestParameters['metadataUuid']))
        ),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: MetadataStatusParameterToJSON(
          requestParameters['metadataStatusParameter']
        ),
      },
      initOverrides
    );

    return new runtime.JSONApiResponse<any>(response);
  }

  /**
   * Set the record status
   */
  async setStatus(
    requestParameters: SetStatusRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<{ [key: string]: string }> {
    const response = await this.setStatusRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Privileges are assigned by group. User needs to be able to edit a record to set sharing settings. For reserved group (ie. Internet, Intranet & Guest), user MUST be reviewer of one group. For other group, if Only set privileges to user\'s groups is set in catalog configuration user MUST be a member of the group.<br/>Clear first allows to unset all operations first before setting the new ones.Clear option does not remove reserved groups operation if user is not an administrator, a reviewer or the owner of the record.<br/><a href=\'https://geonetwork-opensource.org/manuals/trunk/eng/users/user-guide/publishing/managing-privileges.html\'>More info</a>
   * Set record sharing
   */
  async shareRaw(
    requestParameters: ShareRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters['metadataUuid'] == null) {
      throw new runtime.RequiredError(
        'metadataUuid',
        'Required parameter "metadataUuid" was null or undefined when calling share().'
      );
    }

    if (requestParameters['sharingParameter'] == null) {
      throw new runtime.RequiredError(
        'sharingParameter',
        'Required parameter "sharingParameter" was null or undefined when calling share().'
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/records/{metadataUuid}/sharing`.replace(
          `{${'metadataUuid'}}`,
          encodeURIComponent(String(requestParameters['metadataUuid']))
        ),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: SharingParameterToJSON(requestParameters['sharingParameter']),
      },
      initOverrides
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Privileges are assigned by group. User needs to be able to edit a record to set sharing settings. For reserved group (ie. Internet, Intranet & Guest), user MUST be reviewer of one group. For other group, if Only set privileges to user\'s groups is set in catalog configuration user MUST be a member of the group.<br/>Clear first allows to unset all operations first before setting the new ones.Clear option does not remove reserved groups operation if user is not an administrator, a reviewer or the owner of the record.<br/><a href=\'https://geonetwork-opensource.org/manuals/trunk/eng/users/user-guide/publishing/managing-privileges.html\'>More info</a>
   * Set record sharing
   */
  async share(
    requestParameters: ShareRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<void> {
    await this.shareRaw(requestParameters, initOverrides);
  }

  /**
   * See record sharing for more details.
   * Set sharing settings for one or more records
   */
  async shareMultipleRecordsRaw(
    requestParameters: ShareMultipleRecordsRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<MetadataProcessingReport>> {
    if (requestParameters['sharingParameter'] == null) {
      throw new runtime.RequiredError(
        'sharingParameter',
        'Required parameter "sharingParameter" was null or undefined when calling shareMultipleRecords().'
      );
    }

    const queryParameters: any = {};

    if (requestParameters['uuids'] != null) {
      queryParameters['uuids'] = requestParameters['uuids'];
    }

    if (requestParameters['bucket'] != null) {
      queryParameters['bucket'] = requestParameters['bucket'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/records/sharing`,
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: SharingParameterToJSON(requestParameters['sharingParameter']),
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, jsonValue =>
      MetadataProcessingReportFromJSON(jsonValue)
    );
  }

  /**
   * See record sharing for more details.
   * Set sharing settings for one or more records
   */
  async shareMultipleRecords(
    requestParameters: ShareMultipleRecordsRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<MetadataProcessingReport> {
    const response = await this.shareMultipleRecordsRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Get saved content from the status record after changes
   */
  async showStatusAfterRaw(
    requestParameters: ShowStatusAfterRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters['metadataUuid'] == null) {
      throw new runtime.RequiredError(
        'metadataUuid',
        'Required parameter "metadataUuid" was null or undefined when calling showStatusAfter().'
      );
    }

    if (requestParameters['statusId'] == null) {
      throw new runtime.RequiredError(
        'statusId',
        'Required parameter "statusId" was null or undefined when calling showStatusAfter().'
      );
    }

    if (requestParameters['userId'] == null) {
      throw new runtime.RequiredError(
        'userId',
        'Required parameter "userId" was null or undefined when calling showStatusAfter().'
      );
    }

    if (requestParameters['changeDate'] == null) {
      throw new runtime.RequiredError(
        'changeDate',
        'Required parameter "changeDate" was null or undefined when calling showStatusAfter().'
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/records/{metadataUuid}/status/{statusId}.{userId}.{changeDate}/after`
          .replace(
            `{${'metadataUuid'}}`,
            encodeURIComponent(String(requestParameters['metadataUuid']))
          )
          .replace(
            `{${'statusId'}}`,
            encodeURIComponent(String(requestParameters['statusId']))
          )
          .replace(
            `{${'userId'}}`,
            encodeURIComponent(String(requestParameters['userId']))
          )
          .replace(
            `{${'changeDate'}}`,
            encodeURIComponent(String(requestParameters['changeDate']))
          ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    if (this.isJsonMime(response.headers.get('content-type'))) {
      return new runtime.JSONApiResponse<string>(response);
    } else {
      return new runtime.TextApiResponse(response) as any;
    }
  }

  /**
   * Get saved content from the status record after changes
   */
  async showStatusAfter(
    requestParameters: ShowStatusAfterRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<string> {
    const response = await this.showStatusAfterRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Get saved content from the status record before changes
   */
  async showStatusBeforeRaw(
    requestParameters: ShowStatusBeforeRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters['metadataUuid'] == null) {
      throw new runtime.RequiredError(
        'metadataUuid',
        'Required parameter "metadataUuid" was null or undefined when calling showStatusBefore().'
      );
    }

    if (requestParameters['statusId'] == null) {
      throw new runtime.RequiredError(
        'statusId',
        'Required parameter "statusId" was null or undefined when calling showStatusBefore().'
      );
    }

    if (requestParameters['userId'] == null) {
      throw new runtime.RequiredError(
        'userId',
        'Required parameter "userId" was null or undefined when calling showStatusBefore().'
      );
    }

    if (requestParameters['changeDate'] == null) {
      throw new runtime.RequiredError(
        'changeDate',
        'Required parameter "changeDate" was null or undefined when calling showStatusBefore().'
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/records/{metadataUuid}/status/{statusId}.{userId}.{changeDate}/before`
          .replace(
            `{${'metadataUuid'}}`,
            encodeURIComponent(String(requestParameters['metadataUuid']))
          )
          .replace(
            `{${'statusId'}}`,
            encodeURIComponent(String(requestParameters['statusId']))
          )
          .replace(
            `{${'userId'}}`,
            encodeURIComponent(String(requestParameters['userId']))
          )
          .replace(
            `{${'changeDate'}}`,
            encodeURIComponent(String(requestParameters['changeDate']))
          ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    if (this.isJsonMime(response.headers.get('content-type'))) {
      return new runtime.JSONApiResponse<string>(response);
    } else {
      return new runtime.TextApiResponse(response) as any;
    }
  }

  /**
   * Get saved content from the status record before changes
   */
  async showStatusBefore(
    requestParameters: ShowStatusBeforeRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<string> {
    const response = await this.showStatusBeforeRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Return HTML form for editing.
   * Edit a record
   */
  async startEditingRaw(
    requestParameters: StartEditingRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters['metadataUuid'] == null) {
      throw new runtime.RequiredError(
        'metadataUuid',
        'Required parameter "metadataUuid" was null or undefined when calling startEditing().'
      );
    }

    const queryParameters: any = {};

    if (requestParameters['currTab'] != null) {
      queryParameters['currTab'] = requestParameters['currTab'];
    }

    if (requestParameters['withAttributes'] != null) {
      queryParameters['withAttributes'] = requestParameters['withAttributes'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/records/{metadataUuid}/editor`.replace(
          `{${'metadataUuid'}}`,
          encodeURIComponent(String(requestParameters['metadataUuid']))
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Return HTML form for editing.
   * Edit a record
   */
  async startEditing(
    requestParameters: StartEditingRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<void> {
    await this.startEditingRaw(requestParameters, initOverrides);
  }

  /**
   * Set the records status to submitted
   */
  async submitRaw(
    requestParameters: SubmitRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<MetadataProcessingReport>> {
    if (requestParameters['metadataBatchSubmitParameter'] == null) {
      throw new runtime.RequiredError(
        'metadataBatchSubmitParameter',
        'Required parameter "metadataBatchSubmitParameter" was null or undefined when calling submit().'
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/records/submit`,
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: MetadataBatchSubmitParameterToJSON(
          requestParameters['metadataBatchSubmitParameter']
        ),
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, jsonValue =>
      MetadataProcessingReportFromJSON(jsonValue)
    );
  }

  /**
   * Set the records status to submitted
   */
  async submit(
    requestParameters: SubmitRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<MetadataProcessingReport> {
    const response = await this.submitRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Add tags to a record
   */
  async tagRecordRaw(
    requestParameters: TagRecordRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters['metadataUuid'] == null) {
      throw new runtime.RequiredError(
        'metadataUuid',
        'Required parameter "metadataUuid" was null or undefined when calling tagRecord().'
      );
    }

    if (requestParameters['id'] == null) {
      throw new runtime.RequiredError(
        'id',
        'Required parameter "id" was null or undefined when calling tagRecord().'
      );
    }

    const queryParameters: any = {};

    if (requestParameters['id'] != null) {
      queryParameters['id'] = requestParameters['id'];
    }

    if (requestParameters['clear'] != null) {
      queryParameters['clear'] = requestParameters['clear'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/records/{metadataUuid}/tags`.replace(
          `{${'metadataUuid'}}`,
          encodeURIComponent(String(requestParameters['metadataUuid']))
        ),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Add tags to a record
   */
  async tagRecord(
    requestParameters: TagRecordRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<void> {
    await this.tagRecordRaw(requestParameters, initOverrides);
  }

  /**
   * Add or remove tags to one or more records
   */
  async tagRecordsRaw(
    requestParameters: TagRecordsRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<MetadataProcessingReport>> {
    const queryParameters: any = {};

    if (requestParameters['uuids'] != null) {
      queryParameters['uuids'] = requestParameters['uuids'];
    }

    if (requestParameters['bucket'] != null) {
      queryParameters['bucket'] = requestParameters['bucket'];
    }

    if (requestParameters['id'] != null) {
      queryParameters['id'] = requestParameters['id'];
    }

    if (requestParameters['removeId'] != null) {
      queryParameters['removeId'] = requestParameters['removeId'];
    }

    if (requestParameters['clear'] != null) {
      queryParameters['clear'] = requestParameters['clear'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/records/tags`,
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, jsonValue =>
      MetadataProcessingReportFromJSON(jsonValue)
    );
  }

  /**
   * Add or remove tags to one or more records
   */
  async tagRecords(
    requestParameters: TagRecordsRequest = {},
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<MetadataProcessingReport> {
    const response = await this.tagRecordsRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * The backup contains all metadata not harvested including templates.
   * Trigger MEF backup archive
   */
  async triggerRaw(
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<string>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/records/backups`,
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    if (this.isJsonMime(response.headers.get('content-type'))) {
      return new runtime.JSONApiResponse<string>(response);
    } else {
      return new runtime.TextApiResponse(response) as any;
    }
  }

  /**
   * The backup contains all metadata not harvested including templates.
   * Trigger MEF backup archive
   */
  async trigger(
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<string> {
    const response = await this.triggerRaw(initOverrides);
    return await response.value();
  }

  /**
   * Unsets privileges for ALL group to publish the metadata for all users.
   */
  async unpublishRaw(
    requestParameters: UnpublishRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters['metadataUuid'] == null) {
      throw new runtime.RequiredError(
        'metadataUuid',
        'Required parameter "metadataUuid" was null or undefined when calling unpublish().'
      );
    }

    if (requestParameters['publicationType'] == null) {
      throw new runtime.RequiredError(
        'publicationType',
        'Required parameter "publicationType" was null or undefined when calling unpublish().'
      );
    }

    const queryParameters: any = {};

    if (requestParameters['publicationType'] != null) {
      queryParameters['publicationType'] = requestParameters['publicationType'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/records/{metadataUuid}/unpublish`.replace(
          `{${'metadataUuid'}}`,
          encodeURIComponent(String(requestParameters['metadataUuid']))
        ),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Unsets privileges for ALL group to publish the metadata for all users.
   */
  async unpublish(
    requestParameters: UnpublishRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<void> {
    await this.unpublishRaw(requestParameters, initOverrides);
  }

  /**
   * See record sharing for more details.
   * Un-publish one or more records
   */
  async unpublishMultipleRecordsRaw(
    requestParameters: UnpublishMultipleRecordsRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<MetadataProcessingReport>> {
    if (requestParameters['publicationType'] == null) {
      throw new runtime.RequiredError(
        'publicationType',
        'Required parameter "publicationType" was null or undefined when calling unpublishMultipleRecords().'
      );
    }

    const queryParameters: any = {};

    if (requestParameters['uuids'] != null) {
      queryParameters['uuids'] = requestParameters['uuids'];
    }

    if (requestParameters['bucket'] != null) {
      queryParameters['bucket'] = requestParameters['bucket'];
    }

    if (requestParameters['publicationType'] != null) {
      queryParameters['publicationType'] = requestParameters['publicationType'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/records/unpublish`,
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, jsonValue =>
      MetadataProcessingReportFromJSON(jsonValue)
    );
  }

  /**
   * See record sharing for more details.
   * Un-publish one or more records
   */
  async unpublishMultipleRecords(
    requestParameters: UnpublishMultipleRecordsRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<MetadataProcessingReport> {
    const response = await this.unpublishMultipleRecordsRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Remove a DOI (this is not recommended, DOI are supposed to be persistent once created. This is mainly here for testing).
   */
  async unregisterDoiRaw(
    requestParameters: UnregisterDoiRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters['metadataUuid'] == null) {
      throw new runtime.RequiredError(
        'metadataUuid',
        'Required parameter "metadataUuid" was null or undefined when calling unregisterDoi().'
      );
    }

    if (requestParameters['doiServerId'] == null) {
      throw new runtime.RequiredError(
        'doiServerId',
        'Required parameter "doiServerId" was null or undefined when calling unregisterDoi().'
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/records/{metadataUuid}/doi/{doiServerId}`
          .replace(
            `{${'metadataUuid'}}`,
            encodeURIComponent(String(requestParameters['metadataUuid']))
          )
          .replace(
            `{${'doiServerId'}}`,
            encodeURIComponent(String(requestParameters['doiServerId']))
          ),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Remove a DOI (this is not recommended, DOI are supposed to be persistent once created. This is mainly here for testing).
   */
  async unregisterDoi(
    requestParameters: UnregisterDoiRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<void> {
    await this.unregisterDoiRaw(requestParameters, initOverrides);
  }

  /**
   * User MUST be able to edit the record to validate it. FIXME : id MUST be the id of the current metadata record in session ?
   * Validate a record
   */
  async validateRecordRaw(
    requestParameters: ValidateRecordRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<Reports>> {
    if (requestParameters['metadataUuid'] == null) {
      throw new runtime.RequiredError(
        'metadataUuid',
        'Required parameter "metadataUuid" was null or undefined when calling validateRecord().'
      );
    }

    const queryParameters: any = {};

    if (requestParameters['isvalid'] != null) {
      queryParameters['isvalid'] = requestParameters['isvalid'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/records/{metadataUuid}/validate/internal`.replace(
          `{${'metadataUuid'}}`,
          encodeURIComponent(String(requestParameters['metadataUuid']))
        ),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, jsonValue =>
      ReportsFromJSON(jsonValue)
    );
  }

  /**
   * User MUST be able to edit the record to validate it. FIXME : id MUST be the id of the current metadata record in session ?
   * Validate a record
   */
  async validateRecord(
    requestParameters: ValidateRecordRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<Reports> {
    const response = await this.validateRecordRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * User MUST be able to edit the record to validate it. An INSPIRE endpoint must be configured in Settings. This activates an asyncronous process, this method does not return any report. This method returns an id to be used to get the report.
   * Submit a record to the INSPIRE service for validation.
   */
  async validateRecordForInspireRaw(
    requestParameters: ValidateRecordForInspireRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters['metadataUuid'] == null) {
      throw new runtime.RequiredError(
        'metadataUuid',
        'Required parameter "metadataUuid" was null or undefined when calling validateRecordForInspire().'
      );
    }

    if (requestParameters['testsuite'] == null) {
      throw new runtime.RequiredError(
        'testsuite',
        'Required parameter "testsuite" was null or undefined when calling validateRecordForInspire().'
      );
    }

    const queryParameters: any = {};

    if (requestParameters['testsuite'] != null) {
      queryParameters['testsuite'] = requestParameters['testsuite'];
    }

    if (requestParameters['mode'] != null) {
      queryParameters['mode'] = requestParameters['mode'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/records/{metadataUuid}/validate/inspire`.replace(
          `{${'metadataUuid'}}`,
          encodeURIComponent(String(requestParameters['metadataUuid']))
        ),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    if (this.isJsonMime(response.headers.get('content-type'))) {
      return new runtime.JSONApiResponse<string>(response);
    } else {
      return new runtime.TextApiResponse(response) as any;
    }
  }

  /**
   * User MUST be able to edit the record to validate it. An INSPIRE endpoint must be configured in Settings. This activates an asyncronous process, this method does not return any report. This method returns an id to be used to get the report.
   * Submit a record to the INSPIRE service for validation.
   */
  async validateRecordForInspire(
    requestParameters: ValidateRecordForInspireRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<string> {
    const response = await this.validateRecordForInspireRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Update validation status for all records.
   * Validate one or more records
   */
  async validateRecordsRaw(
    requestParameters: ValidateRecordsRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<SimpleMetadataProcessingReport>> {
    const queryParameters: any = {};

    if (requestParameters['uuids'] != null) {
      queryParameters['uuids'] = requestParameters['uuids'];
    }

    if (requestParameters['approved'] != null) {
      queryParameters['approved'] = requestParameters['approved'];
    }

    if (requestParameters['bucket'] != null) {
      queryParameters['bucket'] = requestParameters['bucket'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/records/validate`,
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, jsonValue =>
      SimpleMetadataProcessingReportFromJSON(jsonValue)
    );
  }

  /**
   * Update validation status for all records.
   * Validate one or more records
   */
  async validateRecords(
    requestParameters: ValidateRecordsRequest = {},
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<SimpleMetadataProcessingReport> {
    const response = await this.validateRecordsRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Update validation status for all records.
   * Validate one or more records in INSPIRE validator
   */
  async validateRecordsInspireRaw(
    requestParameters: ValidateRecordsInspireRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<string>> {
    const queryParameters: any = {};

    if (requestParameters['uuids'] != null) {
      queryParameters['uuids'] = requestParameters['uuids'];
    }

    if (requestParameters['bucket'] != null) {
      queryParameters['bucket'] = requestParameters['bucket'];
    }

    if (requestParameters['mode'] != null) {
      queryParameters['mode'] = requestParameters['mode'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/records/validate/inspire`,
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    if (this.isJsonMime(response.headers.get('content-type'))) {
      return new runtime.JSONApiResponse<string>(response);
    } else {
      return new runtime.TextApiResponse(response) as any;
    }
  }

  /**
   * Update validation status for all records.
   * Validate one or more records in INSPIRE validator
   */
  async validateRecordsInspire(
    requestParameters: ValidateRecordsInspireRequest = {},
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<string> {
    const response = await this.validateRecordsInspireRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }
}

/**
 * @export
 */
export const CreateMetadataTypeEnum = {
  Metadata: 'METADATA',
  Template: 'TEMPLATE',
  SubTemplate: 'SUB_TEMPLATE',
  TemplateOfSubTemplate: 'TEMPLATE_OF_SUB_TEMPLATE',
} as const;
export type CreateMetadataTypeEnum =
  (typeof CreateMetadataTypeEnum)[keyof typeof CreateMetadataTypeEnum];
/**
 * @export
 */
export const ExportAsMefFormatEnum = {
  Simple: 'SIMPLE',
  Partial: 'PARTIAL',
  Full: 'FULL',
} as const;
export type ExportAsMefFormatEnum =
  (typeof ExportAsMefFormatEnum)[keyof typeof ExportAsMefFormatEnum];
/**
 * @export
 */
export const GetAllResourcesSortEnum = {
  Type: 'type',
  Name: 'name',
} as const;
export type GetAllResourcesSortEnum =
  (typeof GetAllResourcesSortEnum)[keyof typeof GetAllResourcesSortEnum];
/**
 * @export
 */
export const GetRecordAsZipFormatEnum = {
  Simple: 'SIMPLE',
  Partial: 'PARTIAL',
  Full: 'FULL',
} as const;
export type GetRecordAsZipFormatEnum =
  (typeof GetRecordAsZipFormatEnum)[keyof typeof GetRecordAsZipFormatEnum];
/**
 * @export
 */
export const GetRecordFormattedByWidthEnum = {
  _25: '_25',
  _50: '_50',
  _75: '_75',
  _100: '_100',
} as const;
export type GetRecordFormattedByWidthEnum =
  (typeof GetRecordFormattedByWidthEnum)[keyof typeof GetRecordFormattedByWidthEnum];
/**
 * @export
 */
export const GetRecordFormattedByOutputEnum = {
  Txt: 'txt',
  Html: 'html',
  Xml: 'xml',
  Json: 'json',
  Jsonld: 'jsonld',
  Pdf: 'pdf',
  Testpdf: 'testpdf',
} as const;
export type GetRecordFormattedByOutputEnum =
  (typeof GetRecordFormattedByOutputEnum)[keyof typeof GetRecordFormattedByOutputEnum];
/**
 * @export
 */
export const GetRecordStatusHistorySortOrderEnum = {
  Asc: 'ASC',
  Desc: 'DESC',
} as const;
export type GetRecordStatusHistorySortOrderEnum =
  (typeof GetRecordStatusHistorySortOrderEnum)[keyof typeof GetRecordStatusHistorySortOrderEnum];
/**
 * @export
 */
export const GetRecordStatusHistoryByTypeTypeEnum = {
  Workflow: 'workflow',
  Task: 'task',
  Event: 'event',
} as const;
export type GetRecordStatusHistoryByTypeTypeEnum =
  (typeof GetRecordStatusHistoryByTypeTypeEnum)[keyof typeof GetRecordStatusHistoryByTypeTypeEnum];
/**
 * @export
 */
export const GetRecordStatusHistoryByTypeSortOrderEnum = {
  Asc: 'ASC',
  Desc: 'DESC',
} as const;
export type GetRecordStatusHistoryByTypeSortOrderEnum =
  (typeof GetRecordStatusHistoryByTypeSortOrderEnum)[keyof typeof GetRecordStatusHistoryByTypeSortOrderEnum];
/**
 * @export
 */
export const GetWorkflowStatusByTypeTypeEnum = {
  Workflow: 'workflow',
  Task: 'task',
  Event: 'event',
} as const;
export type GetWorkflowStatusByTypeTypeEnum =
  (typeof GetWorkflowStatusByTypeTypeEnum)[keyof typeof GetWorkflowStatusByTypeTypeEnum];
/**
 * @export
 */
export const GetWorkflowStatusByTypeSortOrderEnum = {
  Asc: 'ASC',
  Desc: 'DESC',
} as const;
export type GetWorkflowStatusByTypeSortOrderEnum =
  (typeof GetWorkflowStatusByTypeSortOrderEnum)[keyof typeof GetWorkflowStatusByTypeSortOrderEnum];
/**
 * @export
 */
export const InsertMetadataTypeEnum = {
  Metadata: 'METADATA',
  Template: 'TEMPLATE',
  SubTemplate: 'SUB_TEMPLATE',
  TemplateOfSubTemplate: 'TEMPLATE_OF_SUB_TEMPLATE',
} as const;
export type InsertMetadataTypeEnum =
  (typeof InsertMetadataTypeEnum)[keyof typeof InsertMetadataTypeEnum];
/**
 * @export
 */
export const InsertUuidProcessingEnum = {
  Generateuuid: 'GENERATEUUID',
  Nothing: 'NOTHING',
  Overwrite: 'OVERWRITE',
  RemoveAndReplace: 'REMOVE_AND_REPLACE',
} as const;
export type InsertUuidProcessingEnum =
  (typeof InsertUuidProcessingEnum)[keyof typeof InsertUuidProcessingEnum];
/**
 * @export
 */
export const InsertFileMetadataTypeEnum = {
  Metadata: 'METADATA',
  Template: 'TEMPLATE',
  SubTemplate: 'SUB_TEMPLATE',
  TemplateOfSubTemplate: 'TEMPLATE_OF_SUB_TEMPLATE',
} as const;
export type InsertFileMetadataTypeEnum =
  (typeof InsertFileMetadataTypeEnum)[keyof typeof InsertFileMetadataTypeEnum];
/**
 * @export
 */
export const InsertFileUuidProcessingEnum = {
  Generateuuid: 'GENERATEUUID',
  Nothing: 'NOTHING',
  Overwrite: 'OVERWRITE',
  RemoveAndReplace: 'REMOVE_AND_REPLACE',
} as const;
export type InsertFileUuidProcessingEnum =
  (typeof InsertFileUuidProcessingEnum)[keyof typeof InsertFileUuidProcessingEnum];
/**
 * @export
 */
export const InsertOgcMapContextFileUuidProcessingEnum = {
  Generateuuid: 'GENERATEUUID',
  Nothing: 'NOTHING',
  Overwrite: 'OVERWRITE',
  RemoveAndReplace: 'REMOVE_AND_REPLACE',
} as const;
export type InsertOgcMapContextFileUuidProcessingEnum =
  (typeof InsertOgcMapContextFileUuidProcessingEnum)[keyof typeof InsertOgcMapContextFileUuidProcessingEnum];
/**
 * @export
 */
export const PatchResourceVisibilityEnum = {
  Public: 'PUBLIC',
  Private: 'PRIVATE',
} as const;
export type PatchResourceVisibilityEnum =
  (typeof PatchResourceVisibilityEnum)[keyof typeof PatchResourceVisibilityEnum];
/**
 * @export
 */
export const PreviewBatchEditDiffTypeEnum = {
  Patch: 'patch',
  Diff: 'diff',
  Diffhtml: 'diffhtml',
} as const;
export type PreviewBatchEditDiffTypeEnum =
  (typeof PreviewBatchEditDiffTypeEnum)[keyof typeof PreviewBatchEditDiffTypeEnum];
/**
 * @export
 */
export const PutResourceVisibilityEnum = {
  Public: 'PUBLIC',
  Private: 'PRIVATE',
} as const;
export type PutResourceVisibilityEnum =
  (typeof PutResourceVisibilityEnum)[keyof typeof PutResourceVisibilityEnum];
/**
 * @export
 */
export const PutResourceFromURLVisibilityEnum = {
  Public: 'PUBLIC',
  Private: 'PRIVATE',
} as const;
export type PutResourceFromURLVisibilityEnum =
  (typeof PutResourceFromURLVisibilityEnum)[keyof typeof PutResourceFromURLVisibilityEnum];
