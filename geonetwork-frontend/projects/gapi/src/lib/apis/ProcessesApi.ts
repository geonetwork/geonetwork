/* tslint:disable */
/* eslint-disable */
/**
 * GeoNetwork 4.4.7 OpenAPI Documentation
 * This is the description of the GeoNetwork OpenAPI. Use this API to manage your catalog.
 *
 * The version of the OpenAPI document: 4.4.7
 * Contact: geonetwork-users@lists.sourceforge.net
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as runtime from '../runtime';
import type {
  MetadataReplacementProcessingReport,
  ProcessingReport,
  XsltMetadataProcessingReport,
} from '../models/index';
import {
  MetadataReplacementProcessingReportFromJSON,
  MetadataReplacementProcessingReportToJSON,
  ProcessingReportFromJSON,
  ProcessingReportToJSON,
  XsltMetadataProcessingReportFromJSON,
  XsltMetadataProcessingReportToJSON,
} from '../models/index';

export interface PreviewProcessRecordsRequest {
  process: string;
  diffType?: PreviewProcessRecordsDiffTypeEnum;
  uuids?: Array<string>;
  bucket?: string;
  appendFirst?: boolean;
  applyUpdateFixedInfo?: boolean;
}

export interface PreviewProcessSearchAndReplaceRequest {
  search: string;
  useRegexp?: boolean;
  replace?: string;
  regexpFlags?: string;
  diffType?: PreviewProcessSearchAndReplaceDiffTypeEnum;
  uuids?: Array<string>;
  bucket?: string;
}

export interface ProcessRecordsRequest {
  process: string;
  uuids?: Array<string>;
  bucket?: string;
  updateDateStamp?: boolean;
  index?: boolean;
}

export interface ProcessSearchAndReplaceRequest {
  search: string;
  useRegexp?: boolean;
  replace?: string;
  regexpFlags?: string;
  uuids?: Array<string>;
  bucket?: string;
  updateDateStamp?: boolean;
  index?: boolean;
}

export interface SearchAndReplaceRequest {
  process?: string;
  uuids?: Array<string>;
  bucket?: string;
  isTesting?: boolean;
  isCaseInsensitive?: boolean;
  vacuumMode?: string;
}

/**
 *
 */
export class ProcessesApi extends runtime.BaseAPI {
  /**
   * Clear process reports list
   */
  async deleteProcessReportRaw(
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<void>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/processes/reports`,
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Clear process reports list
   */
  async deleteProcessReport(
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<void> {
    await this.deleteProcessReportRaw(initOverrides);
  }

  /**
   * When processing, the report is stored in memory and allows to retrieve progress repport during processing. Usually, process reports are returned by the synchronous processing operation.
   * Get current process reports
   */
  async getProcessReportRaw(
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<Array<ProcessingReport>>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/processes/reports`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, jsonValue =>
      jsonValue.map(ProcessingReportFromJSON)
    );
  }

  /**
   * When processing, the report is stored in memory and allows to retrieve progress repport during processing. Usually, process reports are returned by the synchronous processing operation.
   * Get current process reports
   */
  async getProcessReport(
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<Array<ProcessingReport>> {
    const response = await this.getProcessReportRaw(initOverrides);
    return await response.value();
  }

  /**
   * Preview result of a process applied to metadata records with an XSL transformation declared in the metadata schema (See the process folder). Parameters sent to the service are forwarded to XSL process. Append mode has 2 limitations. First, it only support a set of records in the same schema. Secondly, it does not propagate URL parameters. This mode is mainly used to create custom reports based on metadata records content.If process name ends with \'.csv\', the XSL process output a text document which is returned. When errors occur during processing, the processing report is returned in JSON format.
   * Preview process result applied to one or more records
   */
  async previewProcessRecordsRaw(
    requestParameters: PreviewProcessRecordsRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<object>> {
    if (requestParameters['process'] == null) {
      throw new runtime.RequiredError(
        'process',
        'Required parameter "process" was null or undefined when calling previewProcessRecords().'
      );
    }

    const queryParameters: any = {};

    if (requestParameters['diffType'] != null) {
      queryParameters['diffType'] = requestParameters['diffType'];
    }

    if (requestParameters['uuids'] != null) {
      queryParameters['uuids'] = requestParameters['uuids'];
    }

    if (requestParameters['bucket'] != null) {
      queryParameters['bucket'] = requestParameters['bucket'];
    }

    if (requestParameters['appendFirst'] != null) {
      queryParameters['appendFirst'] = requestParameters['appendFirst'];
    }

    if (requestParameters['applyUpdateFixedInfo'] != null) {
      queryParameters['applyUpdateFixedInfo'] =
        requestParameters['applyUpdateFixedInfo'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/processes/{process}`.replace(
          `{${'process'}}`,
          encodeURIComponent(String(requestParameters['process']))
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse<any>(response);
  }

  /**
   * Preview result of a process applied to metadata records with an XSL transformation declared in the metadata schema (See the process folder). Parameters sent to the service are forwarded to XSL process. Append mode has 2 limitations. First, it only support a set of records in the same schema. Secondly, it does not propagate URL parameters. This mode is mainly used to create custom reports based on metadata records content.If process name ends with \'.csv\', the XSL process output a text document which is returned. When errors occur during processing, the processing report is returned in JSON format.
   * Preview process result applied to one or more records
   */
  async previewProcessRecords(
    requestParameters: PreviewProcessRecordsRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<object> {
    const response = await this.previewProcessRecordsRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   *  When errors occur during processing, the processing report is returned in JSON format.
   * Preview of search and replace text.
   */
  async previewProcessSearchAndReplaceRaw(
    requestParameters: PreviewProcessSearchAndReplaceRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<object>> {
    if (requestParameters['search'] == null) {
      throw new runtime.RequiredError(
        'search',
        'Required parameter "search" was null or undefined when calling previewProcessSearchAndReplace().'
      );
    }

    const queryParameters: any = {};

    if (requestParameters['useRegexp'] != null) {
      queryParameters['useRegexp'] = requestParameters['useRegexp'];
    }

    if (requestParameters['search'] != null) {
      queryParameters['search'] = requestParameters['search'];
    }

    if (requestParameters['replace'] != null) {
      queryParameters['replace'] = requestParameters['replace'];
    }

    if (requestParameters['regexpFlags'] != null) {
      queryParameters['regexpFlags'] = requestParameters['regexpFlags'];
    }

    if (requestParameters['diffType'] != null) {
      queryParameters['diffType'] = requestParameters['diffType'];
    }

    if (requestParameters['uuids'] != null) {
      queryParameters['uuids'] = requestParameters['uuids'];
    }

    if (requestParameters['bucket'] != null) {
      queryParameters['bucket'] = requestParameters['bucket'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/processes/db/search-and-replace`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse<any>(response);
  }

  /**
   *  When errors occur during processing, the processing report is returned in JSON format.
   * Preview of search and replace text.
   */
  async previewProcessSearchAndReplace(
    requestParameters: PreviewProcessSearchAndReplaceRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<object> {
    const response = await this.previewProcessSearchAndReplaceRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Process a metadata with an XSL transformation declared in the metadata schema (See the process folder). Parameters sent to the service are forwarded to XSL process.
   * Apply a process to one or more records
   */
  async processRecordsRaw(
    requestParameters: ProcessRecordsRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<XsltMetadataProcessingReport>> {
    if (requestParameters['process'] == null) {
      throw new runtime.RequiredError(
        'process',
        'Required parameter "process" was null or undefined when calling processRecords().'
      );
    }

    const queryParameters: any = {};

    if (requestParameters['uuids'] != null) {
      queryParameters['uuids'] = requestParameters['uuids'];
    }

    if (requestParameters['bucket'] != null) {
      queryParameters['bucket'] = requestParameters['bucket'];
    }

    if (requestParameters['updateDateStamp'] != null) {
      queryParameters['updateDateStamp'] = requestParameters['updateDateStamp'];
    }

    if (requestParameters['index'] != null) {
      queryParameters['index'] = requestParameters['index'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/processes/{process}`.replace(
          `{${'process'}}`,
          encodeURIComponent(String(requestParameters['process']))
        ),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, jsonValue =>
      XsltMetadataProcessingReportFromJSON(jsonValue)
    );
  }

  /**
   * Process a metadata with an XSL transformation declared in the metadata schema (See the process folder). Parameters sent to the service are forwarded to XSL process.
   * Apply a process to one or more records
   */
  async processRecords(
    requestParameters: ProcessRecordsRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<XsltMetadataProcessingReport> {
    const response = await this.processRecordsRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Process a metadata with an XSL transformation declared in the metadata schema (See the process folder). Parameters sent to the service are forwarded to XSL process.
   * Apply a database search and replace to one or more records
   */
  async processSearchAndReplaceRaw(
    requestParameters: ProcessSearchAndReplaceRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<XsltMetadataProcessingReport>> {
    if (requestParameters['search'] == null) {
      throw new runtime.RequiredError(
        'search',
        'Required parameter "search" was null or undefined when calling processSearchAndReplace().'
      );
    }

    const queryParameters: any = {};

    if (requestParameters['useRegexp'] != null) {
      queryParameters['useRegexp'] = requestParameters['useRegexp'];
    }

    if (requestParameters['search'] != null) {
      queryParameters['search'] = requestParameters['search'];
    }

    if (requestParameters['replace'] != null) {
      queryParameters['replace'] = requestParameters['replace'];
    }

    if (requestParameters['regexpFlags'] != null) {
      queryParameters['regexpFlags'] = requestParameters['regexpFlags'];
    }

    if (requestParameters['uuids'] != null) {
      queryParameters['uuids'] = requestParameters['uuids'];
    }

    if (requestParameters['bucket'] != null) {
      queryParameters['bucket'] = requestParameters['bucket'];
    }

    if (requestParameters['updateDateStamp'] != null) {
      queryParameters['updateDateStamp'] = requestParameters['updateDateStamp'];
    }

    if (requestParameters['index'] != null) {
      queryParameters['index'] = requestParameters['index'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/processes/db/search-and-replace`,
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, jsonValue =>
      XsltMetadataProcessingReportFromJSON(jsonValue)
    );
  }

  /**
   * Process a metadata with an XSL transformation declared in the metadata schema (See the process folder). Parameters sent to the service are forwarded to XSL process.
   * Apply a database search and replace to one or more records
   */
  async processSearchAndReplace(
    requestParameters: ProcessSearchAndReplaceRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<XsltMetadataProcessingReport> {
    const response = await this.processSearchAndReplaceRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Service to apply replacements to one or more records.  To define a replacement, send the following parameters:  * mdsection-139815551372=metadata  * mdfield-1398155513728=id.contact.individualName  * replaceValue-1398155513728=Juan  * searchValue-1398155513728=Jose  <br/>Batch editing can also be used for similar works.
   * Search and replace values in one or more ISO19139 records
   * @deprecated
   */
  async searchAndReplaceRaw(
    requestParameters: SearchAndReplaceRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<MetadataReplacementProcessingReport>> {
    const queryParameters: any = {};

    if (requestParameters['process'] != null) {
      queryParameters['process'] = requestParameters['process'];
    }

    if (requestParameters['uuids'] != null) {
      queryParameters['uuids'] = requestParameters['uuids'];
    }

    if (requestParameters['bucket'] != null) {
      queryParameters['bucket'] = requestParameters['bucket'];
    }

    if (requestParameters['isTesting'] != null) {
      queryParameters['isTesting'] = requestParameters['isTesting'];
    }

    if (requestParameters['isCaseInsensitive'] != null) {
      queryParameters['isCaseInsensitive'] =
        requestParameters['isCaseInsensitive'];
    }

    if (requestParameters['vacuumMode'] != null) {
      queryParameters['vacuumMode'] = requestParameters['vacuumMode'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/processes/search-and-replace`,
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, jsonValue =>
      MetadataReplacementProcessingReportFromJSON(jsonValue)
    );
  }

  /**
   * Service to apply replacements to one or more records.  To define a replacement, send the following parameters:  * mdsection-139815551372=metadata  * mdfield-1398155513728=id.contact.individualName  * replaceValue-1398155513728=Juan  * searchValue-1398155513728=Jose  <br/>Batch editing can also be used for similar works.
   * Search and replace values in one or more ISO19139 records
   * @deprecated
   */
  async searchAndReplace(
    requestParameters: SearchAndReplaceRequest = {},
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<MetadataReplacementProcessingReport> {
    const response = await this.searchAndReplaceRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }
}

/**
 * @export
 */
export const PreviewProcessRecordsDiffTypeEnum = {
  Patch: 'patch',
  Diff: 'diff',
  Diffhtml: 'diffhtml',
} as const;
export type PreviewProcessRecordsDiffTypeEnum =
  (typeof PreviewProcessRecordsDiffTypeEnum)[keyof typeof PreviewProcessRecordsDiffTypeEnum];
/**
 * @export
 */
export const PreviewProcessSearchAndReplaceDiffTypeEnum = {
  Patch: 'patch',
  Diff: 'diff',
  Diffhtml: 'diffhtml',
} as const;
export type PreviewProcessSearchAndReplaceDiffTypeEnum =
  (typeof PreviewProcessSearchAndReplaceDiffTypeEnum)[keyof typeof PreviewProcessSearchAndReplaceDiffTypeEnum];
