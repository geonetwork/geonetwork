/* tslint:disable */
/* eslint-disable */
/**
 * GeoNetwork 4.4.7 OpenAPI Documentation
 * This is the description of the GeoNetwork OpenAPI. Use this API to manage your catalog.
 *
 * The version of the OpenAPI document: 4.4.7
 * Contact: geonetwork-users@lists.sourceforge.net
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as runtime from '../runtime';
import type {
  LogFileResponse,
  ProxyConfiguration,
  Setting,
  SettingsListResponse,
  SiteInformation,
  Status,
  SystemInfo,
} from '../models/index';
import {
  LogFileResponseFromJSON,
  LogFileResponseToJSON,
  ProxyConfigurationFromJSON,
  ProxyConfigurationToJSON,
  SettingFromJSON,
  SettingToJSON,
  SettingsListResponseFromJSON,
  SettingsListResponseToJSON,
  SiteInformationFromJSON,
  SiteInformationToJSON,
  StatusFromJSON,
  StatusToJSON,
  SystemInfoFromJSON,
  SystemInfoToJSON,
} from '../models/index';

export interface GetLastActivityRequest {
  lines?: number;
}

export interface GetSettingsDetailsRequest {
  set?: Array<GetSettingsDetailsSetEnum>;
  key?: Array<string>;
}

export interface GetSettingsSetRequest {
  set?: Array<GetSettingsSetSetEnum>;
  key?: Array<string>;
}

export interface GetSitemapRequest {
  format?: string;
  doc?: number;
}

export interface IndexSiteRequest {
  reset?: boolean;
  asynchronous?: boolean;
  indices?: Array<string>;
  bucket?: string;
}

export interface SaveSettingsRequest {
  allRequestParams: { [key: string]: string };
}

export interface SendApplicationUserFeedbackRequest {
  name: string;
  org: string;
  email: string;
  comments: string;
  recaptcha?: string;
}

export interface SetLogoRequest {
  file: string;
  asFavicon?: boolean;
}

export interface UpdateStagingProfileRequest {
  profile: UpdateStagingProfileProfileEnum;
}

/**
 *
 */
export class SiteApi extends runtime.BaseAPI {
  /**
   * May be used when indexing task is hanging.
   * Force to commit pending documents in index.
   */
  async commitIndexChangesRaw(
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<void>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/site/index/commit`,
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * May be used when indexing task is hanging.
   * Force to commit pending documents in index.
   */
  async commitIndexChanges(
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<void> {
    await this.commitIndexChangesRaw(initOverrides);
  }

  /**
   * Get site informations
   */
  async getInformationRaw(
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<SiteInformation>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/site/info`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, jsonValue =>
      SiteInformationFromJSON(jsonValue)
    );
  }

  /**
   * Get site informations
   */
  async getInformation(
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<SiteInformation> {
    const response = await this.getInformationRaw(initOverrides);
    return await response.value();
  }

  /**
   * Get last activity
   */
  async getLastActivityRaw(
    requestParameters: GetLastActivityRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<string>> {
    const queryParameters: any = {};

    if (requestParameters['lines'] != null) {
      queryParameters['lines'] = requestParameters['lines'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/site/logging/activity`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    if (this.isJsonMime(response.headers.get('content-type'))) {
      return new runtime.JSONApiResponse<string>(response);
    } else {
      return new runtime.TextApiResponse(response) as any;
    }
  }

  /**
   * Get last activity
   */
  async getLastActivity(
    requestParameters: GetLastActivityRequest = {},
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<string> {
    const response = await this.getLastActivityRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Get last activity in a ZIP
   */
  async getLastActivityInAZipRaw(
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<void>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/site/logging/activity/zip`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Get last activity in a ZIP
   */
  async getLastActivityInAZip(
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<void> {
    await this.getLastActivityInAZipRaw(initOverrides);
  }

  /**
   * Get log files
   */
  async getLogFilesRaw(
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<Array<LogFileResponse>>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/site/logging`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, jsonValue =>
      jsonValue.map(LogFileResponseFromJSON)
    );
  }

  /**
   * Get log files
   */
  async getLogFiles(
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<Array<LogFileResponse>> {
    const response = await this.getLogFilesRaw(initOverrides);
    return await response.value();
  }

  /**
   * Get notification levels
   */
  async getNotificationLevelRaw(
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<Array<string>>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/site/info/notificationLevels`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse<any>(response);
  }

  /**
   * Get notification levels
   */
  async getNotificationLevel(
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<Array<string>> {
    const response = await this.getNotificationLevelRaw(initOverrides);
    return await response.value();
  }

  /**
   * Get the proxy configuration.
   * Get proxy configuration details
   */
  async getProxyConfigurationRaw(
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<ProxyConfiguration>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/site/info/proxy`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, jsonValue =>
      ProxyConfigurationFromJSON(jsonValue)
    );
  }

  /**
   * Get the proxy configuration.
   * Get proxy configuration details
   */
  async getProxyConfiguration(
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<ProxyConfiguration> {
    const response = await this.getProxyConfigurationRaw(initOverrides);
    return await response.value();
  }

  /**
   * robots.txt
   */
  async getRobotsTextRaw(
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<void>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/robots.txt`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * robots.txt
   */
  async getRobotsText(
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<void> {
    await this.getRobotsTextRaw(initOverrides);
  }

  /**
   * Provides also setting properties.
   * Get settings with details
   */
  async getSettingsDetailsRaw(
    requestParameters: GetSettingsDetailsRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<Array<Setting>>> {
    const queryParameters: any = {};

    if (requestParameters['set'] != null) {
      queryParameters['set'] = requestParameters['set'];
    }

    if (requestParameters['key'] != null) {
      queryParameters['key'] = requestParameters['key'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/site/settings/details`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, jsonValue =>
      jsonValue.map(SettingFromJSON)
    );
  }

  /**
   * Provides also setting properties.
   * Get settings with details
   */
  async getSettingsDetails(
    requestParameters: GetSettingsDetailsRequest = {},
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<Array<Setting>> {
    const response = await this.getSettingsDetailsRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Return public settings for anonymous users, internals are allowed for authenticated.
   * Get settings
   */
  async getSettingsSetRaw(
    requestParameters: GetSettingsSetRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<SettingsListResponse>> {
    const queryParameters: any = {};

    if (requestParameters['set'] != null) {
      queryParameters['set'] = requestParameters['set'];
    }

    if (requestParameters['key'] != null) {
      queryParameters['key'] = requestParameters['key'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/site/settings`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, jsonValue =>
      SettingsListResponseFromJSON(jsonValue)
    );
  }

  /**
   * Return public settings for anonymous users, internals are allowed for authenticated.
   * Get settings
   */
  async getSettingsSet(
    requestParameters: GetSettingsSetRequest = {},
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<SettingsListResponse> {
    const response = await this.getSettingsSetRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Get site (or portal) description
   */
  async getSiteOrPortalDescriptionRaw(
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<{ [key: string]: string }>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/site`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse<any>(response);
  }

  /**
   * Get site (or portal) description
   */
  async getSiteOrPortalDescription(
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<{ [key: string]: string }> {
    const response = await this.getSiteOrPortalDescriptionRaw(initOverrides);
    return await response.value();
  }

  /**
   * Get sitemap
   */
  async getSitemapRaw(
    requestParameters: GetSitemapRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<void>> {
    const queryParameters: any = {};

    if (requestParameters['format'] != null) {
      queryParameters['format'] = requestParameters['format'];
    }

    if (requestParameters['doc'] != null) {
      queryParameters['doc'] = requestParameters['doc'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/sitemap`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Get sitemap
   */
  async getSitemap(
    requestParameters: GetSitemapRequest = {},
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<void> {
    await this.getSitemapRaw(requestParameters, initOverrides);
  }

  /**
   * To know when and how this version of the application was built.
   * Get build details
   */
  async getSystemInfoRaw(
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<SystemInfo>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/site/info/build`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, jsonValue =>
      SystemInfoFromJSON(jsonValue)
    );
  }

  /**
   * To know when and how this version of the application was built.
   * Get build details
   */
  async getSystemInfo(
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<SystemInfo> {
    const response = await this.getSystemInfoRaw(initOverrides);
    return await response.value();
  }

  /**
   * XSL transformations may be applied while importing or harvesting records.
   * Get XSL tranformations available
   */
  async getXslTransformationsRaw(
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<Array<string>>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/site/info/transforms`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse<any>(response);
  }

  /**
   * XSL transformations may be applied while importing or harvesting records.
   * Get XSL tranformations available
   */
  async getXslTransformations(
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<Array<string>> {
    const response = await this.getXslTransformationsRaw(initOverrides);
    return await response.value();
  }

  /**
   * Index synchronized with database
   */
  async indexAndDbSynchronizationStatusRaw(
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<{ [key: string]: object }>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/site/index/synchronized`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse<any>(response);
  }

  /**
   * Index synchronized with database
   */
  async indexAndDbSynchronizationStatus(
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<{ [key: string]: object }> {
    const response =
      await this.indexAndDbSynchronizationStatusRaw(initOverrides);
    return await response.value();
  }

  /**
   * Index commit
   */
  async indexCommitRaw(
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<void>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/site/index/commit`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Index commit
   */
  async indexCommit(
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<void> {
    await this.indexCommitRaw(initOverrides);
  }

  /**
   * Index
   */
  async indexSiteRaw(
    requestParameters: IndexSiteRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<string>> {
    const queryParameters: any = {};

    if (requestParameters['reset'] != null) {
      queryParameters['reset'] = requestParameters['reset'];
    }

    if (requestParameters['asynchronous'] != null) {
      queryParameters['asynchronous'] = requestParameters['asynchronous'];
    }

    if (requestParameters['indices'] != null) {
      queryParameters['indices'] = requestParameters['indices'];
    }

    if (requestParameters['bucket'] != null) {
      queryParameters['bucket'] = requestParameters['bucket'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/site/index`,
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    if (this.isJsonMime(response.headers.get('content-type'))) {
      return new runtime.JSONApiResponse<string>(response);
    } else {
      return new runtime.TextApiResponse(response) as any;
    }
  }

  /**
   * Index
   */
  async indexSite(
    requestParameters: IndexSiteRequest = {},
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<string> {
    const response = await this.indexSiteRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Index status
   */
  async indexStatusRaw(
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<Status>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/site/index/status`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, jsonValue =>
      StatusFromJSON(jsonValue)
    );
  }

  /**
   * Index status
   */
  async indexStatus(
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<Status> {
    const response = await this.indexStatusRaw(initOverrides);
    return await response.value();
  }

  /**
   * Is CAS enabled?
   */
  async isCasEnabledRaw(
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<boolean>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/site/info/isCasEnabled`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    if (this.isJsonMime(response.headers.get('content-type'))) {
      return new runtime.JSONApiResponse<boolean>(response);
    } else {
      return new runtime.TextApiResponse(response) as any;
    }
  }

  /**
   * Is CAS enabled?
   */
  async isCasEnabled(
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<boolean> {
    const response = await this.isCasEnabledRaw(initOverrides);
    return await response.value();
  }

  /**
   * Is indexing?
   */
  async isIndexingRaw(
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<boolean>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/site/indexing`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    if (this.isJsonMime(response.headers.get('content-type'))) {
      return new runtime.JSONApiResponse<boolean>(response);
    } else {
      return new runtime.TextApiResponse(response) as any;
    }
  }

  /**
   * Is indexing?
   */
  async isIndexing(
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<boolean> {
    const response = await this.isIndexingRaw(initOverrides);
    return await response.value();
  }

  /**
   * Is in read-only mode?
   */
  async isReadOnlyRaw(
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<boolean>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/site/info/readonly`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    if (this.isJsonMime(response.headers.get('content-type'))) {
      return new runtime.JSONApiResponse<boolean>(response);
    } else {
      return new runtime.TextApiResponse(response) as any;
    }
  }

  /**
   * Is in read-only mode?
   */
  async isReadOnly(
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<boolean> {
    const response = await this.isReadOnlyRaw(initOverrides);
    return await response.value();
  }

  /**
   * Save settings
   */
  async saveSettingsRaw(
    requestParameters: SaveSettingsRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters['allRequestParams'] == null) {
      throw new runtime.RequiredError(
        'allRequestParams',
        'Required parameter "allRequestParams" was null or undefined when calling saveSettings().'
      );
    }

    const queryParameters: any = {};

    if (requestParameters['allRequestParams'] != null) {
      queryParameters['allRequestParams'] =
        requestParameters['allRequestParams'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/site/settings`,
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Save settings
   */
  async saveSettings(
    requestParameters: SaveSettingsRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<void> {
    await this.saveSettingsRaw(requestParameters, initOverrides);
  }

  /**
   * Send an email to catalogue administrator with feedback about the application
   */
  async sendApplicationUserFeedbackRaw(
    requestParameters: SendApplicationUserFeedbackRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters['name'] == null) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter "name" was null or undefined when calling sendApplicationUserFeedback().'
      );
    }

    if (requestParameters['org'] == null) {
      throw new runtime.RequiredError(
        'org',
        'Required parameter "org" was null or undefined when calling sendApplicationUserFeedback().'
      );
    }

    if (requestParameters['email'] == null) {
      throw new runtime.RequiredError(
        'email',
        'Required parameter "email" was null or undefined when calling sendApplicationUserFeedback().'
      );
    }

    if (requestParameters['comments'] == null) {
      throw new runtime.RequiredError(
        'comments',
        'Required parameter "comments" was null or undefined when calling sendApplicationUserFeedback().'
      );
    }

    const queryParameters: any = {};

    if (requestParameters['recaptcha'] != null) {
      queryParameters['recaptcha'] = requestParameters['recaptcha'];
    }

    if (requestParameters['name'] != null) {
      queryParameters['name'] = requestParameters['name'];
    }

    if (requestParameters['org'] != null) {
      queryParameters['org'] = requestParameters['org'];
    }

    if (requestParameters['email'] != null) {
      queryParameters['email'] = requestParameters['email'];
    }

    if (requestParameters['comments'] != null) {
      queryParameters['comments'] = requestParameters['comments'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/site/userfeedback`,
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    if (this.isJsonMime(response.headers.get('content-type'))) {
      return new runtime.JSONApiResponse<string>(response);
    } else {
      return new runtime.TextApiResponse(response) as any;
    }
  }

  /**
   * Send an email to catalogue administrator with feedback about the application
   */
  async sendApplicationUserFeedback(
    requestParameters: SendApplicationUserFeedbackRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<string> {
    const response = await this.sendApplicationUserFeedbackRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Logos are stored in the data directory resources/images/harvesting as PNG or GIF images. When a logo is assigned to the catalog, a new image is created in images/logos/<catalogUuid>.png.
   * Set catalog logo
   */
  async setLogoRaw(
    requestParameters: SetLogoRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters['file'] == null) {
      throw new runtime.RequiredError(
        'file',
        'Required parameter "file" was null or undefined when calling setLogo().'
      );
    }

    const queryParameters: any = {};

    if (requestParameters['file'] != null) {
      queryParameters['file'] = requestParameters['file'];
    }

    if (requestParameters['asFavicon'] != null) {
      queryParameters['asFavicon'] = requestParameters['asFavicon'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/site/logo`,
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Logos are stored in the data directory resources/images/harvesting as PNG or GIF images. When a logo is assigned to the catalog, a new image is created in images/logos/<catalogUuid>.png.
   * Set catalog logo
   */
  async setLogo(
    requestParameters: SetLogoRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<void> {
    await this.setLogoRaw(requestParameters, initOverrides);
  }

  /**
   * TODO: Needs doc
   * Update staging profile
   */
  async updateStagingProfileRaw(
    requestParameters: UpdateStagingProfileRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters['profile'] == null) {
      throw new runtime.RequiredError(
        'profile',
        'Required parameter "profile" was null or undefined when calling updateStagingProfile().'
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/site/info/staging/{profile}`.replace(
          `{${'profile'}}`,
          encodeURIComponent(String(requestParameters['profile']))
        ),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * TODO: Needs doc
   * Update staging profile
   */
  async updateStagingProfile(
    requestParameters: UpdateStagingProfileRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<void> {
    await this.updateStagingProfileRaw(requestParameters, initOverrides);
  }
}

/**
 * @export
 */
export const GetSettingsDetailsSetEnum = {
  Inspire: 'INSPIRE',
  Csw: 'CSW',
  Harvester: 'HARVESTER',
  UserGroupOnly: 'USER_GROUP_ONLY',
  Auth: 'AUTH',
  ReadOnly: 'READ_ONLY',
  Index: 'INDEX',
  Systeminfo: 'SYSTEMINFO',
  StagingProfile: 'STAGING_PROFILE',
  Type: 'TYPE',
} as const;
export type GetSettingsDetailsSetEnum =
  (typeof GetSettingsDetailsSetEnum)[keyof typeof GetSettingsDetailsSetEnum];
/**
 * @export
 */
export const GetSettingsSetSetEnum = {
  Inspire: 'INSPIRE',
  Csw: 'CSW',
  Harvester: 'HARVESTER',
  UserGroupOnly: 'USER_GROUP_ONLY',
  Auth: 'AUTH',
  ReadOnly: 'READ_ONLY',
  Index: 'INDEX',
  Systeminfo: 'SYSTEMINFO',
  StagingProfile: 'STAGING_PROFILE',
  Type: 'TYPE',
} as const;
export type GetSettingsSetSetEnum =
  (typeof GetSettingsSetSetEnum)[keyof typeof GetSettingsSetSetEnum];
/**
 * @export
 */
export const UpdateStagingProfileProfileEnum = {
  Testing: 'testing',
  Development: 'development',
  Production: 'production',
} as const;
export type UpdateStagingProfileProfileEnum =
  (typeof UpdateStagingProfileProfileEnum)[keyof typeof UpdateStagingProfileProfileEnum];
