/* tslint:disable */
/* eslint-disable */
/**
 * GeoNetwork 4.4.5 OpenAPI Documentation
 * This is the description of the GeoNetwork OpenAPI. Use this API to manage your catalog.
 *
 * The version of the OpenAPI document: 4.4.5
 * Contact: geonetwork-users@lists.sourceforge.net
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as runtime from '../runtime';
import type { PageProperties } from '../models/index';
import { PagePropertiesFromJSON, PagePropertiesToJSON } from '../models/index';

export interface AddPageUploadingFileRequest {
  language: string;
  pageId: string;
  data: Blob;
  sections?: Array<AddPageUploadingFileSectionsEnum>;
  status?: AddPageUploadingFileStatusEnum;
  format?: AddPageUploadingFileFormatEnum;
}

export interface AddPageWithoutUploadingFileRequest {
  pageProperties: PageProperties;
}

export interface DeletePageRequest {
  language: string;
  pageId: string;
}

export interface GetPageRequest {
  language: string;
  pageId: string;
}

export interface GetPageContentRequest {
  language: string;
  pageId: string;
}

export interface ListPagesRequest {
  language?: string;
  section?: ListPagesSectionEnum;
  format?: ListPagesFormatEnum;
}

export interface UpdatePageRequest {
  language: string;
  pageId: string;
  pageProperties: PageProperties;
}

/**
 *
 */
export class PagesApi extends runtime.BaseAPI {
  /**
   * <p>Is not possible to load a link and a file at the same time.</p> <a href=\'https://geonetwork-opensource.org/manuals/4.0.x/en/customizing-application/adding-static-pages.html\'>More info</a>
   * Add a page by uploading a file
   */
  async addPageUploadingFileRaw(
    requestParameters: AddPageUploadingFileRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters['language'] == null) {
      throw new runtime.RequiredError(
        'language',
        'Required parameter "language" was null or undefined when calling addPageUploadingFile().'
      );
    }

    if (requestParameters['pageId'] == null) {
      throw new runtime.RequiredError(
        'pageId',
        'Required parameter "pageId" was null or undefined when calling addPageUploadingFile().'
      );
    }

    if (requestParameters['data'] == null) {
      throw new runtime.RequiredError(
        'data',
        'Required parameter "data" was null or undefined when calling addPageUploadingFile().'
      );
    }

    const queryParameters: any = {};

    if (requestParameters['language'] != null) {
      queryParameters['language'] = requestParameters['language'];
    }

    if (requestParameters['pageId'] != null) {
      queryParameters['pageId'] = requestParameters['pageId'];
    }

    if (requestParameters['sections'] != null) {
      queryParameters['sections'] = requestParameters['sections'];
    }

    if (requestParameters['status'] != null) {
      queryParameters['status'] = requestParameters['status'];
    }

    if (requestParameters['format'] != null) {
      queryParameters['format'] = requestParameters['format'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const consumes: runtime.Consume[] = [
      { contentType: 'multipart/form-data' },
    ];
    // @ts-ignore: canConsumeForm may be unused
    const canConsumeForm = runtime.canConsumeForm(consumes);

    let formParams: { append(param: string, value: any): any };
    let useForm = false;
    // use FormData to transmit files using content-type "multipart/form-data"
    useForm = canConsumeForm;
    if (useForm) {
      formParams = new FormData();
    } else {
      formParams = new URLSearchParams();
    }

    if (requestParameters['data'] != null) {
      formParams.append('data', requestParameters['data'] as any);
    }

    const response = await this.request(
      {
        path: `/pages`,
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: formParams,
      },
      initOverrides
    );

    if (this.isJsonMime(response.headers.get('content-type'))) {
      return new runtime.JSONApiResponse<string>(response);
    } else {
      return new runtime.TextApiResponse(response) as any;
    }
  }

  /**
   * <p>Is not possible to load a link and a file at the same time.</p> <a href=\'https://geonetwork-opensource.org/manuals/4.0.x/en/customizing-application/adding-static-pages.html\'>More info</a>
   * Add a page by uploading a file
   */
  async addPageUploadingFile(
    requestParameters: AddPageUploadingFileRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<string> {
    const response = await this.addPageUploadingFileRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * <p>Is not possible to load a link and a file at the same time.</p> <a href=\'https://geonetwork-opensource.org/manuals/4.0.x/en/customizing-application/adding-static-pages.html\'>More info</a>
   * Add a page
   */
  async addPageWithoutUploadingFileRaw(
    requestParameters: AddPageWithoutUploadingFileRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters['pageProperties'] == null) {
      throw new runtime.RequiredError(
        'pageProperties',
        'Required parameter "pageProperties" was null or undefined when calling addPageWithoutUploadingFile().'
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/pages`,
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: PagePropertiesToJSON(requestParameters['pageProperties']),
      },
      initOverrides
    );

    if (this.isJsonMime(response.headers.get('content-type'))) {
      return new runtime.JSONApiResponse<string>(response);
    } else {
      return new runtime.TextApiResponse(response) as any;
    }
  }

  /**
   * <p>Is not possible to load a link and a file at the same time.</p> <a href=\'https://geonetwork-opensource.org/manuals/4.0.x/en/customizing-application/adding-static-pages.html\'>More info</a>
   * Add a page
   */
  async addPageWithoutUploadingFile(
    requestParameters: AddPageWithoutUploadingFileRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<string> {
    const response = await this.addPageWithoutUploadingFileRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * <a href=\'https://geonetwork-opensource.org/manuals/4.0.x/en/customizing-application/adding-static-pages.html\'>More info</a>
   * Delete a page
   */
  async deletePageRaw(
    requestParameters: DeletePageRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters['language'] == null) {
      throw new runtime.RequiredError(
        'language',
        'Required parameter "language" was null or undefined when calling deletePage().'
      );
    }

    if (requestParameters['pageId'] == null) {
      throw new runtime.RequiredError(
        'pageId',
        'Required parameter "pageId" was null or undefined when calling deletePage().'
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/pages/{language}/{pageId}`
          .replace(
            `{${'language'}}`,
            encodeURIComponent(String(requestParameters['language']))
          )
          .replace(
            `{${'pageId'}}`,
            encodeURIComponent(String(requestParameters['pageId']))
          ),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * <a href=\'https://geonetwork-opensource.org/manuals/4.0.x/en/customizing-application/adding-static-pages.html\'>More info</a>
   * Delete a page
   */
  async deletePage(
    requestParameters: DeletePageRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<void> {
    await this.deletePageRaw(requestParameters, initOverrides);
  }

  /**
   * <a href=\'https://geonetwork-opensource.org/manuals/4.0.x/en/customizing-application/adding-static-pages.html\'>More info</a>
   * Return the page object details except the content
   */
  async getPageRaw(
    requestParameters: GetPageRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<PageProperties>> {
    if (requestParameters['language'] == null) {
      throw new runtime.RequiredError(
        'language',
        'Required parameter "language" was null or undefined when calling getPage().'
      );
    }

    if (requestParameters['pageId'] == null) {
      throw new runtime.RequiredError(
        'pageId',
        'Required parameter "pageId" was null or undefined when calling getPage().'
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/pages/{language}/{pageId}`
          .replace(
            `{${'language'}}`,
            encodeURIComponent(String(requestParameters['language']))
          )
          .replace(
            `{${'pageId'}}`,
            encodeURIComponent(String(requestParameters['pageId']))
          ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, jsonValue =>
      PagePropertiesFromJSON(jsonValue)
    );
  }

  /**
   * <a href=\'https://geonetwork-opensource.org/manuals/4.0.x/en/customizing-application/adding-static-pages.html\'>More info</a>
   * Return the page object details except the content
   */
  async getPage(
    requestParameters: GetPageRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<PageProperties> {
    const response = await this.getPageRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * <a href=\'https://geonetwork-opensource.org/manuals/4.0.x/en/customizing-application/adding-static-pages.html\'>More info</a>
   * Return the static html content identified by pageId
   */
  async getPageContentRaw(
    requestParameters: GetPageContentRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters['language'] == null) {
      throw new runtime.RequiredError(
        'language',
        'Required parameter "language" was null or undefined when calling getPageContent().'
      );
    }

    if (requestParameters['pageId'] == null) {
      throw new runtime.RequiredError(
        'pageId',
        'Required parameter "pageId" was null or undefined when calling getPageContent().'
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/pages/{language}/{pageId}/content`
          .replace(
            `{${'language'}}`,
            encodeURIComponent(String(requestParameters['language']))
          )
          .replace(
            `{${'pageId'}}`,
            encodeURIComponent(String(requestParameters['pageId']))
          ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    if (this.isJsonMime(response.headers.get('content-type'))) {
      return new runtime.JSONApiResponse<string>(response);
    } else {
      return new runtime.TextApiResponse(response) as any;
    }
  }

  /**
   * <a href=\'https://geonetwork-opensource.org/manuals/4.0.x/en/customizing-application/adding-static-pages.html\'>More info</a>
   * Return the static html content identified by pageId
   */
  async getPageContent(
    requestParameters: GetPageContentRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<string> {
    const response = await this.getPageContentRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   */
  async getPageFormatsRaw(
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<Array<string>>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/pages/config/formats`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse<any>(response);
  }

  /**
   */
  async getPageFormats(
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<Array<string>> {
    const response = await this.getPageFormatsRaw(initOverrides);
    return await response.value();
  }

  /**
   */
  async getPageSectionsRaw(
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<Array<string>>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/pages/config/sections`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse<any>(response);
  }

  /**
   */
  async getPageSections(
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<Array<string>> {
    const response = await this.getPageSectionsRaw(initOverrides);
    return await response.value();
  }

  /**
   */
  async getPageStatusRaw(
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<Array<string>>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/pages/config/status`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse<any>(response);
  }

  /**
   */
  async getPageStatus(
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<Array<string>> {
    const response = await this.getPageStatusRaw(initOverrides);
    return await response.value();
  }

  /**
   * <a href=\'https://geonetwork-opensource.org/manuals/4.0.x/en/customizing-application/adding-static-pages.html\'>More info</a>
   * List all pages according to the filters
   */
  async listPagesRaw(
    requestParameters: ListPagesRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<void>> {
    const queryParameters: any = {};

    if (requestParameters['language'] != null) {
      queryParameters['language'] = requestParameters['language'];
    }

    if (requestParameters['section'] != null) {
      queryParameters['section'] = requestParameters['section'];
    }

    if (requestParameters['format'] != null) {
      queryParameters['format'] = requestParameters['format'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/pages`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * <a href=\'https://geonetwork-opensource.org/manuals/4.0.x/en/customizing-application/adding-static-pages.html\'>More info</a>
   * List all pages according to the filters
   */
  async listPages(
    requestParameters: ListPagesRequest = {},
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<void> {
    await this.listPagesRaw(requestParameters, initOverrides);
  }

  /**
   * <a href=\'https://geonetwork-opensource.org/manuals/4.0.x/en/customizing-application/adding-static-pages.html\'>More info</a>
   * Update a page
   */
  async updatePageRaw(
    requestParameters: UpdatePageRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters['language'] == null) {
      throw new runtime.RequiredError(
        'language',
        'Required parameter "language" was null or undefined when calling updatePage().'
      );
    }

    if (requestParameters['pageId'] == null) {
      throw new runtime.RequiredError(
        'pageId',
        'Required parameter "pageId" was null or undefined when calling updatePage().'
      );
    }

    if (requestParameters['pageProperties'] == null) {
      throw new runtime.RequiredError(
        'pageProperties',
        'Required parameter "pageProperties" was null or undefined when calling updatePage().'
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/pages/{language}/{pageId}`
          .replace(
            `{${'language'}}`,
            encodeURIComponent(String(requestParameters['language']))
          )
          .replace(
            `{${'pageId'}}`,
            encodeURIComponent(String(requestParameters['pageId']))
          ),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: PagePropertiesToJSON(requestParameters['pageProperties']),
      },
      initOverrides
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * <a href=\'https://geonetwork-opensource.org/manuals/4.0.x/en/customizing-application/adding-static-pages.html\'>More info</a>
   * Update a page
   */
  async updatePage(
    requestParameters: UpdatePageRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<void> {
    await this.updatePageRaw(requestParameters, initOverrides);
  }
}

/**
 * @export
 */
export const AddPageUploadingFileSectionsEnum = {
  Top: 'TOP',
  Footer: 'FOOTER',
  Menu: 'MENU',
  Submenu: 'SUBMENU',
  CustomMenu1: 'CUSTOM_MENU1',
  CustomMenu2: 'CUSTOM_MENU2',
  CustomMenu3: 'CUSTOM_MENU3',
} as const;
export type AddPageUploadingFileSectionsEnum =
  (typeof AddPageUploadingFileSectionsEnum)[keyof typeof AddPageUploadingFileSectionsEnum];
/**
 * @export
 */
export const AddPageUploadingFileStatusEnum = {
  Public: 'PUBLIC',
  PublicOnly: 'PUBLIC_ONLY',
  Private: 'PRIVATE',
  Hidden: 'HIDDEN',
} as const;
export type AddPageUploadingFileStatusEnum =
  (typeof AddPageUploadingFileStatusEnum)[keyof typeof AddPageUploadingFileStatusEnum];
/**
 * @export
 */
export const AddPageUploadingFileFormatEnum = {
  Link: 'LINK',
  Html: 'HTML',
  Htmlpage: 'HTMLPAGE',
  Text: 'TEXT',
} as const;
export type AddPageUploadingFileFormatEnum =
  (typeof AddPageUploadingFileFormatEnum)[keyof typeof AddPageUploadingFileFormatEnum];
/**
 * @export
 */
export const ListPagesSectionEnum = {
  Top: 'TOP',
  Footer: 'FOOTER',
  Menu: 'MENU',
  Submenu: 'SUBMENU',
  CustomMenu1: 'CUSTOM_MENU1',
  CustomMenu2: 'CUSTOM_MENU2',
  CustomMenu3: 'CUSTOM_MENU3',
} as const;
export type ListPagesSectionEnum =
  (typeof ListPagesSectionEnum)[keyof typeof ListPagesSectionEnum];
/**
 * @export
 */
export const ListPagesFormatEnum = {
  Link: 'LINK',
  Html: 'HTML',
  Htmlpage: 'HTMLPAGE',
  Text: 'TEXT',
} as const;
export type ListPagesFormatEnum =
  (typeof ListPagesFormatEnum)[keyof typeof ListPagesFormatEnum];
