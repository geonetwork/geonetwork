/* tslint:disable */
/* eslint-disable */
/**
 * GeoNetwork 4.4.7 OpenAPI Documentation
 * This is the description of the GeoNetwork OpenAPI. Use this API to manage your catalog.
 *
 * The version of the OpenAPI document: 4.4.7
 * Contact: geonetwork-users@lists.sourceforge.net
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as runtime from '../runtime';
import type { Translations } from '../models/index';
import { TranslationsFromJSON, TranslationsToJSON } from '../models/index';

export interface AddTranslationsRequest {
  translations: Array<Translations>;
  replace?: boolean;
}

export interface AddTranslationsForRequest {
  key: string;
  requestBody: { [key: string]: string };
  replace?: boolean;
}

export interface BuildFilterRequest {
  filters: string;
}

export interface BuildSLDRequest {
  url: string;
  layers: string;
  filters: string;
}

export interface CallStepRequest {
  stepName: string;
}

export interface DeleteTranslationsRequest {
  key: string;
}

export interface DownloadSLDRequest {
  id: number;
  extension: string;
}

export interface GetCustomTranslationsRequest {
  type?: Array<string>;
}

export interface GetTranslationsRequest {
  type?: Array<string>;
}

export interface GetTranslationsPackageRequest {
  pack: string;
}

/**
 *
 */
export class ToolsApi extends runtime.BaseAPI {
  /**
   * Add or update all database translations.
   */
  async addTranslationsRaw(
    requestParameters: AddTranslationsRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters['translations'] == null) {
      throw new runtime.RequiredError(
        'translations',
        'Required parameter "translations" was null or undefined when calling addTranslations().'
      );
    }

    const queryParameters: any = {};

    if (requestParameters['replace'] != null) {
      queryParameters['replace'] = requestParameters['replace'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/i18n/db/translations`,
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: requestParameters['translations']!.map(TranslationsToJSON),
      },
      initOverrides
    );

    if (this.isJsonMime(response.headers.get('content-type'))) {
      return new runtime.JSONApiResponse<string>(response);
    } else {
      return new runtime.TextApiResponse(response) as any;
    }
  }

  /**
   * Add or update all database translations.
   */
  async addTranslations(
    requestParameters: AddTranslationsRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<string> {
    const response = await this.addTranslationsRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Database translations can be used to customize labels in the UI for different languages.
   * Add or update database translations for a key.
   */
  async addTranslationsForRaw(
    requestParameters: AddTranslationsForRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters['key'] == null) {
      throw new runtime.RequiredError(
        'key',
        'Required parameter "key" was null or undefined when calling addTranslationsFor().'
      );
    }

    if (requestParameters['requestBody'] == null) {
      throw new runtime.RequiredError(
        'requestBody',
        'Required parameter "requestBody" was null or undefined when calling addTranslationsFor().'
      );
    }

    const queryParameters: any = {};

    if (requestParameters['replace'] != null) {
      queryParameters['replace'] = requestParameters['replace'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/i18n/db/translations/{key}`.replace(
          `{${'key'}}`,
          encodeURIComponent(String(requestParameters['key']))
        ),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: requestParameters['requestBody'],
      },
      initOverrides
    );

    if (this.isJsonMime(response.headers.get('content-type'))) {
      return new runtime.JSONApiResponse<string>(response);
    } else {
      return new runtime.TextApiResponse(response) as any;
    }
  }

  /**
   * Database translations can be used to customize labels in the UI for different languages.
   * Add or update database translations for a key.
   */
  async addTranslationsFor(
    requestParameters: AddTranslationsForRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<string> {
    const response = await this.addTranslationsForRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * From a JSON filter, return an OGC filter expression.
   * Generate an OGC filter
   */
  async buildFilterRaw(
    requestParameters: BuildFilterRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters['filters'] == null) {
      throw new runtime.RequiredError(
        'filters',
        'Required parameter "filters" was null or undefined when calling buildFilter().'
      );
    }

    const queryParameters: any = {};

    if (requestParameters['filters'] != null) {
      queryParameters['filters'] = requestParameters['filters'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/tools/ogc/filter`,
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    if (this.isJsonMime(response.headers.get('content-type'))) {
      return new runtime.JSONApiResponse<string>(response);
    } else {
      return new runtime.TextApiResponse(response) as any;
    }
  }

  /**
   * From a JSON filter, return an OGC filter expression.
   * Generate an OGC filter
   */
  async buildFilter(
    requestParameters: BuildFilterRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<string> {
    const response = await this.buildFilterRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Get the current SLD for the requested layers, add new filters in, save the SLD and return the new SLD URL.
   * Generate a SLD with a new filter
   */
  async buildSLDRaw(
    requestParameters: BuildSLDRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters['url'] == null) {
      throw new runtime.RequiredError(
        'url',
        'Required parameter "url" was null or undefined when calling buildSLD().'
      );
    }

    if (requestParameters['layers'] == null) {
      throw new runtime.RequiredError(
        'layers',
        'Required parameter "layers" was null or undefined when calling buildSLD().'
      );
    }

    if (requestParameters['filters'] == null) {
      throw new runtime.RequiredError(
        'filters',
        'Required parameter "filters" was null or undefined when calling buildSLD().'
      );
    }

    const queryParameters: any = {};

    if (requestParameters['url'] != null) {
      queryParameters['url'] = requestParameters['url'];
    }

    if (requestParameters['layers'] != null) {
      queryParameters['layers'] = requestParameters['layers'];
    }

    if (requestParameters['filters'] != null) {
      queryParameters['filters'] = requestParameters['filters'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/tools/ogc/sld`,
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    if (this.isJsonMime(response.headers.get('content-type'))) {
      return new runtime.JSONApiResponse<string>(response);
    } else {
      return new runtime.TextApiResponse(response) as any;
    }
  }

  /**
   * Get the current SLD for the requested layers, add new filters in, save the SLD and return the new SLD URL.
   * Generate a SLD with a new filter
   */
  async buildSLD(
    requestParameters: BuildSLDRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<string> {
    const response = await this.buildSLDRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Call a migration step
   */
  async callStepRaw(
    requestParameters: CallStepRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters['stepName'] == null) {
      throw new runtime.RequiredError(
        'stepName',
        'Required parameter "stepName" was null or undefined when calling callStep().'
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/tools/migration/steps/{stepName}`.replace(
          `{${'stepName'}}`,
          encodeURIComponent(String(requestParameters['stepName']))
        ),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    if (this.isJsonMime(response.headers.get('content-type'))) {
      return new runtime.JSONApiResponse<string>(response);
    } else {
      return new runtime.TextApiResponse(response) as any;
    }
  }

  /**
   * Call a migration step
   */
  async callStep(
    requestParameters: CallStepRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<string> {
    const response = await this.callStepRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Clean translation packages cache.
   */
  async cleanTranslationsPackagesCacheRaw(
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<void>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/i18n/cache`,
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Clean translation packages cache.
   */
  async cleanTranslationsPackagesCache(
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<void> {
    await this.cleanTranslationsPackagesCacheRaw(initOverrides);
  }

  /**
   * Delete custom translations stored in the database.
   * Delete database translations.
   */
  async deleteTranslationsRaw(
    requestParameters: DeleteTranslationsRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters['key'] == null) {
      throw new runtime.RequiredError(
        'key',
        'Required parameter "key" was null or undefined when calling deleteTranslations().'
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/i18n/db/translations/{key}`.replace(
          `{${'key'}}`,
          encodeURIComponent(String(requestParameters['key']))
        ),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Delete custom translations stored in the database.
   * Delete database translations.
   */
  async deleteTranslations(
    requestParameters: DeleteTranslationsRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<void> {
    await this.deleteTranslationsRaw(requestParameters, initOverrides);
  }

  /**
   * Clean all SLD generated previously
   * Remove all SLD files
   */
  async deteleSLDRaw(
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<void>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/tools/ogc/sld`,
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Clean all SLD generated previously
   * Remove all SLD files
   */
  async deteleSLD(
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<void> {
    await this.deteleSLDRaw(initOverrides);
  }

  /**
   * Download a SLD
   */
  async downloadSLDRaw(
    requestParameters: DownloadSLDRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters['id'] == null) {
      throw new runtime.RequiredError(
        'id',
        'Required parameter "id" was null or undefined when calling downloadSLD().'
      );
    }

    if (requestParameters['extension'] == null) {
      throw new runtime.RequiredError(
        'extension',
        'Required parameter "extension" was null or undefined when calling downloadSLD().'
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/tools/ogc/sld/{id}.{extension}`
          .replace(
            `{${'id'}}`,
            encodeURIComponent(String(requestParameters['id']))
          )
          .replace(
            `{${'extension'}}`,
            encodeURIComponent(String(requestParameters['extension']))
          ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Download a SLD
   */
  async downloadSLD(
    requestParameters: DownloadSLDRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<void> {
    await this.downloadSLDRaw(requestParameters, initOverrides);
  }

  /**
   * List custom user translations
   */
  async getCustomTranslationsRaw(
    requestParameters: GetCustomTranslationsRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<Array<Translations>>> {
    const queryParameters: any = {};

    if (requestParameters['type'] != null) {
      queryParameters['type'] = requestParameters['type'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/i18n/db/custom`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, jsonValue =>
      jsonValue.map(TranslationsFromJSON)
    );
  }

  /**
   * List custom user translations
   */
  async getCustomTranslations(
    requestParameters: GetCustomTranslationsRequest = {},
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<Array<Translations>> {
    const response = await this.getCustomTranslationsRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * List database translations (used to overrides client application translations).
   */
  async getDbTranslationsRaw(
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<{ [key: string]: string }>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/i18n/db/translations`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse<any>(response);
  }

  /**
   * List database translations (used to overrides client application translations).
   */
  async getDbTranslations(
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<{ [key: string]: string }> {
    const response = await this.getDbTranslationsRaw(initOverrides);
    return await response.value();
  }

  /**
   * Get the list of SLD available
   */
  async getSLDRaw(
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<Array<string>>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/tools/ogc/sld`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse<any>(response);
  }

  /**
   * Get the list of SLD available
   */
  async getSLD(
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<Array<string>> {
    const response = await this.getSLDRaw(initOverrides);
    return await response.value();
  }

  /**
   * List translations for database description table
   */
  async getTranslationsRaw(
    requestParameters: GetTranslationsRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<{ [key: string]: string }>> {
    const queryParameters: any = {};

    if (requestParameters['type'] != null) {
      queryParameters['type'] = requestParameters['type'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/i18n/db`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse<any>(response);
  }

  /**
   * List translations for database description table
   */
  async getTranslations(
    requestParameters: GetTranslationsRequest = {},
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<{ [key: string]: string }> {
    const response = await this.getTranslationsRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Get a translation package.
   */
  async getTranslationsPackageRaw(
    requestParameters: GetTranslationsPackageRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<{ [key: string]: string }>> {
    if (requestParameters['pack'] == null) {
      throw new runtime.RequiredError(
        'pack',
        'Required parameter "pack" was null or undefined when calling getTranslationsPackage().'
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/i18n/packages/{pack}`.replace(
          `{${'pack'}}`,
          encodeURIComponent(String(requestParameters['pack']))
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse<any>(response);
  }

  /**
   * Get a translation package.
   */
  async getTranslationsPackage(
    requestParameters: GetTranslationsPackageRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<{ [key: string]: string }> {
    const response = await this.getTranslationsPackageRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Get list of translation packages.
   */
  async getTranslationsPackagesRaw(
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<{ [key: string]: Array<string> }>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/i18n/packages`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse<any>(response);
  }

  /**
   * Get list of translation packages.
   */
  async getTranslationsPackages(
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<{ [key: string]: Array<string> }> {
    const response = await this.getTranslationsPackagesRaw(initOverrides);
    return await response.value();
  }

  /**
   * Remove all database translations.
   */
  async removeAllTranslationsRaw(
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<void>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/i18n/db/translations`,
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Remove all database translations.
   */
  async removeAllTranslations(
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<void> {
    await this.removeAllTranslationsRaw(initOverrides);
  }

  /**
   * Send an email to the catalog feedback email.
   * Test mail configuration
   */
  async testMailConfigurationRaw(
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<string>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/tools/mail/test`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    if (this.isJsonMime(response.headers.get('content-type'))) {
      return new runtime.JSONApiResponse<string>(response);
    } else {
      return new runtime.TextApiResponse(response) as any;
    }
  }

  /**
   * Send an email to the catalog feedback email.
   * Test mail configuration
   */
  async testMailConfiguration(
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<string> {
    const response = await this.testMailConfigurationRaw(initOverrides);
    return await response.value();
  }
}
