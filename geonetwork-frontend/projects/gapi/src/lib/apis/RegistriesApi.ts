/* tslint:disable */
/* eslint-disable */
/**
 * GeoNetwork 4.4.5 OpenAPI Documentation
 * This is the description of the GeoNetwork OpenAPI. Use this API to manage your catalog.
 *
 * The version of the OpenAPI document: 4.4.5
 * Contact: geonetwork-users@lists.sourceforge.net
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as runtime from '../runtime';
import type {
  Crs,
  SimpleMetadataProcessingReport,
  ThesaurusInfo,
  UploadThesaurusRequest,
} from '../models/index';
import {
  CrsFromJSON,
  CrsToJSON,
  SimpleMetadataProcessingReportFromJSON,
  SimpleMetadataProcessingReportToJSON,
  ThesaurusInfoFromJSON,
  ThesaurusInfoToJSON,
  UploadThesaurusRequestFromJSON,
  UploadThesaurusRequestToJSON,
} from '../models/index';

export interface DeleteThesaurusRequest {
  thesaurus: string;
}

export interface ExtractEntriesRequest {
  xpath: string;
  uuids?: Array<string>;
  bucket?: string;
  identifierXpath?: string;
}

export interface GetCrsRequest {
  id: string;
}

export interface GetEntryRequest {
  uuid: string;
  process?: Array<string>;
  transformation?: string;
  lang?: Array<string>;
  schema?: string;
}

export interface GetKeywordByIdRequest {
  id: string;
  thesaurus: string;
  lang?: Array<string>;
  keywordOnly?: boolean;
  transformation?: string;
  langMap?: string;
}

export interface GetKeywordByIdsRequest {
  id: string;
  thesaurus: string;
  lang?: Array<string>;
  keywordOnly?: boolean;
  transformation?: string;
  langMap?: string;
}

export interface GetThesaurusRequest {
  thesaurus: string;
}

export interface ImportCsvAsThesaurusRequest {
  type?: ImportCsvAsThesaurusTypeEnum;
  dir?: string;
  encoding?: string;
  thesaurusNs?: string;
  languages?: Array<string>;
  thesaurusTitle?: string;
  conceptIdColumn?: string;
  conceptLabelColumn?: string;
  conceptDescriptionColumn?: string;
  conceptBroaderIdColumn?: string;
  conceptNarrowerIdColumn?: string;
  conceptRelatedIdColumn?: string;
  conceptLinkSeparator?: string;
  importAsThesaurus?: boolean;
  uploadThesaurusRequest?: UploadThesaurusRequest;
}

export interface ImportSpatialEntriesRequest {
  file: Blob;
  uuidAttribute?: string;
  uuidPattern?: string;
  descriptionAttribute?: string;
  geomProjectionTo?: string;
  lenient?: boolean;
  charset?: string;
  onlyBoundingBox?: boolean;
  process?: string;
  schema?: string;
  uuidProcessing?: ImportSpatialEntriesUuidProcessingEnum;
  group?: number;
}

export interface PreviewExtractedEntriesRequest {
  xpath: string;
  uuids?: Array<string>;
  bucket?: string;
  identifierXpath?: string;
}

export interface PreviewUpdatedRecordEntriesRequest {
  xpath: string;
  uuids?: Array<string>;
  bucket?: string;
  identifierXpath?: string;
  propertiesToCopy?: Array<string>;
  substituteAsXLink?: boolean;
  fq?: string;
}

export interface SearchCrsRequest {
  q?: string;
  type?: SearchCrsTypeEnum;
  rows?: number;
}

export interface SearchKeywordsRequest {
  q?: string;
  lang?: string;
  rows?: number;
  start?: number;
  pLang?: Array<string>;
  thesaurus?: Array<string>;
  type?: SearchKeywordsTypeEnum;
  uri?: string;
  sort?: string;
}

export interface UpdateRecordEntriesRequest {
  xpath: string;
  uuids?: Array<string>;
  bucket?: string;
  identifierXpath?: string;
  propertiesToCopy?: Array<string>;
  substituteAsXLink?: boolean;
  fq?: string;
}

export interface UpdateThesaurusRequest {
  thesaurus: string;
  thesaurusInfo: ThesaurusInfo;
}

export interface UploadThesaurusOperationRequest {
  type?: UploadThesaurusOperationTypeEnum;
  dir?: string;
  stylesheet?: string;
  uploadThesaurusRequest?: UploadThesaurusRequest;
}

export interface UploadThesaurusFromUrlRequest {
  url?: string;
  registryUrl?: string;
  registryType?: UploadThesaurusFromUrlRegistryTypeEnum;
  registryLanguage?: Array<string>;
  type?: UploadThesaurusFromUrlTypeEnum;
  dir?: string;
  stylesheet?: string;
  thesaurusInfo?: ThesaurusInfo;
}

/**
 *
 */
export class RegistriesApi extends runtime.BaseAPI {
  /**
   * Delete a thesaurus.
   * Delete a thesaurus by name
   */
  async deleteThesaurusRaw(
    requestParameters: DeleteThesaurusRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters['thesaurus'] == null) {
      throw new runtime.RequiredError(
        'thesaurus',
        'Required parameter "thesaurus" was null or undefined when calling deleteThesaurus().'
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/registries/vocabularies/{thesaurus}`.replace(
          `{${'thesaurus'}}`,
          encodeURIComponent(String(requestParameters['thesaurus']))
        ),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Delete a thesaurus.
   * Delete a thesaurus by name
   */
  async deleteThesaurus(
    requestParameters: DeleteThesaurusRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<void> {
    await this.deleteThesaurusRaw(requestParameters, initOverrides);
  }

  /**
   * Scan one or more records for element matching the XPath provided and save them as directory entries (ie. subtemplate).<br/><br/>Only records that the current user can edit are analyzed.<br/><br/>Examples:<br/>For ISO19115-3 records, use .//cit:CI_Responsibility and compute identifier based on email with .//cit:electronicMailAddress/_*_/text() to create a contact directory.
   * Extracts directory entries from records
   */
  async extractEntriesRaw(
    requestParameters: ExtractEntriesRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<object>> {
    if (requestParameters['xpath'] == null) {
      throw new runtime.RequiredError(
        'xpath',
        'Required parameter "xpath" was null or undefined when calling extractEntries().'
      );
    }

    const queryParameters: any = {};

    if (requestParameters['uuids'] != null) {
      queryParameters['uuids'] = requestParameters['uuids'];
    }

    if (requestParameters['bucket'] != null) {
      queryParameters['bucket'] = requestParameters['bucket'];
    }

    if (requestParameters['xpath'] != null) {
      queryParameters['xpath'] = requestParameters['xpath'];
    }

    if (requestParameters['identifierXpath'] != null) {
      queryParameters['identifierXpath'] = requestParameters['identifierXpath'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/registries/actions/entries/collect`,
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse<any>(response);
  }

  /**
   * Scan one or more records for element matching the XPath provided and save them as directory entries (ie. subtemplate).<br/><br/>Only records that the current user can edit are analyzed.<br/><br/>Examples:<br/>For ISO19115-3 records, use .//cit:CI_Responsibility and compute identifier based on email with .//cit:electronicMailAddress/_*_/text() to create a contact directory.
   * Extracts directory entries from records
   */
  async extractEntries(
    requestParameters: ExtractEntriesRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<object> {
    const response = await this.extractEntriesRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Get CRS
   */
  async getCrsRaw(
    requestParameters: GetCrsRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<Crs>> {
    if (requestParameters['id'] == null) {
      throw new runtime.RequiredError(
        'id',
        'Required parameter "id" was null or undefined when calling getCrs().'
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/registries/crs/{id}`.replace(
          `{${'id'}}`,
          encodeURIComponent(String(requestParameters['id']))
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, jsonValue =>
      CrsFromJSON(jsonValue)
    );
  }

  /**
   * Get CRS
   */
  async getCrs(
    requestParameters: GetCrsRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<Crs> {
    const response = await this.getCrsRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Get list of CRS type
   */
  async getCrsTypesRaw(
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<Array<string>>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/registries/crs/types`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse<any>(response);
  }

  /**
   * Get list of CRS type
   */
  async getCrsTypes(
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<Array<string>> {
    const response = await this.getCrsTypesRaw(initOverrides);
    return await response.value();
  }

  /**
   * Directory entry (AKA subtemplates) are XML fragments that can be inserted in metadata records using XLinks. XLinks can be remote or local.
   * Get a directory entry
   */
  async getEntryRaw(
    requestParameters: GetEntryRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters['uuid'] == null) {
      throw new runtime.RequiredError(
        'uuid',
        'Required parameter "uuid" was null or undefined when calling getEntry().'
      );
    }

    const queryParameters: any = {};

    if (requestParameters['process'] != null) {
      queryParameters['process'] = requestParameters['process'];
    }

    if (requestParameters['transformation'] != null) {
      queryParameters['transformation'] = requestParameters['transformation'];
    }

    if (requestParameters['lang'] != null) {
      queryParameters['lang'] = requestParameters['lang'];
    }

    if (requestParameters['schema'] != null) {
      queryParameters['schema'] = requestParameters['schema'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/registries/entries/{uuid}`.replace(
          `{${'uuid'}}`,
          encodeURIComponent(String(requestParameters['uuid']))
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Directory entry (AKA subtemplates) are XML fragments that can be inserted in metadata records using XLinks. XLinks can be remote or local.
   * Get a directory entry
   */
  async getEntry(
    requestParameters: GetEntryRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<void> {
    await this.getEntryRaw(requestParameters, initOverrides);
  }

  /**
   * Retrieve XML representation of keyword(s) from same thesaurususing different transformations. \'to-iso19139-keyword\' is the default and return an ISO19139 snippet.\'to-iso19139-keyword-as-xlink\' return an XLinked element. Custom transformation can be create on a per schema basis.
   * Get keyword by id
   */
  async getKeywordByIdRaw(
    requestParameters: GetKeywordByIdRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<object>> {
    if (requestParameters['id'] == null) {
      throw new runtime.RequiredError(
        'id',
        'Required parameter "id" was null or undefined when calling getKeywordById().'
      );
    }

    if (requestParameters['thesaurus'] == null) {
      throw new runtime.RequiredError(
        'thesaurus',
        'Required parameter "thesaurus" was null or undefined when calling getKeywordById().'
      );
    }

    const queryParameters: any = {};

    if (requestParameters['id'] != null) {
      queryParameters['id'] = requestParameters['id'];
    }

    if (requestParameters['thesaurus'] != null) {
      queryParameters['thesaurus'] = requestParameters['thesaurus'];
    }

    if (requestParameters['lang'] != null) {
      queryParameters['lang'] = requestParameters['lang'];
    }

    if (requestParameters['keywordOnly'] != null) {
      queryParameters['keywordOnly'] = requestParameters['keywordOnly'];
    }

    if (requestParameters['transformation'] != null) {
      queryParameters['transformation'] = requestParameters['transformation'];
    }

    if (requestParameters['langMap'] != null) {
      queryParameters['langMap'] = requestParameters['langMap'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/registries/vocabularies/keyword`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse<any>(response);
  }

  /**
   * Retrieve XML representation of keyword(s) from same thesaurususing different transformations. \'to-iso19139-keyword\' is the default and return an ISO19139 snippet.\'to-iso19139-keyword-as-xlink\' return an XLinked element. Custom transformation can be create on a per schema basis.
   * Get keyword by id
   */
  async getKeywordById(
    requestParameters: GetKeywordByIdRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<object> {
    const response = await this.getKeywordByIdRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Retrieve XML representation of keyword(s) from same thesaurususing different transformations. \'to-iso19139-keyword\' is the default and return an ISO19139 snippet.\'to-iso19139-keyword-as-xlink\' return an XLinked element. Custom transformation can be create on a per schema basis.This can be used instead of the GET method for cases where you need to submit large parameters list
   * Get keyword by ids
   */
  async getKeywordByIdsRaw(
    requestParameters: GetKeywordByIdsRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<object>> {
    if (requestParameters['id'] == null) {
      throw new runtime.RequiredError(
        'id',
        'Required parameter "id" was null or undefined when calling getKeywordByIds().'
      );
    }

    if (requestParameters['thesaurus'] == null) {
      throw new runtime.RequiredError(
        'thesaurus',
        'Required parameter "thesaurus" was null or undefined when calling getKeywordByIds().'
      );
    }

    const queryParameters: any = {};

    if (requestParameters['id'] != null) {
      queryParameters['id'] = requestParameters['id'];
    }

    if (requestParameters['thesaurus'] != null) {
      queryParameters['thesaurus'] = requestParameters['thesaurus'];
    }

    if (requestParameters['lang'] != null) {
      queryParameters['lang'] = requestParameters['lang'];
    }

    if (requestParameters['keywordOnly'] != null) {
      queryParameters['keywordOnly'] = requestParameters['keywordOnly'];
    }

    if (requestParameters['transformation'] != null) {
      queryParameters['transformation'] = requestParameters['transformation'];
    }

    if (requestParameters['langMap'] != null) {
      queryParameters['langMap'] = requestParameters['langMap'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/registries/vocabularies/keyword`,
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse<any>(response);
  }

  /**
   * Retrieve XML representation of keyword(s) from same thesaurususing different transformations. \'to-iso19139-keyword\' is the default and return an ISO19139 snippet.\'to-iso19139-keyword-as-xlink\' return an XLinked element. Custom transformation can be create on a per schema basis.This can be used instead of the GET method for cases where you need to submit large parameters list
   * Get keyword by ids
   */
  async getKeywordByIds(
    requestParameters: GetKeywordByIdsRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<object> {
    const response = await this.getKeywordByIdsRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Download the thesaurus in SKOS format.
   * Download a thesaurus by name
   */
  async getThesaurusRaw(
    requestParameters: GetThesaurusRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<Blob>> {
    if (requestParameters['thesaurus'] == null) {
      throw new runtime.RequiredError(
        'thesaurus',
        'Required parameter "thesaurus" was null or undefined when calling getThesaurus().'
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/registries/vocabularies/{thesaurus}`.replace(
          `{${'thesaurus'}}`,
          encodeURIComponent(String(requestParameters['thesaurus']))
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.BlobApiResponse(response);
  }

  /**
   * Download the thesaurus in SKOS format.
   * Download a thesaurus by name
   */
  async getThesaurus(
    requestParameters: GetThesaurusRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<Blob> {
    const response = await this.getThesaurusRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * CSV file MUST contains columns at least for concept id and label. For multilingual thesaurus, consider using columns like label, label_fre, label_ita with languages parameter set to [en, fr, it]. Default language value is used if translations are empty. The thesaurus filename will be the filename of the CSV file (with .rdf extension). It is recommended to set the thesaurus title and namespace URL even if default values will be used based on the filename. Thesaurus dates are set to the date of import.
   * Uploads a CSV file and convert it to SKOS format
   */
  async importCsvAsThesaurusRaw(
    requestParameters: ImportCsvAsThesaurusRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<void>> {
    const queryParameters: any = {};

    if (requestParameters['type'] != null) {
      queryParameters['type'] = requestParameters['type'];
    }

    if (requestParameters['dir'] != null) {
      queryParameters['dir'] = requestParameters['dir'];
    }

    if (requestParameters['encoding'] != null) {
      queryParameters['encoding'] = requestParameters['encoding'];
    }

    if (requestParameters['thesaurusNs'] != null) {
      queryParameters['thesaurusNs'] = requestParameters['thesaurusNs'];
    }

    if (requestParameters['languages'] != null) {
      queryParameters['languages'] = requestParameters['languages'];
    }

    if (requestParameters['thesaurusTitle'] != null) {
      queryParameters['thesaurusTitle'] = requestParameters['thesaurusTitle'];
    }

    if (requestParameters['conceptIdColumn'] != null) {
      queryParameters['conceptIdColumn'] = requestParameters['conceptIdColumn'];
    }

    if (requestParameters['conceptLabelColumn'] != null) {
      queryParameters['conceptLabelColumn'] =
        requestParameters['conceptLabelColumn'];
    }

    if (requestParameters['conceptDescriptionColumn'] != null) {
      queryParameters['conceptDescriptionColumn'] =
        requestParameters['conceptDescriptionColumn'];
    }

    if (requestParameters['conceptBroaderIdColumn'] != null) {
      queryParameters['conceptBroaderIdColumn'] =
        requestParameters['conceptBroaderIdColumn'];
    }

    if (requestParameters['conceptNarrowerIdColumn'] != null) {
      queryParameters['conceptNarrowerIdColumn'] =
        requestParameters['conceptNarrowerIdColumn'];
    }

    if (requestParameters['conceptRelatedIdColumn'] != null) {
      queryParameters['conceptRelatedIdColumn'] =
        requestParameters['conceptRelatedIdColumn'];
    }

    if (requestParameters['conceptLinkSeparator'] != null) {
      queryParameters['conceptLinkSeparator'] =
        requestParameters['conceptLinkSeparator'];
    }

    if (requestParameters['importAsThesaurus'] != null) {
      queryParameters['importAsThesaurus'] =
        requestParameters['importAsThesaurus'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/registries/vocabularies/import/csv`,
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: UploadThesaurusRequestToJSON(
          requestParameters['uploadThesaurusRequest']
        ),
      },
      initOverrides
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * CSV file MUST contains columns at least for concept id and label. For multilingual thesaurus, consider using columns like label, label_fre, label_ita with languages parameter set to [en, fr, it]. Default language value is used if translations are empty. The thesaurus filename will be the filename of the CSV file (with .rdf extension). It is recommended to set the thesaurus title and namespace URL even if default values will be used based on the filename. Thesaurus dates are set to the date of import.
   * Uploads a CSV file and convert it to SKOS format
   */
  async importCsvAsThesaurus(
    requestParameters: ImportCsvAsThesaurusRequest = {},
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<void> {
    await this.importCsvAsThesaurusRaw(requestParameters, initOverrides);
  }

  /**
   * Directory entry (AKA subtemplates) are XML fragments that can be inserted in metadata records. Use this service to import geographic extent entries from an ESRI Shapefile format.
   * Import spatial directory entries
   */
  async importSpatialEntriesRaw(
    requestParameters: ImportSpatialEntriesRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<SimpleMetadataProcessingReport>> {
    if (requestParameters['file'] == null) {
      throw new runtime.RequiredError(
        'file',
        'Required parameter "file" was null or undefined when calling importSpatialEntries().'
      );
    }

    const queryParameters: any = {};

    if (requestParameters['uuidAttribute'] != null) {
      queryParameters['uuidAttribute'] = requestParameters['uuidAttribute'];
    }

    if (requestParameters['uuidPattern'] != null) {
      queryParameters['uuidPattern'] = requestParameters['uuidPattern'];
    }

    if (requestParameters['descriptionAttribute'] != null) {
      queryParameters['descriptionAttribute'] =
        requestParameters['descriptionAttribute'];
    }

    if (requestParameters['geomProjectionTo'] != null) {
      queryParameters['geomProjectionTo'] =
        requestParameters['geomProjectionTo'];
    }

    if (requestParameters['lenient'] != null) {
      queryParameters['lenient'] = requestParameters['lenient'];
    }

    if (requestParameters['charset'] != null) {
      queryParameters['charset'] = requestParameters['charset'];
    }

    if (requestParameters['onlyBoundingBox'] != null) {
      queryParameters['onlyBoundingBox'] = requestParameters['onlyBoundingBox'];
    }

    if (requestParameters['process'] != null) {
      queryParameters['process'] = requestParameters['process'];
    }

    if (requestParameters['schema'] != null) {
      queryParameters['schema'] = requestParameters['schema'];
    }

    if (requestParameters['uuidProcessing'] != null) {
      queryParameters['uuidProcessing'] = requestParameters['uuidProcessing'];
    }

    if (requestParameters['group'] != null) {
      queryParameters['group'] = requestParameters['group'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const consumes: runtime.Consume[] = [
      { contentType: 'multipart/form-data' },
    ];
    // @ts-ignore: canConsumeForm may be unused
    const canConsumeForm = runtime.canConsumeForm(consumes);

    let formParams: { append(param: string, value: any): any };
    let useForm = false;
    // use FormData to transmit files using content-type "multipart/form-data"
    useForm = canConsumeForm;
    if (useForm) {
      formParams = new FormData();
    } else {
      formParams = new URLSearchParams();
    }

    if (requestParameters['file'] != null) {
      formParams.append('file', requestParameters['file'] as any);
    }

    const response = await this.request(
      {
        path: `/registries/actions/entries/import/spatial`,
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: formParams,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, jsonValue =>
      SimpleMetadataProcessingReportFromJSON(jsonValue)
    );
  }

  /**
   * Directory entry (AKA subtemplates) are XML fragments that can be inserted in metadata records. Use this service to import geographic extent entries from an ESRI Shapefile format.
   * Import spatial directory entries
   */
  async importSpatialEntries(
    requestParameters: ImportSpatialEntriesRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<SimpleMetadataProcessingReport> {
    const response = await this.importSpatialEntriesRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Scan one or more records for element matching the XPath provided and save them as directory entries (ie. subtemplate).<br/><br/>Only records that the current user can edit are analyzed.<br/><br/>Examples:<br/>For ISO19115-3 records, use .//cit:CI_Responsibility and compute identifier based on email with .//cit:electronicMailAddress/_*_/text() to create a contact directory.
   * Preview directory entries extracted from records
   */
  async previewExtractedEntriesRaw(
    requestParameters: PreviewExtractedEntriesRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<object>> {
    if (requestParameters['xpath'] == null) {
      throw new runtime.RequiredError(
        'xpath',
        'Required parameter "xpath" was null or undefined when calling previewExtractedEntries().'
      );
    }

    const queryParameters: any = {};

    if (requestParameters['uuids'] != null) {
      queryParameters['uuids'] = requestParameters['uuids'];
    }

    if (requestParameters['bucket'] != null) {
      queryParameters['bucket'] = requestParameters['bucket'];
    }

    if (requestParameters['xpath'] != null) {
      queryParameters['xpath'] = requestParameters['xpath'];
    }

    if (requestParameters['identifierXpath'] != null) {
      queryParameters['identifierXpath'] = requestParameters['identifierXpath'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/registries/actions/entries/collect`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse<any>(response);
  }

  /**
   * Scan one or more records for element matching the XPath provided and save them as directory entries (ie. subtemplate).<br/><br/>Only records that the current user can edit are analyzed.<br/><br/>Examples:<br/>For ISO19115-3 records, use .//cit:CI_Responsibility and compute identifier based on email with .//cit:electronicMailAddress/_*_/text() to create a contact directory.
   * Preview directory entries extracted from records
   */
  async previewExtractedEntries(
    requestParameters: PreviewExtractedEntriesRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<object> {
    const response = await this.previewExtractedEntriesRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Scan one or more records for element matching the XPath provided and then check if this element is available in the directory. If Found, the element from the directory update the element in the record and optionally text or attribute value properties are preserved using propertiesToCopy. Elements can be lost if not existing in the directory entry (eg. from an gex:Extent directory containing only description and bounding polygon, the update can remove temporal element).<br/><br/>The identifier XPath is used to find a match. An optional filtercan be added to restrict search to a subset of the directory. If no identifier XPaths is provided, the UUID is based on the content of the snippet (hash). It is recommended to use an identifier for better matching (eg. ISO19139 contact with different roles will not match on the automatic UUID mode).
   * Preview updated matching entries in records
   */
  async previewUpdatedRecordEntriesRaw(
    requestParameters: PreviewUpdatedRecordEntriesRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<object>> {
    if (requestParameters['xpath'] == null) {
      throw new runtime.RequiredError(
        'xpath',
        'Required parameter "xpath" was null or undefined when calling previewUpdatedRecordEntries().'
      );
    }

    const queryParameters: any = {};

    if (requestParameters['uuids'] != null) {
      queryParameters['uuids'] = requestParameters['uuids'];
    }

    if (requestParameters['bucket'] != null) {
      queryParameters['bucket'] = requestParameters['bucket'];
    }

    if (requestParameters['xpath'] != null) {
      queryParameters['xpath'] = requestParameters['xpath'];
    }

    if (requestParameters['identifierXpath'] != null) {
      queryParameters['identifierXpath'] = requestParameters['identifierXpath'];
    }

    if (requestParameters['propertiesToCopy'] != null) {
      queryParameters['propertiesToCopy'] =
        requestParameters['propertiesToCopy'];
    }

    if (requestParameters['substituteAsXLink'] != null) {
      queryParameters['substituteAsXLink'] =
        requestParameters['substituteAsXLink'];
    }

    if (requestParameters['fq'] != null) {
      queryParameters['fq'] = requestParameters['fq'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/registries/actions/entries/synchronize`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse<any>(response);
  }

  /**
   * Scan one or more records for element matching the XPath provided and then check if this element is available in the directory. If Found, the element from the directory update the element in the record and optionally text or attribute value properties are preserved using propertiesToCopy. Elements can be lost if not existing in the directory entry (eg. from an gex:Extent directory containing only description and bounding polygon, the update can remove temporal element).<br/><br/>The identifier XPath is used to find a match. An optional filtercan be added to restrict search to a subset of the directory. If no identifier XPaths is provided, the UUID is based on the content of the snippet (hash). It is recommended to use an identifier for better matching (eg. ISO19139 contact with different roles will not match on the automatic UUID mode).
   * Preview updated matching entries in records
   */
  async previewUpdatedRecordEntries(
    requestParameters: PreviewUpdatedRecordEntriesRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<object> {
    const response = await this.previewUpdatedRecordEntriesRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Based on GeoTools EPSG database. If phrase query, each words are searched separately.
   * Search coordinate reference system (CRS)
   */
  async searchCrsRaw(
    requestParameters: SearchCrsRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<Array<Crs>>> {
    const queryParameters: any = {};

    if (requestParameters['q'] != null) {
      queryParameters['q'] = requestParameters['q'];
    }

    if (requestParameters['type'] != null) {
      queryParameters['type'] = requestParameters['type'];
    }

    if (requestParameters['rows'] != null) {
      queryParameters['rows'] = requestParameters['rows'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/registries/crs`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, jsonValue =>
      jsonValue.map(CrsFromJSON)
    );
  }

  /**
   * Based on GeoTools EPSG database. If phrase query, each words are searched separately.
   * Search coordinate reference system (CRS)
   */
  async searchCrs(
    requestParameters: SearchCrsRequest = {},
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<Array<Crs>> {
    const response = await this.searchCrsRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Search keywords
   */
  async searchKeywordsRaw(
    requestParameters: SearchKeywordsRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<object>> {
    const queryParameters: any = {};

    if (requestParameters['q'] != null) {
      queryParameters['q'] = requestParameters['q'];
    }

    if (requestParameters['lang'] != null) {
      queryParameters['lang'] = requestParameters['lang'];
    }

    if (requestParameters['rows'] != null) {
      queryParameters['rows'] = requestParameters['rows'];
    }

    if (requestParameters['start'] != null) {
      queryParameters['start'] = requestParameters['start'];
    }

    if (requestParameters['pLang'] != null) {
      queryParameters['pLang'] = requestParameters['pLang'];
    }

    if (requestParameters['thesaurus'] != null) {
      queryParameters['thesaurus'] = requestParameters['thesaurus'];
    }

    if (requestParameters['type'] != null) {
      queryParameters['type'] = requestParameters['type'];
    }

    if (requestParameters['uri'] != null) {
      queryParameters['uri'] = requestParameters['uri'];
    }

    if (requestParameters['sort'] != null) {
      queryParameters['sort'] = requestParameters['sort'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/registries/vocabularies/search`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse<any>(response);
  }

  /**
   * Search keywords
   */
  async searchKeywords(
    requestParameters: SearchKeywordsRequest = {},
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<object> {
    const response = await this.searchKeywordsRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Scan one or more records for element matching the XPath provided and then check if this element is available in the directory. If Found, the element from the directory update the element in the record and optionally text or attribute value properties are preserved using propertiesToCopy. Elements can be lost if not existing in the directory entry (eg. from an gex:Extent directory containing only description and bounding polygon, the update can remove temporal element).<br/><br/>The identifier XPath is used to find a match. An optional filtercan be added to restrict search to a subset of the directory. If no identifier XPaths is provided, the UUID is based on the content of the snippet (hash). It is recommended to use an identifier for better matching (eg. ISO19139 contact with different roles will not match on the automatic UUID mode).
   * Update matching entries in records
   */
  async updateRecordEntriesRaw(
    requestParameters: UpdateRecordEntriesRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<object>> {
    if (requestParameters['xpath'] == null) {
      throw new runtime.RequiredError(
        'xpath',
        'Required parameter "xpath" was null or undefined when calling updateRecordEntries().'
      );
    }

    const queryParameters: any = {};

    if (requestParameters['uuids'] != null) {
      queryParameters['uuids'] = requestParameters['uuids'];
    }

    if (requestParameters['bucket'] != null) {
      queryParameters['bucket'] = requestParameters['bucket'];
    }

    if (requestParameters['xpath'] != null) {
      queryParameters['xpath'] = requestParameters['xpath'];
    }

    if (requestParameters['identifierXpath'] != null) {
      queryParameters['identifierXpath'] = requestParameters['identifierXpath'];
    }

    if (requestParameters['propertiesToCopy'] != null) {
      queryParameters['propertiesToCopy'] =
        requestParameters['propertiesToCopy'];
    }

    if (requestParameters['substituteAsXLink'] != null) {
      queryParameters['substituteAsXLink'] =
        requestParameters['substituteAsXLink'];
    }

    if (requestParameters['fq'] != null) {
      queryParameters['fq'] = requestParameters['fq'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/registries/actions/entries/synchronize`,
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse<any>(response);
  }

  /**
   * Scan one or more records for element matching the XPath provided and then check if this element is available in the directory. If Found, the element from the directory update the element in the record and optionally text or attribute value properties are preserved using propertiesToCopy. Elements can be lost if not existing in the directory entry (eg. from an gex:Extent directory containing only description and bounding polygon, the update can remove temporal element).<br/><br/>The identifier XPath is used to find a match. An optional filtercan be added to restrict search to a subset of the directory. If no identifier XPaths is provided, the UUID is based on the content of the snippet (hash). It is recommended to use an identifier for better matching (eg. ISO19139 contact with different roles will not match on the automatic UUID mode).
   * Update matching entries in records
   */
  async updateRecordEntries(
    requestParameters: UpdateRecordEntriesRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<object> {
    const response = await this.updateRecordEntriesRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Updates the information of a local thesaurus.
   * Updates the information of a local thesaurus
   */
  async updateThesaurusRaw(
    requestParameters: UpdateThesaurusRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters['thesaurus'] == null) {
      throw new runtime.RequiredError(
        'thesaurus',
        'Required parameter "thesaurus" was null or undefined when calling updateThesaurus().'
      );
    }

    if (requestParameters['thesaurusInfo'] == null) {
      throw new runtime.RequiredError(
        'thesaurusInfo',
        'Required parameter "thesaurusInfo" was null or undefined when calling updateThesaurus().'
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/registries/vocabularies/{thesaurus}`.replace(
          `{${'thesaurus'}}`,
          encodeURIComponent(String(requestParameters['thesaurus']))
        ),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: ThesaurusInfoToJSON(requestParameters['thesaurusInfo']),
      },
      initOverrides
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Updates the information of a local thesaurus.
   * Updates the information of a local thesaurus
   */
  async updateThesaurus(
    requestParameters: UpdateThesaurusRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<void> {
    await this.updateThesaurusRaw(requestParameters, initOverrides);
  }

  /**
   * Supported thesaurus are RDF/XML files using SKOS specification, OWL file describing NamedIndividual elements or SDMX file describing Codelist element. For RDF, extension must be .rdf or .xml, for OWL, .owl and for SDMX, .sdmx.
   * Uploads a new thesaurus from a file
   */
  async uploadThesaurusRaw(
    requestParameters: UploadThesaurusOperationRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<string>> {
    const queryParameters: any = {};

    if (requestParameters['type'] != null) {
      queryParameters['type'] = requestParameters['type'];
    }

    if (requestParameters['dir'] != null) {
      queryParameters['dir'] = requestParameters['dir'];
    }

    if (requestParameters['stylesheet'] != null) {
      queryParameters['stylesheet'] = requestParameters['stylesheet'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/registries/vocabularies`,
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: UploadThesaurusRequestToJSON(
          requestParameters['uploadThesaurusRequest']
        ),
      },
      initOverrides
    );

    if (this.isJsonMime(response.headers.get('content-type'))) {
      return new runtime.JSONApiResponse<string>(response);
    } else {
      return new runtime.TextApiResponse(response) as any;
    }
  }

  /**
   * Supported thesaurus are RDF/XML files using SKOS specification, OWL file describing NamedIndividual elements or SDMX file describing Codelist element. For RDF, extension must be .rdf or .xml, for OWL, .owl and for SDMX, .sdmx.
   * Uploads a new thesaurus from a file
   */
  async uploadThesaurus(
    requestParameters: UploadThesaurusOperationRequest = {},
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<string> {
    const response = await this.uploadThesaurusRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Uploads a new thesaurus.
   * Uploads a new thesaurus from URL or Registry
   */
  async uploadThesaurusFromUrlRaw(
    requestParameters: UploadThesaurusFromUrlRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<string>> {
    const queryParameters: any = {};

    if (requestParameters['url'] != null) {
      queryParameters['url'] = requestParameters['url'];
    }

    if (requestParameters['registryUrl'] != null) {
      queryParameters['registryUrl'] = requestParameters['registryUrl'];
    }

    if (requestParameters['registryType'] != null) {
      queryParameters['registryType'] = requestParameters['registryType'];
    }

    if (requestParameters['registryLanguage'] != null) {
      queryParameters['registryLanguage'] =
        requestParameters['registryLanguage'];
    }

    if (requestParameters['type'] != null) {
      queryParameters['type'] = requestParameters['type'];
    }

    if (requestParameters['dir'] != null) {
      queryParameters['dir'] = requestParameters['dir'];
    }

    if (requestParameters['stylesheet'] != null) {
      queryParameters['stylesheet'] = requestParameters['stylesheet'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/registries/vocabularies`,
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: ThesaurusInfoToJSON(requestParameters['thesaurusInfo']),
      },
      initOverrides
    );

    if (this.isJsonMime(response.headers.get('content-type'))) {
      return new runtime.JSONApiResponse<string>(response);
    } else {
      return new runtime.TextApiResponse(response) as any;
    }
  }

  /**
   * Uploads a new thesaurus.
   * Uploads a new thesaurus from URL or Registry
   */
  async uploadThesaurusFromUrl(
    requestParameters: UploadThesaurusFromUrlRequest = {},
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<string> {
    const response = await this.uploadThesaurusFromUrlRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }
}

/**
 * @export
 */
export const ImportCsvAsThesaurusTypeEnum = {
  External: 'external',
  Local: 'local',
} as const;
export type ImportCsvAsThesaurusTypeEnum =
  (typeof ImportCsvAsThesaurusTypeEnum)[keyof typeof ImportCsvAsThesaurusTypeEnum];
/**
 * @export
 */
export const ImportSpatialEntriesUuidProcessingEnum = {
  Generateuuid: 'GENERATEUUID',
  Nothing: 'NOTHING',
  Overwrite: 'OVERWRITE',
  RemoveAndReplace: 'REMOVE_AND_REPLACE',
} as const;
export type ImportSpatialEntriesUuidProcessingEnum =
  (typeof ImportSpatialEntriesUuidProcessingEnum)[keyof typeof ImportSpatialEntriesUuidProcessingEnum];
/**
 * @export
 */
export const SearchCrsTypeEnum = {
  CoordinateReferenceSystem: 'CoordinateReferenceSystem',
  VerticalCrs: 'VerticalCRS',
  GeographicCrs: 'GeographicCRS',
  ProjectedCrs: 'ProjectedCRS',
} as const;
export type SearchCrsTypeEnum =
  (typeof SearchCrsTypeEnum)[keyof typeof SearchCrsTypeEnum];
/**
 * @export
 */
export const SearchKeywordsTypeEnum = {
  StartsWith: 'STARTS_WITH',
  Contains: 'CONTAINS',
  Match: 'MATCH',
} as const;
export type SearchKeywordsTypeEnum =
  (typeof SearchKeywordsTypeEnum)[keyof typeof SearchKeywordsTypeEnum];
/**
 * @export
 */
export const UploadThesaurusOperationTypeEnum = {
  External: 'external',
  Local: 'local',
} as const;
export type UploadThesaurusOperationTypeEnum =
  (typeof UploadThesaurusOperationTypeEnum)[keyof typeof UploadThesaurusOperationTypeEnum];
/**
 * @export
 */
export const UploadThesaurusFromUrlRegistryTypeEnum = {
  Re3gistry: 're3gistry',
  LdRegistry: 'ldRegistry',
} as const;
export type UploadThesaurusFromUrlRegistryTypeEnum =
  (typeof UploadThesaurusFromUrlRegistryTypeEnum)[keyof typeof UploadThesaurusFromUrlRegistryTypeEnum];
/**
 * @export
 */
export const UploadThesaurusFromUrlTypeEnum = {
  External: 'external',
  Local: 'local',
} as const;
export type UploadThesaurusFromUrlTypeEnum =
  (typeof UploadThesaurusFromUrlTypeEnum)[keyof typeof UploadThesaurusFromUrlTypeEnum];
